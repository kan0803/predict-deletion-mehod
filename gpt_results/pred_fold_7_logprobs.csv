status,method,filepath,class_name,predict,prob_deleted,reason
survived,"def test_positional_only_compatibility():
    old_code = ""def func(a, /): pass""
    new_code = ""def func(b, /): pass""

    old_tree = ast.parse(old_code)
    new_tree = ast.parse(new_code)
    errors = check_signature_compatibility(old_tree.body[0], new_tree.body[0])

    assert len(errors) == 1
    assert ""Positional param order/name changed: 'a' -> 'b'."" in errors[0].message
",tests/dev/test_check_function_signatures.py,,1,9.736200303530205e-10,"The method `test_positional_only_compatibility` is a unit test designed to verify the functionality of a specific feature, namely the compatibility of positional-only parameters in function signatures. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with changes in code behavior or API contracts. This test checks if the system correctly identifies changes in positional-only parameter names, which is an important aspect of maintaining backward compatibility. Therefore, this method is likely to be retained as it serves a valuable purpose in the codebase."
survived,"def test_no_changes():
    old_code = ""def func(a, b=1): pass""
    new_code = ""def func(a, b=1): pass""

    old_tree = ast.parse(old_code)
    new_tree = ast.parse(new_code)
    errors = check_signature_compatibility(old_tree.body[0], new_tree.body[0])

    assert len(errors) == 0
",tests/dev/test_check_function_signatures.py,,1,2.2159489282323004e-08,"The method 'test_no_changes' is a unit test designed to verify that there are no changes in the function signature between 'old_code' and 'new_code'. It uses the 'ast' module to parse the code and checks for signature compatibility using 'check_signature_compatibility'. The test asserts that there are no errors, which is a valid and useful test case for ensuring backward compatibility of function signatures. Therefore, it is likely to be retained as it serves a clear purpose in testing code stability."
survived,"    def format(self, github: bool = False) -> str:
        message = "" "".join(self.lines)
        if github:
            return f""::warning file={self.file_path},line={self.line},col={self.column}::{message}""
        else:
            return f""{self.file_path}:{self.line}:{self.column}: {message}""
",dev/check_function_signatures.py,Error,1,1.4166087846364157e-09,"The method 'format' is a utility function that formats a message string based on the input parameters. It provides two different formats depending on whether the 'github' flag is set to True or False. This kind of functionality is useful for logging or displaying messages in different contexts, such as in a GitHub Actions environment or a local development environment. The method is simple, clear, and serves a specific purpose, making it likely to be retained in the codebase."
survived,"def test_move_matrix_pandas_min_count_simple(func_name, window, min_count):
    """"""Test matrix functions against pandas with different min_count values.""""""
    # Create test array directly
    rs = np.random.RandomState(0)
    array = rs.rand(4, 15)

    # Get the function
    func = (
        move_nancorrmatrix if func_name == ""move_nancorrmatrix"" else move_nancovmatrix
    )

    # Get comparisons
    c = COMPARISONS[func]

    # Get numbagg result
    result = c[""numbagg""](array, window=window, min_count=min_count)()

    # Get pandas result and convert to our format
    pandas_callable = c[""pandas""](array, window=window, min_count=min_count)
    pandas_result = pandas_callable()

    # Convert pandas MultiIndex DataFrame to 3D array
    n_obs = array.shape[-1]
    n_vars = array.shape[-2]
    expected_pandas = np.full((n_obs, n_vars, n_vars), np.nan)

    for t in range(n_obs):
        if t in pandas_result.index.get_level_values(0):
            expected_pandas[t] = pandas_result.loc[t].values

    assert_allclose(result, expected_pandas)
",numbagg/test/test_moving.py,,1,2.3823698451773172e-07,"The method `test_move_matrix_pandas_min_count_simple` is a test function that compares the output of a custom matrix function (either `move_nancorrmatrix` or `move_nancovmatrix`) with the output of a similar function implemented in pandas. It uses assertions to ensure that the results are close, which is a common practice in testing to verify the correctness of code. Test functions are generally crucial for maintaining code quality and ensuring that changes do not introduce bugs. Therefore, it is unlikely that this method will be deleted as it serves an important role in validating the functionality of the code."
survived,"    def gufunc(self, *, target):
        vectorize = numba.guvectorize(
            *self.signature,
            nopython=True,
            target=target,
            cache=self.cache,
            fastmath=_FASTMATH,
        )
        return vectorize(self.func)
",numbagg/decorators.py,ndmovematrix,1,2.998960815863541e-09,"The method 'gufunc' is a wrapper around the 'numba.guvectorize' function, which is a part of the Numba library used for creating generalized universal functions. This method is likely to be useful for users who need to apply Numba's vectorization capabilities to their functions, especially in performance-critical applications. The method is well-defined, uses keyword arguments for clarity, and leverages caching and fast math optimizations, which are beneficial features. Given these points, the method is likely to be retained as it provides valuable functionality for numerical computing tasks."
survived,"    def test_correlation_covariance_relationship(self):
        """"""Test relationship between correlation and covariance.""""""
        np.random.seed(42)
        data = np.random.randn(4, 50)

        cov_matrix = nancovmatrix(data)
        corr_matrix = nancorrmatrix(data)

        # Correlation = Covariance / (std_i * std_j)
        stds = np.sqrt(np.diag(cov_matrix))
        expected_corr = cov_matrix / np.outer(stds, stds)

        assert_allclose(corr_matrix, expected_corr, rtol=1e-10)
",numbagg/test/test_matrix_functions.py,TestMatrixFunctions,1,1.725782769012759e-08,"The method `test_correlation_covariance_relationship` is a unit test that verifies the mathematical relationship between correlation and covariance matrices. It uses random data to compute both matrices and checks if the correlation matrix can be derived from the covariance matrix using the standard deviations. This is a fundamental test for validating statistical computations, especially in libraries dealing with data analysis or scientific computing. Such tests are crucial for ensuring the correctness of mathematical operations in the codebase, and therefore, it is unlikely to be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def test_positive_semidefinite_covariance(self):
        """"""Test that covariance matrices are positive semi-definite.""""""
        np.random.seed(42)
        data = np.random.randn(4, 50)

        result = move_exp_nancovmatrix(data, alpha=0.3)

        # Check that all finite covariance matrices are positive semi-definite
        for t in range(result.shape[0]):
            cov_matrix = result[t]
            if not np.any(np.isnan(cov_matrix)):
                # Compute eigenvalues
                eigenvals = np.linalg.eigvals(cov_matrix)
                # All eigenvalues should be non-negative (allowing small numerical errors)
                assert np.all(eigenvals >= -1e-10), (
                    f""Negative eigenvalue found at time {t}: {eigenvals.min()}""
                )
",numbagg/test/test_move_exp_matrix_advanced.py,TestMoveExpMatrixAdvanced,1,1.6052280526088547e-09,"The method is a unit test that checks if the covariance matrices produced by the function `move_exp_nancovmatrix` are positive semi-definite. This is a crucial property for covariance matrices in statistical analysis, ensuring that they are valid and can be used in further computations. The test is well-defined, uses a random seed for reproducibility, and includes a clear assertion with an informative error message. Such tests are essential for maintaining code quality and correctness, especially in numerical computations. Therefore, it is likely to be retained in the codebase."
survived,"    def __call__(
        self,
        a: np.ndarray,
        alpha: float | np.ndarray,
        min_weight: float = 0,
        axis: int = -1,
        **kwargs,
    ):
        a = np.asarray(a)

        if a.ndim < 2:
            raise ValueError(f""{self.func.__name__} requires at least a 2D array."")

        # Move the axis to the last position for the gufunc
        a = np.moveaxis(a, axis, -1)

        # Handle alpha parameter similar to ndmoveexp
        if not isinstance(alpha, np.ndarray):
            alpha = np.broadcast_to(alpha, a.shape[-1])  # type: ignore[assignment,unused-ignore]

        gufunc = self.gufunc(target=self.target)
        with np.errstate(invalid=""ignore"", divide=""ignore""):
            return gufunc(a, alpha, min_weight, **kwargs)
",numbagg/decorators.py,ndmoveexpmatrix,1,2.3355930333443423e-09,"The method is a well-structured implementation of a callable class method that processes numpy arrays. It includes error handling, parameter validation, and uses numpy's capabilities effectively. The method is likely part of a larger library or framework that deals with numerical computations, and its functionality seems complete and useful. There is no indication of redundancy or obsolescence, suggesting it will be retained."
survived,"    def test_all_nan_input(self):
        """"""Test behavior with all-NaN input.""""""
        data = np.full((2, 4), np.nan, dtype=np.float64)

        result_corr = move_exp_nancorrmatrix(data, alpha=0.5)
        result_cov = move_exp_nancovmatrix(data, alpha=0.5)

        # All results should be NaN
        assert np.all(np.isnan(result_corr))
        assert np.all(np.isnan(result_cov))
",numbagg/test/test_move_exp_matrix.py,TestMoveExpMatrixFunctions,1,7.194132978569833e-09,"The method is a test case designed to verify the behavior of functions when provided with all-NaN input data. Such test cases are crucial for ensuring the robustness and correctness of functions, especially in handling edge cases. The presence of assertions to check that the results are NaN indicates that the test is well-defined and serves a clear purpose in the testing suite. Therefore, it is likely to be retained as part of the codebase to ensure the functions being tested handle NaN inputs as expected."
survived,"    def test_correlation_consistency(self, alpha):
        """"""Test that move_exp_nancorrmatrix matches move_exp_nancorr for pairs.""""""
        np.random.seed(123)

        # Create two time series
        n_obs = 50
        a1 = np.random.randn(n_obs)
        a2 = np.random.randn(n_obs) * 1.5 + 0.5

        # Compute using non-matrix function
        corr_nonmatrix = move_exp_nancorr(a1, a2, alpha=alpha)

        # Compute using matrix function
        data_matrix = np.array([a1, a2])
        corr_matrix_result = move_exp_nancorrmatrix(data_matrix, alpha=alpha)

        # Extract the off-diagonal element (correlation between a1 and a2)
        corr_from_matrix = corr_matrix_result[:, 0, 1]

        # They should match
        assert_allclose(corr_nonmatrix, corr_from_matrix, rtol=1e-10)

        # Also check symmetry - (0,1) should equal (1,0)
        assert_allclose(
            corr_matrix_result[:, 0, 1], corr_matrix_result[:, 1, 0], rtol=1e-10
        )
",numbagg/test/test_move_exp_matrix_consistency.py,TestMoveExpMatrixConsistency,1,2.5109990926928157e-08,"The method is a unit test that verifies the consistency between two functions, `move_exp_nancorr` and `move_exp_nancorrmatrix`. It ensures that both functions produce the same results for a pair of time series and checks the symmetry of the correlation matrix. This is a valuable test for maintaining the integrity of the correlation computation functions, especially when dealing with time series data. Such tests are crucial for validating the correctness of the code and are typically retained in the codebase to prevent future regressions."
survived,"    def _generate_integration_guide(self, model_info: Dict[str, Any]) -> str:
        """"""Generate an integration guide""""""
        lines = [
            f""# Integration Guide: {model_info['name']}"",
            f""\nGenerated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"",
            ""\n## Overview"",
            f""\nThis guide helps you integrate {model_info['name']} into your application.""
        ]
        
        # Integration approaches
        lines.extend([
            ""\n## Integration Approaches"",
            ""\n### 1. Direct Integration"",
            ""```python"",
            ""# Direct model loading and inference"",
            ""from your_framework import load_model"",
            """",
            ""model = load_model('path/to/model')"",
            ""result = model.predict(input_data)"",
            ""```"",
            ""\n### 2. API Integration"",
            ""```python"",
            ""# REST API integration"",
            ""import requests"",
            """",
            ""response = requests.post("",
            ""    'http://your-api-endpoint/predict',"",
            ""    json={'input': input_data}"",
            "")"",
            ""result = response.json()"",
            ""```"",
            ""\n### 3. Microservice Architecture"",
            ""```yaml"",
            ""# Docker Compose example"",
            ""version: '3.8'"",
            ""services:"",
            ""  model-service:"",
            ""    image: your-model-image"",
            ""    ports:"",
            ""      - '8080:8080'"",
            ""    environment:"",
            ""      - MODEL_PATH=/models/your-model"",
            ""```""
        ])
        
        # Requirements for integration
        lines.extend([
            ""\n## System Requirements"",
            ""\n### Hardware Requirements"",
            ""- CPU: Multi-core processor recommended"",
            ""- RAM: Depends on model size"",
            ""- GPU: Optional but recommended for large models"",
            ""\n### Software Requirements""
        ])
        
        if model_info['requirements']:
            for req_file in model_info['requirements']:
                if req_file.get('content'):
                    lines.append(f""\nFrom `{req_file['name']}`:"")
                    lines.append(""```"")
                    lines.append(req_file['content'][:200])
                    lines.append(""```"")
        
        # Configuration
        lines.extend([
            ""\n## Configuration"",
            ""\n### Environment Variables"",
            ""```bash"",
            ""export MODEL_PATH=/path/to/model"",
            ""export MODEL_CONFIG=/path/to/config.json"",
            ""export DEVICE=cuda  # or cpu"",
            ""```""
        ])
        
        # Deployment options
        lines.extend([
            ""\n## Deployment Options"",
            ""\n### 1. Cloud Deployment"",
            ""- AWS SageMaker"",
            ""- Google Cloud AI Platform"",
            ""- Azure Machine Learning"",
            ""\n### 2. Edge Deployment"",
            ""- Mobile devices (TensorFlow Lite, Core ML)"",
            ""- IoT devices"",
            ""- Browser (WebAssembly, TensorFlow.js)"",
            ""\n### 3. On-Premise"",
            ""- Kubernetes cluster"",
            ""- Docker containers"",
            ""- Bare metal servers""
        ])
        
        # Monitoring
        lines.extend([
            ""\n## Monitoring and Maintenance"",
            ""\n### Key Metrics to Monitor"",
            ""- Inference latency"",
            ""- Throughput (requests/second)"",
            ""- Resource utilization (CPU, GPU, Memory)"",
            ""- Error rates"",
            ""\n### Logging"",
            ""```python"",
            ""import logging"",
            """",
            ""logging.basicConfig(level=logging.INFO)"",
            ""logger = logging.getLogger(__name__)"",
            """",
            ""# Log model predictions"",
            ""logger.info(f'Prediction: {result}, Latency: {latency}ms')"",
            ""```""
        ])
        
        return ""\n"".join(lines)
",src/haconiwa/scan/guide_generator.py,GuideGenerator,1,1.8189616842444243e-09,"The method `_generate_integration_guide` is a comprehensive utility function that generates a detailed integration guide for a given model. It covers various aspects such as integration approaches, system requirements, configuration, deployment options, and monitoring. This method is useful for developers who need to integrate machine learning models into their applications, providing them with a structured and informative guide. The method is well-structured, uses dynamic content based on the input `model_info`, and is likely to be useful in a variety of contexts where model integration is required. Therefore, it is likely to be retained in the codebase."
survived,"    def runner(self):
        """"""Create a CLI runner""""""
        return CliRunner()
",tests/test_scan/test_cli.py,TestScanCLI,1,6.69158608681505e-10,"The method 'runner' is a simple utility function that creates and returns an instance of 'CliRunner'. This is a common pattern in command-line interface (CLI) applications for testing purposes. The method is straightforward, has a clear purpose, and is likely used in the context of testing CLI commands. Given its utility and the fact that it encapsulates the creation of a 'CliRunner' instance, it is unlikely to be deleted unless the entire testing framework or approach is changed. Therefore, it is more likely to survive."
survived,"    def test_list_models_with_filters(self, temp_model_dir):
        """"""Test listing models with category and provider filters""""""
        scanner = ModelScanner(temp_model_dir)
        
        # Filter by provider
        openai_models = scanner.list_all_models(provider=""openai"")
        assert all(m['provider'] == 'openai' for m in openai_models)
        
        # Filter by category
        llm_models = scanner.list_all_models(category=""llm"")
        assert all('llm' in m['category'] for m in llm_models)
",tests/test_scan/test_scanner.py,TestModelScanner,1,2.3355930333443423e-09,"The method 'test_list_models_with_filters' is a unit test designed to verify the functionality of filtering models by provider and category. Unit tests are crucial for ensuring code reliability and are typically retained in the codebase to maintain software quality. The method is well-structured, with clear assertions to validate the expected behavior of the 'list_all_models' function. There is no indication of redundancy or obsolescence, and it serves a clear purpose in the testing suite."
survived,"    def _get_action_prompt(self, action: str) -> str:
        """"""Get general action prompt""""""
        if action in self.task_templates:
            return self.task_templates[action]
        
        # Default prompt
        return f""Perform {action} on this file following best practices""
",src/haconiwa/scan/generate_parallel.py,ParallelYAMLGenerator,1,6.69158608681505e-10,"The method '_get_action_prompt' is likely to survive because it provides a useful utility function for generating prompts based on actions. It checks if the action exists in 'task_templates' and returns a corresponding prompt, otherwise it returns a default prompt. This functionality is essential for applications that require dynamic prompt generation based on user actions or tasks, making it a valuable part of the codebase."
survived,"    def _generate_insights(self, analysis: Dict[str, Any]) -> List[str]:
        """"""Generate insights from analysis""""""
        insights = []
        
        # Model count insight
        if analysis['total_models'] > 0:
            insights.append(f""Found {analysis['total_models']} models across {len(analysis['categories'])} categories"")
        
        # Size insight
        if analysis['total_size'] > 0:
            size_gb = analysis['total_size'] / (1024 ** 3)
            insights.append(f""Total model storage: {size_gb:.2f} GB"")
        
        # Format insights
        if analysis['model_formats']:
            most_common = max(analysis['model_formats'].items(), key=lambda x: x[1])
            insights.append(f""Most common format: {most_common[0]} ({most_common[1]} models)"")
        
        # Provider insights
        if analysis['providers']:
            provider_count = len(analysis['providers'])
            insights.append(f""Models from {provider_count} different providers"")
        
        # Category distribution
        if analysis['categories']:
            largest_category = max(analysis['categories'].items(), key=lambda x: len(x[1]))
            insights.append(f""Largest category: {largest_category[0]} with {len(largest_category[1])} models"")
        
        return insights",src/haconiwa/scan/analyzer.py,ModelAnalyzer,1,8.592166611791576e-10,"The method '_generate_insights' is well-structured and provides valuable functionality by generating insights from a given analysis dictionary. It covers various aspects such as model count, size, format, provider, and category distribution, which are likely important for understanding the data. The method is also flexible, handling different types of insights based on the available data in the analysis dictionary. This makes it a useful utility function that is likely to be retained in the codebase."
survived,"    def analyze_category(self, category: str) -> Dict[str, Any]:
        """"""Analyze models in a specific category""""""
        analysis = {
            'category': category,
            'models': [],
            'total_count': 0,
            'total_size': 0,
            'common_formats': defaultdict(int),
            'providers': defaultdict(int)
        }
        
        all_analysis = self.analyze_all()
        
        if category in all_analysis['categories']:
            models = all_analysis['categories'][category]
            analysis['models'] = models
            analysis['total_count'] = len(models)
            
            for model in models:
                analysis['total_size'] += model.get('size', 0)
                analysis['providers'][model.get('provider', 'unknown')] += 1
                
                for fmt in model.get('formats', []):
                    analysis['common_formats'][fmt] += 1
        
        # Convert defaultdicts
        analysis['common_formats'] = dict(analysis['common_formats'])
        analysis['providers'] = dict(analysis['providers'])
        
        return analysis
",src/haconiwa/scan/analyzer.py,ModelAnalyzer,1,2.1724399346070676e-10,"The method 'analyze_category' is well-structured and provides a clear functionality to analyze models within a specific category. It aggregates useful statistics such as total count, total size, common formats, and providers, which are likely valuable for understanding the distribution and characteristics of models in a category. The method also handles cases where the category might not exist in the analysis, ensuring robustness. Given its utility and the lack of any apparent issues, it is likely to be retained in the codebase."
survived,"    def test_file_info_with_content(self, temp_model_dir):
        """"""Test getting file info with content""""""
        scanner = ModelScanner(temp_model_dir)
        
        results = scanner.search_by_model_name(""gpt-4"", include_content=True)
        
        # Find the example.py file in results
        example_file = None
        for files in results['matches'].values():
            for f in files:
                if f['name'] == 'example.py':
                    example_file = f
                    break
        
        assert example_file is not None
        assert 'content' in example_file
        assert 'import openai' in example_file['content']
",tests/test_scan/test_scanner.py,TestModelScanner,1,2.5109990926928157e-08,"The method 'test_file_info_with_content' is a unit test designed to verify the functionality of a ModelScanner class. It checks if the scanner can correctly identify a file named 'example.py' and ensure that the file's content includes a specific import statement. This is a typical test case that ensures the integrity and correctness of the file scanning feature, which is crucial for maintaining the reliability of the software. Such test methods are generally retained as they are essential for continuous integration and testing processes."
survived,"    def compare(self, models: List[str], aspects: List[str]) -> Dict[str, Any]:
        """"""Compare multiple models across specified aspects""""""
        comparison = {
            'models': models,
            'timestamp': self._get_timestamp(),
            'results': {}
        }
        
        # Load model information
        model_data = {}
        for model in models:
            model_info = self._load_model_info(model)
            if model_info:
                model_data[model] = model_info
        
        # Compare across requested aspects
        for aspect in aspects:
            if aspect in self.aspects:
                comparison['results'][aspect] = self.aspects[aspect](model_data)
        
        return comparison['results']
",src/haconiwa/scan/comparator.py,ModelComparator,1,5.905303995456778e-10,"The method 'compare' is well-structured and serves a clear purpose of comparing models across specified aspects. It uses helper methods like '_get_timestamp' and '_load_model_info', which suggests a modular design. The method is likely part of a larger system that deals with model evaluation or comparison, which is a common requirement in data science and machine learning applications. The method is also flexible, allowing for dynamic comparison based on the 'aspects' parameter. These factors indicate that the method is useful and likely to be retained."
survived,"    def _format_size(self, size: int) -> str:
        """"""Format file size in human-readable format""""""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f""{size:.1f} {unit}""
            size /= 1024.0
        return f""{size:.1f} PB""",src/haconiwa/scan/formatter.py,OutputFormatter,1,2.998960815863541e-09,"The method '_format_size' is a utility function that converts a file size in bytes to a human-readable format, which is a common requirement in many applications dealing with file systems or data storage. It is well-implemented, concise, and serves a clear purpose. Such utility functions are often retained because they provide essential functionality that can be reused across different parts of a codebase."
survived,"    def test_scan_model_command(self, runner, temp_model_dir):
        """"""Test the scan model command""""""
        result = runner.invoke(
            scan_app,
            [""model"", ""o1-mini"", ""--path"", str(temp_model_dir), ""--format"", ""json""]
        )
        
        assert result.exit_code == 0
        output = json.loads(result.stdout)
        assert output['model_name'] == ""o1-mini""
        assert output['total_files'] > 0
",tests/test_scan/test_cli.py,TestScanCLI,1,1.1628233028868813e-10,"The method 'test_scan_model_command' is a unit test for a command-line interface function. It is well-structured, uses assertions to verify the expected behavior, and is likely part of a test suite that ensures the functionality of the 'scan model' command. Such test methods are crucial for maintaining code quality and are typically not deleted unless the functionality they test is removed or significantly changed. Therefore, it is likely to survive."
survived,"    def _generate_prompt_for_file(self, 
                                file_path: str, 
                                action: str,
                                custom_prompts: Optional[Dict[str, str]] = None) -> str:
        """"""Generate appropriate prompt based on file type and action""""""
        
        # Check custom prompts first
        if custom_prompts and file_path in custom_prompts:
            return custom_prompts[file_path]
        
        # Determine file category
        file_path_lower = file_path.lower()
        
        if 'model' in file_path_lower:
            category = 'model'
        elif 'api' in file_path_lower or 'route' in file_path_lower:
            category = 'api'
        elif 'util' in file_path_lower or 'helper' in file_path_lower:
            category = 'utils'
        elif 'config' in file_path_lower or 'setting' in file_path_lower:
            category = 'config'
        elif 'service' in file_path_lower:
            category = 'service'
        else:
            # Default based on action
            return self._get_action_prompt(action)
        
        # Get category-specific prompt
        if category in self.default_prompts and action in self.default_prompts[category]:
            return self.default_prompts[category][action]
        
        # Fallback to general action prompt
        return self._get_action_prompt(action)
",src/haconiwa/scan/generate_parallel.py,ParallelYAMLGenerator,1,3.581747929000289e-10,"The method '_generate_prompt_for_file' is well-structured and serves a clear purpose of generating prompts based on file type and action. It includes checks for custom prompts, categorizes files based on their path, and provides a fallback mechanism. This functionality is useful in applications where dynamic prompt generation is needed, such as in code generation tools or automated documentation systems. The method is likely to be retained as it provides a flexible and extensible way to handle different file types and actions."
deleted,"        def process_functions(func_df, target_ndim, source_df=None):
            """"""Process a subset of functions with target dimensionality.""""""
            if source_df is None:
                source_df = func_df

            filtered = func_df[lambda x: x[""ndim""] == target_ndim]
            if filtered.empty:
                return None

            # Use largest array shape for performance comparison
            shape = filtered.sort_values(by=""size"")[""shape""].iloc[-1]
            return (
                source_df.query(f""shape == '{shape}'"")
                .reset_index()
                .set_index([""func"", ""shape""])
                .unstack(""shape"")  # Pivot: functions as rows, shapes as columns
                .pipe(
                    lambda x: x[
                        [
                            c
                            for c in x.columns
                            if c[0].endswith(""ratio"") and c[0] not in [""numbagg_ratio""]
                        ]
                    ]
                )
            )
",numbagg/test/run_benchmarks.py,,1,1.1861120010657661e-08,"The method 'process_functions' is a utility function that processes a DataFrame of functions based on a target dimensionality. It filters the DataFrame, sorts it, and performs a series of transformations to return a specific view of the data. This type of function is useful in data processing and analysis tasks, especially when dealing with multi-dimensional data. The method is well-defined, performs a specific task, and is likely to be used in contexts where data needs to be filtered and reshaped based on certain criteria. Therefore, it is likely to be retained in the codebase."
survived,"    def test_consistency_with_pairwise_functions(self, alpha):
        """"""Test that matrix functions match non-matrix functions for pairwise cases.""""""
        np.random.seed(42)

        # Create two time series
        n_obs = 50
        a1 = np.random.randn(n_obs)
        a2 = np.random.randn(n_obs) * 2 + 1

        # Compute using non-matrix functions
        cov_nonmatrix = move_exp_nancov(a1, a2, alpha=alpha)
        corr_nonmatrix = move_exp_nancorr(a1, a2, alpha=alpha)

        # Compute using matrix functions
        # Exponential moving functions expect (obs, vars) format
        data_matrix = np.column_stack([a1, a2])
        cov_matrix_result = move_exp_nancovmatrix(data_matrix, alpha=alpha)
        corr_matrix_result = move_exp_nancorrmatrix(data_matrix, alpha=alpha)

        # Extract the off-diagonal element (covariance/correlation between a1 and a2)
        cov_from_matrix = cov_matrix_result[:, 0, 1]
        corr_from_matrix = corr_matrix_result[:, 0, 1]

        # They should match
        assert_allclose(cov_nonmatrix, cov_from_matrix, rtol=1e-10)
        assert_allclose(corr_nonmatrix, corr_from_matrix, rtol=1e-10)

        # Also check symmetry - (0,1) should equal (1,0)
        assert_allclose(
            cov_matrix_result[:, 0, 1], cov_matrix_result[:, 1, 0], rtol=1e-10
        )
        assert_allclose(
            corr_matrix_result[:, 0, 1], corr_matrix_result[:, 1, 0], rtol=1e-10
        )
",numbagg/test/test_matrix_functions.py,TestExponentialMatrices,1,1.522997951276035e-08,"The method is a unit test that ensures consistency between matrix and non-matrix implementations of covariance and correlation functions. Such tests are crucial for verifying the correctness of mathematical operations in code, especially when dealing with numerical computations. The method is well-structured, uses assertions to validate results, and is likely part of a test suite that ensures the reliability of the software. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality."
survived,"    def test_rolling_simple(self, move_func, static_func, window):
        """"""Test rolling functions with simple data.""""""
        # Moving functions expect (obs, vars) format
        data = np.array(
            [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10], [6, 12]], dtype=np.float64
        )
        result = move_func(data, window=window, min_count=2)

        # Shape should be (n_obs, n_vars, n_vars)
        assert result.shape == (6, 2, 2)

        # Check symmetry for each time point
        for t in range(6):
            assert_allclose(result[t], result[t].T, equal_nan=True)

        # For perfect linear relationship, correlation should be 1
        if move_func == move_nancorrmatrix:
            for i in range(1, 6):  # From second window onwards (min_count=2)
                assert_allclose(result[i], [[1.0, 1.0], [1.0, 1.0]], rtol=1e-10)
",numbagg/test/test_matrix_functions.py,TestMovingMatrices,1,1.8553915987649156e-07,"The method 'test_rolling_simple' is a unit test function that verifies the behavior of rolling functions with simple data. It checks the shape of the result, symmetry, and correlation values, which are essential for ensuring the correctness of the rolling functions. Such test functions are crucial for maintaining code quality and reliability, especially in numerical and data processing libraries. Therefore, it is unlikely to be deleted as it serves an important role in testing and validation."
survived,"    def test_min_weight(self, func):
        """"""Test min_weight parameter.""""""
        # Exponential moving functions expect (obs, vars) format
        data = np.array([[1, 2], [2, 4], [3, 6], [4, 8]], dtype=np.float64)
        alpha = 0.1  # Low alpha means slow buildup of weight

        # High min_weight should produce more NaNs initially
        result_high = func(data, alpha=alpha, min_weight=0.8)
        result_low = func(data, alpha=alpha, min_weight=0.1)

        # Check that high min_weight produces more NaNs initially
        nan_count_high = np.sum(np.isnan(result_high[0]))
        nan_count_low = np.sum(np.isnan(result_low[0]))
        assert nan_count_high >= nan_count_low
",numbagg/test/test_matrix_functions.py,TestExponentialMatrices,1,3.3982678079468468e-09,"The method `test_min_weight` is a unit test designed to verify the behavior of a function with respect to the `min_weight` parameter. It checks if a higher `min_weight` results in more NaN values initially, which is a valid and useful test for ensuring the function's correctness. Since it serves a clear purpose in validating the functionality of the code, it is likely to be retained."
survived,"    def test_rolling_1d_array_raises_error(self, move_func):
        """"""Test that 1D arrays raise an appropriate error for rolling functions.""""""
        data_1d = np.array([1, 2, 3, 4, 5], dtype=np.float64)

        with pytest.raises(ValueError, match=""requires at least a 2D array""):
            move_func(data_1d, window=3)
",numbagg/test/test_matrix_functions.py,TestMovingMatrices,1,1.6052280526088547e-09,"The method is a unit test designed to ensure that a specific function, `move_func`, raises an error when given a 1D array instead of a 2D array. This is a valid and useful test case to ensure the robustness of the `move_func` function, as it checks for proper error handling and input validation. Such tests are crucial in maintaining code quality and preventing unexpected behavior. Therefore, the method is likely to be retained in the codebase."
survived,"    def test_dtype_preservation(self, func):
        """"""Test that dtypes are preserved.""""""
        # Set up appropriate data and window for rolling vs basic
        is_rolling = func.__name__.startswith(""move_"")

        # Test float32
        if is_rolling:
            # Moving functions expect (obs, vars)
            data32 = np.random.randn(10, 3).astype(np.float32)
            result32 = func(data32, window=5, min_count=3)
        else:
            # Basic functions expect (vars, obs)
            data32 = np.random.randn(3, 10).astype(np.float32)
            result32 = func(data32)
        assert result32.dtype == np.float32

        # Test float64
        if is_rolling:
            # Moving functions expect (obs, vars)
            data64 = np.random.randn(10, 3).astype(np.float64)
            result64 = func(data64, window=5, min_count=3)
        else:
            # Basic functions expect (vars, obs)
            data64 = np.random.randn(3, 10).astype(np.float64)
            result64 = func(data64)
        assert result64.dtype == np.float64",numbagg/test/test_matrix_functions.py,TestMatrixDtypePreservation,1,4.6911638017642294e-08,"The method `test_dtype_preservation` is a unit test designed to ensure that the data types (dtypes) of input arrays are preserved after applying a function. This is a common requirement in data processing and scientific computing to maintain precision and avoid unexpected behavior. The method is well-structured, checks for both float32 and float64 dtypes, and handles different function types (rolling vs basic) appropriately. Such tests are crucial for maintaining code quality and reliability, especially in libraries dealing with numerical computations. Therefore, it is likely to be retained as it serves an important purpose in ensuring the correctness of dtype handling in the codebase."
survived,"    def test_windows_colon_validation_logic(self):
        """"""Test that Windows colon validation logic is implemented.""""""

        # Just verify that the Windows-specific logic exists in the code
        # The platform detection happens at instantiation, so mocking doesn't work
        # effectively for testing the actual validation behavior in unit tests.
        # The logic is tested indirectly through the Windows path tests above.
        validator = PathValidator()

        # Verify the validation method exists and handles different path types
        assert hasattr(
            validator, ""validate_path""
        ), ""PathValidator should have validate_path method""

        # Test that validation works for basic cases
        is_valid, _, _ = validator.validate_path(""test.txt"", check_exists=False)
        assert is_valid, ""Simple filename should be valid""",tests/unit/test_windows_compatibility.py,TestWindowsPathValidation,1,1.444980317078884e-07,"The method `test_windows_colon_validation_logic` is a unit test that verifies the existence and basic functionality of a path validation method in a Windows-specific context. It checks that the `validate_path` method exists and performs a basic validation test. This is a fundamental test to ensure that the path validation logic is implemented correctly, which is crucial for any file handling operations in a Windows environment. Since it serves an essential purpose in verifying the functionality of the code, it is likely to be retained."
survived,"    async def test_bash_tool_windows_shell_preparation(self, mock_which, mock_platform):
        """"""Test Windows shell command preparation.""""""
        mock_which.side_effect = {
            ""cmd"": ""C:\\Windows\\System32\\cmd.exe"",
            ""powershell"": (
                ""C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe""
            ),
            ""pwsh"": None,
        }.get

        bash_tool = BashTool()

        # Test default cmd.exe handling
        result = bash_tool._prepare_shell_command(""echo test"", ""bash"")
        assert result == [""C:\\Windows\\System32\\cmd.exe"", ""/c"", ""echo test""]

        # Test PowerShell handling
        result = bash_tool._prepare_shell_command(""echo test"", ""powershell"")
        assert result == [
            ""C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"",
            ""-Command"",
            ""echo test"",
        ]
",tests/unit/test_windows_compatibility.py,TestWindowsCompatibility,1,1.275190675769241e-07,"The method `test_bash_tool_windows_shell_preparation` is a unit test designed to verify the functionality of the `BashTool` class's `_prepare_shell_command` method. It uses mocking to simulate different shell environments on Windows and checks if the command preparation is done correctly for both `cmd.exe` and `powershell`. This is a crucial part of ensuring that the `BashTool` class behaves as expected in different environments, which is important for cross-platform compatibility. Given the importance of testing in software development, especially for platform-specific functionality, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def test_run_with_uv_error_handling(self, mock_run):
        """"""Test run_with_uv error handling.""""""
        mock_run.side_effect = subprocess.CalledProcessError(1, [""uv"", ""run""])

        with pytest.raises(SystemExit) as exc_info:
            run_with_uv(""server.py"")

        assert exc_info.value.code == 1
",tests/cli/test_run_with_uv.py,TestRunWithUv,1,8.152020648014727e-09,"The method 'test_run_with_uv_error_handling' is a unit test designed to verify the error handling of the 'run_with_uv' function when a 'subprocess.CalledProcessError' is raised. Unit tests are crucial for ensuring code reliability and are typically maintained as long as the functionality they test is relevant. Since this test is directly tied to error handling, which is an important aspect of robust software, it is likely to be retained to ensure that the 'run_with_uv' function behaves correctly under error conditions."
survived,"async def reduce_clusters_from_base_clusters( 
    clusters: List[Cluster],
    *,
    model: BaseMetaClusterModel,
    checkpoint_manager: Optional[CheckpointManager] = None
) -> List[Cluster]:
    """"""Reduce clusters into a hierarchical structure.
    
    Iteratively combines similar clusters until the number of root clusters
    is less than or equal to the model's max_clusters setting.
    
    Args:
        clusters: List of initial clusters to reduce
        model: Meta-clustering model to use for reduction
        checkpoint_manager: Optional checkpoint manager for caching
        
    Returns:
        List of clusters with hierarchical structure
        
    Example:
        >>> meta_model = MetaClusterModel(max_clusters=5)
        >>> reduced = await reduce_clusters(
        ...     clusters=base_clusters,
        ...     model=meta_model,
        ...     checkpoint_manager=checkpoint_mgr
        ... )
    """"""
    logger.info(f""Starting cluster reduction from {len(clusters)} initial clusters using {type(model).__name__}"")
    
    # Try to load from checkpoint
    if checkpoint_manager:
        cached = checkpoint_manager.load_checkpoint(
            model.checkpoint_filename,
            Cluster
        )
        if cached:
            root_count = len([c for c in cached if c.parent_id is None])
            logger.info(f""Loaded {len(cached)} clusters from checkpoint ({root_count} root clusters)"")
            return cached
    
    # Start with all clusters as potential roots
    all_clusters = clusters.copy()
    root_clusters = clusters.copy()
    
    logger.info(f""Starting with {len(root_clusters)} clusters, target: {model.max_clusters}"")
    
    # Iteratively reduce until we have desired number of root clusters
    while len(root_clusters) > model.max_clusters:
        # Get updated clusters from meta-clustering
        new_current_level = await model.reduce_clusters(root_clusters)
        
        # Find new root clusters (those without parents)
        root_clusters = [c for c in new_current_level if c.parent_id is None]
        
        # Remove old clusters that now have parents
        old_cluster_ids = {c.id for c in new_current_level if c.parent_id}
        all_clusters = [c for c in all_clusters if c.id not in old_cluster_ids]
        
        # Add new clusters to the complete list
        all_clusters.extend(new_current_level)
        
        logger.info(f""Reduced to {len(root_clusters)} root clusters"")
    
    logger.info(f""Cluster reduction complete: {len(all_clusters)} total clusters, {len(root_clusters)} root clusters"")
    
    # Save to checkpoint
    if checkpoint_manager:
        checkpoint_manager.save_checkpoint(model.checkpoint_filename, all_clusters)
    
    return all_clusters
",kura/v1/kura.py,,1,9.736200303530205e-10,"The method `reduce_clusters_from_base_clusters` is a well-defined function that performs a specific task of reducing clusters into a hierarchical structure. It includes logging, checkpoint management, and uses an asynchronous model to iteratively reduce clusters. The method is useful for applications involving clustering and hierarchical data structures, and it is likely to be used in various data processing or machine learning tasks. The presence of detailed documentation and an example usage further indicates its utility and clarity. Therefore, it is likely to be retained in the codebase."
survived,"def visualise_clusters_enhanced(
    clusters: Optional[List[Cluster]] = None,
    *,
    checkpoint_path: Optional[Union[str, Path]] = None
) -> None:
    """"""Print an enhanced hierarchical visualization of clusters with colors and statistics.
    
    This function provides a more detailed visualization than visualise_clusters(),
    including conversation counts, percentages, progress bars, and descriptions.
    
    Args:
        clusters: List of clusters to visualize. If None, loads from checkpoint_path
        checkpoint_path: Path to checkpoint file to load clusters from
        
    Raises:
        ValueError: If neither clusters nor checkpoint_path is provided
        FileNotFoundError: If checkpoint file doesn't exist
    """"""
    # Load clusters
    if clusters is None:
        if checkpoint_path is None:
            raise ValueError(""Either clusters or checkpoint_path must be provided"")
        clusters = _load_clusters_from_checkpoint(checkpoint_path)
    
    logger.info(f""Enhanced visualization of {len(clusters)} clusters"")
    
    print(""\n"" + ""=""*80)
    print(""üéØ ENHANCED CLUSTER VISUALIZATION"")
    print(""=""*80)
    
    # Build tree structure
    node_id_to_cluster = _build_cluster_tree(clusters)
    
    # Calculate total conversations from root clusters only
    root_clusters = [cluster for cluster in clusters if not cluster.parent_id]
    total_conversations = sum(len(cluster.chat_ids) for cluster in root_clusters)

    # Find root nodes
    root_nodes = [
        node_id_to_cluster[cluster.id] for cluster in root_clusters
    ]

    fake_root = ClusterTreeNode(
        id=""root"",
        name=f""üìö All Clusters ({total_conversations:,} total conversations)"",
        description=""Hierarchical conversation clustering results"",
        count=total_conversations,
        children=[node.id for node in root_nodes],
    )

    tree_output = _build_enhanced_tree_structure(
        fake_root, node_id_to_cluster, 0, False, """", total_conversations
    )

    print(tree_output)
    
    # Add summary statistics
    print(""=""*80)
    print(""üìà CLUSTER STATISTICS"")
    print(""=""*80)
    print(f""üìä Total Clusters: {len(clusters)}"")
    print(f""üå≥ Root Clusters: {len(root_nodes)}"")
    print(f""üí¨ Total Conversations: {total_conversations:,}"")
    print(f""üìè Average Conversations per Root Cluster: {total_conversations/len(root_nodes):.1f}"")
    print(""=""*80 + ""\n"")
",kura/v1/visualization.py,,1,3.850741907939403e-09,"The method `visualise_clusters_enhanced` is a utility function that provides a detailed visualization of clusters, which is a common requirement in data analysis and machine learning workflows. It enhances the basic visualization by adding features like conversation counts, percentages, progress bars, and descriptions, making it more informative and user-friendly. Such enhancements are valuable for users who need to interpret and present clustering results effectively. The method also includes error handling for missing inputs, which is a good practice. Given its utility and the added value it provides, it is likely to be retained in the codebase."
survived,"    def test_contextual_pipeline_decay_with_rate(self):
        """"""Test contextual pipeline decay with explicit rate.""""""
        arms = make_arms(range(3))
        agent = ContextualAgent(arms, ThompsonSampling())
        pipeline = ContextualAgentPipeline([(""identity"", FunctionTransformer())], agent)

        X = np.array([[1.0]])
        pipeline.decay(X, decay_rate=0.7)
",tests/test_agent_pipeline.py,TestCoverage,1,2.646573631904765e-09,"The method `test_contextual_pipeline_decay_with_rate` is a unit test designed to verify the functionality of a specific feature (contextual pipeline decay with an explicit rate) in a machine learning pipeline. Unit tests are crucial for ensuring code reliability and correctness, especially in complex systems like machine learning models. Since this method is a test case, it is unlikely to be deleted unless the feature it tests is removed or significantly altered. Therefore, the method will likely survive."
survived,"    def add_arm(self, arm) -> None:
        """"""Add an arm to the wrapped agent.""""""
        self._agent.add_arm(arm)
",bayesianbandits/pipelines/_agent.py,NonContextualAgentPipeline,1,1.522997951276035e-08,"The method 'add_arm' is a simple wrapper that calls the 'add_arm' method on the '_agent' attribute. This suggests that the method is part of a larger class that manages or interacts with an agent object. Such methods are typically essential for maintaining the functionality and extensibility of the class, especially if the class is designed to manage multiple components or modules dynamically. Therefore, it is unlikely to be deleted unless the entire class or the concept of 'arms' is removed from the system."
survived,"        def add_polynomials(X):
            """"""Add polynomial features.""""""
            # X shape: (n_samples, 3) after interactions
            squared = X**2
            return np.c_[X, squared]
",tests/test_agent_pipeline.py,TestIntegrationScenarios,1,2.0611536181902033e-09,"The method 'add_polynomials' is a simple utility function that adds polynomial features to a given dataset. It is a common preprocessing step in machine learning to enhance model performance by allowing it to capture non-linear relationships. The method is straightforward, performs a specific task, and is likely to be useful in various contexts where polynomial feature expansion is needed. Therefore, it is likely to be retained in the codebase."
survived,"    def test_not_fitted_transformer_helpful_error(self):
        """"""Test helpful error message for not fitted transformers.""""""
        arms = make_arms(range(3))
        agent = ContextualAgent(arms, ThompsonSampling())

        steps = [(""scaler"", StandardScaler())]  # Not fitted!
        pipeline = ContextualAgentPipeline(steps, agent)

        X = np.array([[1.0], [2.0]])

        with pytest.raises(RuntimeError) as exc_info:
            pipeline.pull(X)

        error_msg = str(exc_info.value)
        assert ""not fitted"" in error_msg
        assert ""scaler"" in error_msg
        assert ""FunctionTransformer"" in error_msg
",tests/test_agent_pipeline.py,TestErrorHandling,1,1.1861120010657661e-08,"The method is a unit test designed to ensure that a specific error message is raised when a transformer in a pipeline is not fitted. This is a common and important test case in machine learning pipelines to ensure robustness and proper error handling. Such tests are crucial for maintaining code quality and preventing runtime errors, especially in production environments. Therefore, it is likely to be retained."
survived,"    def _analyze_architecture(self, project_path: str) -> Dict[str, Any]:
        """"""Analyze the overall architecture patterns.""""""
        architecture = {""primary_pattern"": ""mvc"", ""layers"": [], ""components"": []}
        # Implementation would analyze architectural patterns
        return architecture
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,1,1.522997951276035e-08,"The method `_analyze_architecture` is a private method (indicated by the underscore prefix) that is designed to analyze architectural patterns of a project. It returns a dictionary with a predefined structure, which suggests it is part of a larger system for analyzing or documenting software architecture. The method is likely to be useful in contexts where understanding the architecture is necessary, such as in code analysis tools or documentation generators. Since it has a clear purpose and potential utility, it is likely to be retained in the codebase."
survived,"    def _analyze_comment_patterns(self, project_path: str) -> Dict[str, Any]:
        """"""Analyze code comment patterns.""""""
        return {""style"": ""inline"", ""density"": ""moderate""}
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,0,0.999876605372333,"The method `_analyze_comment_patterns` is a private method (indicated by the underscore prefix) that analyzes code comment patterns within a given project path. The method currently returns a hardcoded dictionary with fixed values for 'style' and 'density'. This suggests that the method is either a placeholder or part of a larger system where these values might be dynamically determined in the future. However, as it stands, the method does not perform any actual analysis based on the input parameter `project_path`, which limits its utility.

If the method is part of a larger codebase where it is expected to perform real analysis, it might be subject to deletion or significant modification unless it is updated to fulfill its intended purpose. However, if it is used as a simple configuration or placeholder, it might survive as is.

Given the lack of dynamic functionality and the potential for future development, the method is more likely to be deleted or significantly altered unless it is actively used in its current form for configuration purposes."
survived,"def show_context_engineering_benefits():
    """"""Demonstrate the benefits of Context Engineering vs traditional approaches.""""""
    print(""\nüìä Context Engineering Benefits"")
    print(""="" * 60)
    
    # Traditional prompt engineering approach
    print(""\n‚ùå Traditional Prompt Engineering:"")
    traditional_prompt = ""Create a user authentication system""
    print(f""   Prompt: '{traditional_prompt}'"")
    print(f""   Length: {len(traditional_prompt)} characters"")
    print(f""   Context: Minimal - relies on AI's general knowledge"")
    print(f""   Success Rate: Variable - depends on AI model's training"")
    
    # Context Engineering approach
    print(""\n‚úÖ Context Engineering Approach:"")
    context_agent = create_context_agent(llm=""gpt-4o-mini"")
    
    # Generate comprehensive context
    analysis = context_agent.analyze_codebase_patterns(str(project_root))
    enhanced_prompt = context_agent.enhance_prompt_with_context(
        traditional_prompt, analysis
    )
    
    print(f""   Enhanced Prompt Length: {len(enhanced_prompt)} characters"")
    print(f""   Context: Comprehensive - includes:"")
    print(f""     ‚Ä¢ Codebase architecture analysis"")
    print(f""     ‚Ä¢ Existing patterns and conventions"")
    print(f""     ‚Ä¢ Implementation guidance"")
    print(f""     ‚Ä¢ Quality requirements"")
    print(f""     ‚Ä¢ Validation criteria"")
    print(f""   Success Rate: Higher - AI has all necessary context"")
    
    print(f""\nüéØ Context Engineering provides:"")
    print(f""   üìà 10x better than prompt engineering (comprehensive vs clever wording)"")
    print(f""   üìà 100x better than vibe coding (structured vs ad-hoc)"")
    print(f""   üéØ First-try implementation success through complete context"")
",examples/python/agents/context-agent.py,,1,9.237449576640118e-09,"The method `show_context_engineering_benefits` is a demonstration function that prints out the benefits of context engineering over traditional prompt engineering. It is informative and educational, providing a clear comparison between two approaches. Such methods are typically retained in codebases as they serve to educate users or developers about the advantages of certain methodologies. Additionally, the method is well-structured and provides a clear output, making it useful for presentations or documentation purposes. Therefore, it is likely to be retained."
survived,"    def analyze_test_patterns(self, project_path: str) -> Dict[str, Any]:
        """"""Analyze testing patterns and conventions in the project.""""""
        test_patterns = {
            ""test_structure"": self._analyze_test_structure(project_path),
            ""testing_frameworks"": self._identify_testing_frameworks(project_path),
            ""test_naming"": self._analyze_test_naming(project_path),
            ""coverage_patterns"": self._analyze_coverage_patterns(project_path)
        }
        return test_patterns
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,1,9.056076988852742e-11,"The method `analyze_test_patterns` is likely to survive because it provides a comprehensive analysis of testing patterns and conventions within a project. This functionality is valuable for understanding and improving the quality of software testing practices. The method breaks down the analysis into specific components such as test structure, frameworks, naming, and coverage, which are all critical aspects of software testing. Additionally, the method returns a dictionary with detailed insights, making it useful for developers and teams looking to enhance their testing strategies."
survived,"    def _format_documentation_standards(self, doc_style: Dict[str, Any]) -> str:
        """"""Format documentation standards for context document.""""""
        return f""Format: {doc_style.get('format', 'markdown')}""
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,1,1.2501528648238603e-09,"The method '_format_documentation_standards' is a simple utility function that formats a string based on a dictionary input. It is straightforward, performs a specific task, and is likely to be useful in contexts where documentation standards need to be formatted consistently. There is no indication of redundancy, inefficiency, or lack of use, which are common reasons for deletion. Therefore, it is likely to be retained in the codebase."
survived,"    def create_validation_loop(self, implementation_requirements: str, success_criteria: List[str]) -> Dict[str, Any]:
        """"""
        Create executable validation loops and success criteria.
        
        Args:
            implementation_requirements (str): What needs to be implemented
            success_criteria (List[str]): List of success criteria to validate
            
        Returns:
            Dict[str, Any]: Validation loop configuration with executable criteria
        """"""
        validation_config = {
            ""requirements"": implementation_requirements,
            ""success_criteria"": success_criteria,
            ""validation_steps"": [],
            ""executable_tests"": [],
            ""quality_gates"": []
        }
        
        # Generate validation steps
        for criterion in success_criteria:
            validation_step = {
                ""criterion"": criterion,
                ""validation_method"": self._determine_validation_method(criterion),
                ""expected_outcome"": self._generate_expected_outcome(criterion),
                ""failure_actions"": self._generate_failure_actions(criterion)
            }
            validation_config[""validation_steps""].append(validation_step)
        
        # Generate executable tests
        validation_config[""executable_tests""] = self._generate_executable_tests(implementation_requirements, success_criteria)
        
        # Generate quality gates
        validation_config[""quality_gates""] = self._generate_quality_gates(success_criteria)
        
        return validation_config
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,1,1.1861120010657661e-08,"The method 'create_validation_loop' is well-structured and provides a clear and useful functionality for creating validation loops based on implementation requirements and success criteria. It returns a dictionary with detailed configuration, which is likely to be useful in various contexts where validation processes are needed. The method is also extensible, allowing for additional validation steps, tests, and quality gates to be added as needed. Given its utility and clarity, it is likely to be retained in the codebase."
survived,"def demonstrate_basic_context_generation():
    """"""Demonstrate basic context generation capabilities.""""""
    print(""üîß Context Engineering Example: Basic Usage"")
    print(""="" * 60)
    
    # Create a ContextAgent using the factory function
    context_agent = create_context_agent(
        llm=""gpt-4o-mini"",
        name=""Basic Context Engineer"",
        verbose=True
    )
    
    # Example 1: Analyze codebase patterns
    print(""\nüìÅ Example 1: Analyzing Codebase Patterns"")
    print(""-"" * 40)
    
    # Use current project as example (adjust path as needed)
    project_path = str(project_root)
    analysis = context_agent.analyze_codebase_patterns(
        project_path=project_path,
        file_patterns=[""*.py""]
    )
    
    print(f""‚úÖ Analyzed project at: {project_path}"")
    print(f""   Project structure: {len(analysis.get('project_structure', {}).get('directories', []))} directories"")
    print(f""   Code patterns identified: {len(analysis.get('code_patterns', {}))}"")
    print(f""   Architecture: {analysis.get('architecture_insights', {}).get('primary_pattern', 'Unknown')}"")
    
    # Example 2: Generate context document
    print(""\nüìÑ Example 2: Generating Context Document"")
    print(""-"" * 40)
    
    feature_request = ""Add user authentication system with JWT tokens and role-based access control""
    context_doc = context_agent.generate_context_document(
        project_path=project_path,
        requirements=feature_request,
        analysis=analysis
    )
    
    print(f""‚úÖ Generated context document for: {feature_request}"")
    print(f""   Document length: {len(context_doc)} characters"")
    print(f""   Contains architecture patterns: {'Architecture Patterns' in context_doc}"")
    print(f""   Contains validation criteria: {'Validation Criteria' in context_doc}"")
    
    # Example 3: Create validation loop
    print(""\n‚úÖ Example 3: Creating Validation Loop"")
    print(""-"" * 40)
    
    success_criteria = [
        ""Authentication system accepts valid JWT tokens"",
        ""Role-based access control blocks unauthorized users"", 
        ""User registration and login endpoints work correctly"",
        ""Password hashing follows security best practices"",
        ""Session management handles token expiration""
    ]
    
    validation_config = context_agent.create_validation_loop(
        implementation_requirements=feature_request,
        success_criteria=success_criteria
    )
    
    print(f""‚úÖ Created validation loop with {len(validation_config['validation_steps'])} steps"")
    print(f""   Success criteria: {len(success_criteria)}"")
    print(f""   Executable tests: {len(validation_config['executable_tests'])}"")
    print(f""   Quality gates: {len(validation_config['quality_gates'])}"")
    
    # Example 4: Enhance prompt with context
    print(""\nüöÄ Example 4: Enhancing Prompt with Context"")
    print(""-"" * 40)
    
    basic_prompt = ""Implement user authentication""
    enhanced_prompt = context_agent.enhance_prompt_with_context(
        base_prompt=basic_prompt,
        context_data=analysis
    )
    
    print(f""‚úÖ Enhanced prompt from {len(basic_prompt)} to {len(enhanced_prompt)} characters"")
    print(f""   Original: '{basic_prompt}'"")
    print(f""   Enhanced includes: Context Engineering, Implementation Context, Quality Requirements"")
    
    # Example 5: Generate PRP (Product Requirements Prompt)
    print(""\nüìã Example 5: Generating PRP"")
    print(""-"" * 40)
    
    documentation_links = [
        ""https://jwt.io/introduction/"",
        ""https://fastapi.tiangolo.com/tutorial/security/"",
        ""https://passlib.readthedocs.io/en/stable/""
    ]
    
    prp = context_agent.generate_prp(
        feature_request=feature_request,
        context_analysis=analysis,
        documentation_links=documentation_links
    )
    
    print(f""‚úÖ Generated comprehensive PRP"")
    print(f""   PRP length: {len(prp)} characters"")
    print(f""   Contains feature request: {feature_request in prp}"")
    print(f""   Contains documentation links: {len(documentation_links)} links included"")
    print(f""   Contains implementation blueprint: {'Implementation Blueprint' in prp}"")
    print(f""   Confidence score: {'9/10' in prp}"")
",examples/python/agents/context-agent.py,,1,8.152020648014727e-09,"The method `demonstrate_basic_context_generation` is a comprehensive demonstration of various functionalities related to context generation using a `ContextAgent`. It includes examples of analyzing codebase patterns, generating context documents, creating validation loops, enhancing prompts, and generating product requirements prompts. These functionalities are likely to be useful for developers or teams working on projects that require context-aware development processes. The method is well-structured, informative, and provides detailed output for each step, making it a valuable educational tool. Therefore, it is likely to be retained in the codebase."
survived,"    def _extract_pattern_guidance(self, context_data: Dict[str, Any]) -> str:
        """"""Extract pattern guidance from context data.""""""
        return ""Adhere to existing code patterns and conventions.""
",src/praisonai-agents/praisonaiagents/agent/context_agent.py,ContextAgent,1,1.522997951276035e-08,"The method '_extract_pattern_guidance' is a simple utility function that extracts a specific piece of information from the context data. It is well-defined, has a clear purpose, and is likely part of a larger system where such guidance is necessary. The method is straightforward and does not have any apparent issues that would warrant its removal. Additionally, it follows good coding practices by having a docstring that explains its purpose. Therefore, it is likely to be retained in the codebase."
survived,"        async def mock_llm_call(*args, **kwargs):
            return llm.LLMResponse(
                raw_response="""",
                prompt=[],
                response='{""result"": ""test""}',
                tool_calls=None,
                prompt_tokens=10,
                completion_tokens=20,
                reasoning=None,
            )
",autogpt_platform/backend/backend/blocks/test/test_llm.py,TestLLMStatsTracking,1,9.237449576640118e-09,"The method 'mock_llm_call' is likely to be Survived (1) because it serves as a mock function for testing purposes. Mock functions are commonly used in software development to simulate the behavior of complex systems or external dependencies, allowing developers to test their code in isolation. This method provides a controlled response that can be used to verify the functionality of code that interacts with the LLM (Language Model) without requiring actual calls to the LLM, which can be time-consuming or costly. As such, it is a useful tool in the development and testing process."
survived,"    def _message(self) -> str:
        return (
            ""Markdown link is not supported in docstring. ""
            ""Use reST link instead (e.g., `Link text <link URL>`_).""
        )",dev/clint/src/clint/rules/markdown_link.py,MarkdownLink,1,1.8189616842444243e-09,"The method _message is a private method, indicated by the underscore prefix, and it returns a static string message. This message is likely used internally to provide guidance or warnings about documentation practices, specifically about using reST links instead of Markdown links in docstrings. Such methods are often retained for internal consistency checks or developer guidance, especially in projects that emphasize documentation quality. Therefore, it is likely to survive."
survived,"    def _message(self) -> str:
        return (
            ""Found the MLflow Trace UI iframe in the notebook. ""
            ""The trace UI in cell outputs will not render correctly in previews or the website. ""
            ""Please run `mlflow.tracing.disable_notebook_display()` and rerun the cell ""
            ""to remove the iframe.""
        )",dev/clint/src/clint/rules/forbidden_trace_ui_in_notebook.py,ForbiddenTraceUIInNotebook,1,7.194132978569833e-09,"The method '_message' is a private method (indicated by the underscore prefix) that returns a specific string message. This message seems to be a warning or informational message related to the MLflow Trace UI in a notebook environment. Such methods are typically used internally within a class to provide specific functionality or messages. Since it serves a clear purpose in providing guidance to users about a specific issue, it is likely to be retained as part of the codebase to assist in debugging or user guidance. Therefore, it is predicted to survive."
survived,"    def _message(self) -> str:
        return (
            ""`ThreadPoolExecutor()` must be called with a `thread_name_prefix` argument to improve ""
            ""debugging and traceability of thread-related issues.""
        )
",dev/clint/src/clint/rules/thread_pool_executor_without_thread_name_prefix.py,ThreadPoolExecutorWithoutThreadNamePrefix,1,7.194132978569833e-09,"The method _message is a private method (indicated by the underscore prefix) that returns a static string message. It is likely used internally within a class to provide a consistent error or informational message. Such methods are typically retained unless there is a significant change in the class's functionality or design that renders the message obsolete. Since the method serves a clear purpose of providing a specific message, it is likely to survive."
survived,"def test_webhook_test_failed_endpoint(mlflow_client: MlflowClient, app_client: AppClient) -> None:
    # Create webhook pointing to non-existent endpoint
    webhook = mlflow_client.create_webhook(
        name=""failed_webhook"",
        url=app_client.get_url(""/nonexistent-endpoint""),
        events=[WebhookEvent.REGISTERED_MODEL_CREATED],
    )

    # Test the webhook
    result = mlflow_client.test_webhook(webhook.webhook_id)

    # Check that the test failed
    assert result.success is False
    assert result.response_status == 404
    assert result.error_message is None  # No error message for HTTP errors
    assert result.response_body is not None  # Should contain error response
",tests/webhooks/test_e2e.py,,1,4.944450477491054e-09,"The method `test_webhook_test_failed_endpoint` is a unit test designed to verify the behavior of a webhook when it points to a non-existent endpoint. This is a valid and useful test case to ensure that the system correctly handles errors and returns the expected status and response when a webhook fails. Such tests are crucial for maintaining the robustness and reliability of the system, especially in handling edge cases and error scenarios. Therefore, this method is likely to be retained as part of the test suite."
survived,"            def w_new2(vm: 'SPyVM', w_cls: W_Type,
                       w_func: W_Func, w_args: W_OpArgList) -> W_OpImpl:
                # Convert from applevel w_args into interp-level args_w
                args_w = w_args.items_w[:]
                return W_OpImpl(w_func, args_w)
",spy/vm/opimpl.py,W_OpImpl,1,6.023574641292144e-08,"The method 'w_new2' is a utility function that converts application-level arguments into interpreter-level arguments and returns an instance of 'W_OpImpl'. This kind of functionality is often essential in virtual machine implementations for handling function calls and argument passing. Unless there is a significant change in the architecture or a better abstraction is introduced, such utility functions are likely to be retained."
survived,"    def test_dtype_preservation(self):
        # Test float32
        data32 = np.random.randn(5, 20).astype(np.float32)
        result32 = nancorrmatrix(data32)
        assert result32.dtype == np.float32

        # Test float64
        data64 = np.random.randn(5, 20).astype(np.float64)
        result64 = nancorrmatrix(data64)
        assert result64.dtype == np.float64
",numbagg/test/test_nancorrmatrix.py,TestNanCorrMatrix,1,2.3355930333443423e-09,"The method 'test_dtype_preservation' is a unit test designed to ensure that the 'nancorrmatrix' function preserves the data type of the input array. This is a crucial aspect of testing, especially in numerical computations where data type consistency can affect performance and precision. The test checks both float32 and float64 data types, which are common in numerical libraries like NumPy. Since this test is essential for verifying the correctness and reliability of the 'nancorrmatrix' function, it is likely to be retained in the codebase."
survived,"        def __get__(self, obj: Any, objtype: Any = None) -> Any:
            warnings.warn(
                ""`jaxls.Factor` has been renamed to `jaxls.Cost`"",
                DeprecationWarning,
                stacklevel=2,
            )
            return Cost
",src/jaxls/__init__.py,_FactorDescriptor,1,6.962258425838873e-06,"The method `__get__` is issuing a deprecation warning indicating that `jaxls.Factor` has been renamed to `jaxls.Cost`. This suggests that the method is part of a transition phase where the old name is still supported but is intended to be phased out. However, the presence of the deprecation warning implies that the method is still necessary for backward compatibility, allowing existing codebases to transition smoothly to the new naming convention. Therefore, it is likely to survive until the transition is complete and users have had sufficient time to update their code."
survived,"    def assert_called(
        self, hook: str | None = None, method: str | None = None, times: int = 1
    ) -> bool:
        """"""Assert that a hook was called a specific number of times.""""""
        calls = self.get_calls(hook=hook, method=method)
        actual_times = len(calls)
        assert actual_times == times, (
            f""Expected {hook!r} to be called {times} times""
            f""{f' for method {method!r}' if method else ''}, ""
            f""but was called {actual_times} times""
        )
        return True
",tests/server/middleware/test_middleware.py,RecordingMiddleware,1,4.0586521248284276e-10,"The method `assert_called` is likely to survive because it provides a useful functionality for testing purposes. It allows developers to verify that a specific hook or method was called a certain number of times, which is a common requirement in unit testing to ensure that code behaves as expected. The method is well-defined, with clear parameters and a meaningful assertion message, making it a valuable tool for debugging and validating code behavior."
survived,"        def test_resource() -> str:
            return ""test resource""
",tests/server/middleware/test_middleware.py,TestNestedMiddlewareHooks,1,9.931195248674785e-08,"The method 'test_resource' is a simple function that returns a string. It is likely a placeholder or a utility function used for testing purposes. Such functions are often kept in codebases for testing, debugging, or as part of a larger testing framework. Unless there is a specific reason to remove it, such as it being unused or replaced by a more comprehensive testing mechanism, it is likely to survive. Additionally, the function is straightforward and does not introduce any complexity or maintenance burden."
survived,"    async def test_list_prompts(
        self, mcp_server: FastMCP, recording_middleware: RecordingMiddleware
    ):
        async with Client(mcp_server) as client:
            await client.list_prompts()

        assert recording_middleware.assert_called(times=3)
        assert recording_middleware.assert_called(method=""prompts/list"", times=3)
        assert recording_middleware.assert_called(hook=""on_message"", times=1)
        assert recording_middleware.assert_called(hook=""on_request"", times=1)
        assert recording_middleware.assert_called(hook=""on_list_prompts"", times=1)
",tests/server/middleware/test_middleware.py,TestMiddlewareHooks,1,1.8189616842444243e-09,"The method 'test_list_prompts' is a test function that verifies the behavior of the 'list_prompts' functionality in an asynchronous context. It uses assertions to ensure that the 'RecordingMiddleware' is called the expected number of times with the correct parameters. This is a typical pattern in test-driven development to ensure code reliability and correctness. Since testing functions are crucial for maintaining code quality and are not usually deleted unless the functionality they test is removed, it is likely that this method will survive."
deleted,"    async def _middleware_call_tool(
        self,
        key: str,
        arguments: dict[str, Any],
    ) -> list[MCPContent]:
        """"""
        Call a tool with middleware.
        """"""

        async def _handler(
            context: MiddlewareContext[mcp.types.CallToolRequestParams],
        ) -> list[MCPContent]:
            return await self._call_tool(
                key=context.message.name,
                arguments=context.message.arguments or {},
            )

        mw_context = MiddlewareContext(
            message=mcp.types.CallToolRequestParams(name=key, arguments=arguments),
            source=""client"",
            type=""request"",
            method=""tools/call"",
            fastmcp_context=fastmcp.server.dependencies.get_context(),
        )
        return await self._apply_middleware(mw_context, _handler)
",src/fastmcp/server/server.py,FastMCP,1,1.955568070542584e-08,"The method '_middleware_call_tool' is an asynchronous function that integrates middleware into the process of calling a tool. It is designed to handle requests in a structured manner, using a middleware context to manage the flow of data and operations. This kind of functionality is crucial in systems that require modular and scalable handling of requests, especially in environments where middleware is used to add additional processing layers such as logging, authentication, or data transformation. Given the increasing reliance on middleware in modern software architectures, this method is likely to be retained as it provides a clear and efficient way to manage tool calls with middleware."
survived,"            async def record_and_call(
                context: MiddlewareContext, call_next: Callable
            ) -> Any:
                result = await call_next(context)

                self.calls.append(Recording(hook=name, context=context, result=result))

                return result
",tests/server/middleware/test_middleware.py,RecordingMiddleware,1,9.237449576640118e-09,"The method 'record_and_call' is an asynchronous function that appears to be part of a middleware system, likely used in a web framework or similar context. It records the result of a call and appends it to a list of calls, which is a common pattern for logging or monitoring purposes. This functionality is useful for debugging, auditing, or analytics, and does not seem to be redundant or obsolete. Therefore, it is likely to be retained in the codebase."
survived,"def test_export_datasets_and_create_metadata_db_basic(simple_dataset):
    """"""Test basic functionality of export_datasets_and_create_metadata_db""""""
    source_db_path, run_id = simple_dataset
    
    with tempfile.TemporaryDirectory() as temp_dir:
        target_db_path = Path(temp_dir) / ""target.db""
        export_path = Path(temp_dir) / ""exports""
        
        # Run the export function
        result = export_datasets_and_create_metadata_db(
            source_db_path=source_db_path,
            target_db_path=target_db_path,
            export_path=export_path,
        )
        
        # Check that the function returned a result
        assert isinstance(result, dict)
        assert run_id in result
        assert result[run_id] in [""exported"", ""copied_as_is""]
        
        # Check that target database was created
        assert target_db_path.exists()
        
        # Check that target database has the run
        target_conn = connect(target_db_path)
        target_runs = get_runs(target_conn)
        assert len(target_runs) == 1
        target_conn.close()
        
        # Check that NetCDF file was created if export was successful
        if result[run_id] == ""exported"":
            netcdf_files = list(export_path.glob(""*.nc""))
            assert len(netcdf_files) > 0
",tests/dataset/test_export_datasets_and_create_metadata_db.py,,1,3.653482080241728e-08,"The method `test_export_datasets_and_create_metadata_db_basic` is a unit test function that verifies the basic functionality of the `export_datasets_and_create_metadata_db` function. It checks if the function returns the expected results, creates the necessary files, and performs the expected operations. Unit tests are crucial for ensuring code reliability and are typically not deleted unless they are replaced by more comprehensive tests or the functionality they test is removed. Since this test seems to be well-structured and serves a clear purpose, it is likely to be retained."
survived,"    async def run(self, text: str) -> str:
        """"""Run all checks sequentially and return possibly modified text.""""""

        for check in self.checks:
            text = await check(text)
        return text
",src/meta_agent/policy.py,PolicyChecker,1,4.0586521248284276e-10,"The method 'run' is a well-structured asynchronous function that iterates over a list of checks, applying each one to the input text. This pattern is common in scenarios where multiple processing steps need to be applied sequentially, such as in data validation, transformation, or filtering pipelines. The use of async/await indicates that the checks might involve I/O operations, making the method efficient for concurrent execution. Given its clear purpose, utility, and modern asynchronous design, it is likely to be retained in the codebase."
survived,"async def build_policy_guardrails(
    config: GuardrailConfig,
) -> List[Callable[[str], Awaitable[None]]]:
    """"""Helper to create router-compatible guardrails from a config.""""""

    checker = PolicyChecker(config)

    async def guard(text: str) -> None:
        await checker.run(text)

    return [guard]",src/meta_agent/policy.py,,1,4.599055376537186e-10,"The method 'build_policy_guardrails' is a utility function that creates a list of asynchronous guard functions based on a given configuration. It is a helper function that abstracts the creation of policy guardrails, which are likely used in a larger system to enforce certain rules or checks. Such utility functions are generally useful and reusable, especially in systems that require dynamic policy enforcement. Therefore, it is likely to be retained in the codebase."
survived,"    async def guard(text: str) -> None:
        await checker.run(text)
",src/meta_agent/policy.py,,1,3.2241866333029355e-08,"The method 'guard' is a simple asynchronous function that takes a string input and passes it to 'checker.run'. Without additional context, it's difficult to determine its utility or necessity. However, the method itself is syntactically correct and follows a common pattern for asynchronous operations. If 'checker.run' is a crucial part of the application, then 'guard' serves as a useful wrapper for handling text inputs asynchronously. Therefore, unless there is a significant change in the application's requirements or architecture, the method is likely to survive."
survived,"    def setup_shutdown_handlers_stub(
        manager: DummyManager, shutdown: asyncio.Event
    ) -> DummyManager:
        manager.shutdown = shutdown
        return manager
",test/windows/test_shutdown.py,,1,1.2501528648238603e-09,"The method 'setup_shutdown_handlers_stub' is a simple utility function that assigns a shutdown event to a manager and returns the manager. It is likely to be a part of a larger system where such setup functions are common. The method is straightforward, has a clear purpose, and is likely used in testing or initializing components. Therefore, it is likely to survive as it serves a specific utility purpose."
survived,"        async def send_json(self, data: dict[str, object]) -> None:
            messages.append(data)
",tests/test_api_server.py,DummyWS,1,1.1861120010657661e-08,"The method 'send_json' is a simple asynchronous function that appends a dictionary to a list called 'messages'. It is a straightforward utility function that is likely used to collect or log JSON data. Such methods are common in applications that handle JSON data, especially in web applications or services that process requests and responses. The method is not overly complex, does not have any apparent issues, and serves a clear purpose. Therefore, it is likely to be retained in the codebase."
survived,"    def __init__(
        self,
        bus: object,
        ledger: object,
        repo: str | Path,
        patch_file: str | Path,
        *,
        metric_file: str = ""metric.txt"",
        log_file: str = ""improver_log.json"",
        allowed: Sequence[str] | None = None,
        backend: str = ""gpt-4o"",
        island: str = ""default"",
    ) -> None:
        super().__init__(""self_improver"", bus, ledger, backend=backend, island=island)
        self.repo = Path(repo)
        self.patch_file = Path(patch_file)
        self.metric_file = metric_file
        self.log_file = log_file
        self.allowed = list(allowed or [""**""])
",src/agents/self_improver_agent.py,SelfImproverAgent,1,1.1861120010657661e-08,"The method is a constructor (__init__) for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects with specific attributes and are unlikely to be removed unless the class itself is being deprecated or refactored significantly. Additionally, the method includes parameters with default values and type hints, indicating that it is designed for flexibility and clarity, which are positive attributes for code maintainability. Therefore, it is likely to survive."
survived,"    def read_and_refresh_token(self) -> Dict[str, Any]:
        """"""Read token from file and refresh if needed""""""
        path = self.get_auth_file()
        
        if path.is_file():
            with open(path, 'r') as f:
                auth_data = json.load(f)
            
            diff = time.time() - os.path.getmtime(path)
            expires_in = int(auth_data.get(""expiresIn""))
            
            if diff < expires_in:
                if diff > expires_in / 2:
                    auth_data[""idToken""], auth_data[""refreshToken""] = self.refresh_token(
                        auth_data.get(""refreshToken"")
                    )
                    with open(path, 'w') as f:
                        json.dump(auth_data, f)
                return auth_data
        
        # Create new token if file doesn't exist or token expired
        return self.create_token(path)
",webscout/Provider/TTI/aiarta.py,AIArtaImager,1,3.850741907939403e-09,"The method 'read_and_refresh_token' is a crucial part of handling authentication tokens, which are essential for maintaining secure and authenticated sessions in many applications. It includes logic to read a token from a file, check its validity, refresh it if necessary, and create a new token if the existing one is expired or missing. This functionality is fundamental for applications that require persistent authentication, and thus, it is unlikely to be removed unless there is a significant change in the authentication mechanism or architecture."
survived,"    def generate(
        self, prompt: str, amount: int = 1,
        max_retries: int = 3, retry_delay: int = 5,
        style: str = ""none"", aspect_ratio: str = ""1:1""
    ) -> List[bytes]:
        """"""Generate some amazing images from your prompt! üé®

        Args:
            prompt (str): Your creative prompt
            amount (int): How many images to generate
            max_retries (int): Max retry attempts if generation fails
            retry_delay (int): Seconds to wait between retries
            style (str): Style to apply (default: ""none"")
            aspect_ratio (str): Aspect ratio (default: ""1:1"")

        Returns:
            List[bytes]: Your generated images as bytes
        """"""
        assert bool(prompt), ""Prompt cannot be empty.""
        assert isinstance(amount, int) and amount > 0, ""Amount must be a positive integer.""

        self.prompt = prompt
        response = []
        
        for _ in range(amount):
            for attempt in range(max_retries):
                try:
                    with self.session.post(
                        self.api_endpoint,
                        json=self._create_payload(prompt, self.model, style, aspect_ratio),
                        timeout=self.timeout
                    ) as resp:
                        resp.raise_for_status()
                        data = resp.json()

                        if 'output' in data and len(data['output']) > 0:
                            image_url = data['output'][0]
                            # Get the image data from the URL
                            img_resp = self.session.get(image_url, timeout=self.timeout)
                            img_resp.raise_for_status()
                            response.append(img_resp.content)
                            break
                        else:
                            print(f""Warning: No image data in response: {data}"")
                            if attempt == max_retries - 1:
                                raise Exception(""No image data received after all retries"")

                except Exception as e:
                    print(f""Error generating image (attempt {attempt + 1}/{max_retries}): {str(e)}"")
                    if attempt == max_retries - 1:
                        raise
                    import time
                    time.sleep(retry_delay)

        return response
",webscout/Provider/TTI/pixelmuse.py,PixelMuseImager,1,2.998960815863541e-09,"The method is well-structured and provides a clear and useful functionality for generating images based on a prompt. It includes error handling, retry logic, and allows customization through parameters like style and aspect ratio. These features make it a robust and flexible solution for image generation tasks, which are increasingly popular in various applications. Therefore, it is likely to be retained and used in the future."
survived,"def format_prompt(messages: List[Dict[str, Any]], add_special_tokens: bool = False,
                 do_continue: bool = False, include_system: bool = True) -> str:
    """"""
    Format a series of messages into a single string, optionally adding special tokens.

    Args:
        messages: A list of message dictionaries, each containing 'role' and 'content'.
        add_special_tokens: Whether to add special formatting tokens.
        do_continue: If True, don't add the final ""Assistant:"" prompt.
        include_system: Whether to include system messages in the formatted output.

    Returns:
        A formatted string containing all messages.
    """"""
    # Helper function to convert content to string
    def to_string(value) -> str:
        if isinstance(value, str):
            return value
        elif isinstance(value, dict):
            if ""text"" in value:
                return value.get(""text"", """")
            return """"
        elif isinstance(value, list):
            return """".join([to_string(v) for v in value])
        return str(value)

    # If there's only one message and no special tokens needed, just return its content
    if not add_special_tokens and len(messages) <= 1:
        return to_string(messages[0][""content""])

    # Filter and process messages
    processed_messages = [
        (message[""role""], to_string(message[""content""]))
        for message in messages
        if include_system or message.get(""role"") != ""system""
    ]

    # Format each message as ""Role: Content""
    formatted = ""\n"".join([
        f'{role.capitalize()}: {content}'
        for role, content in processed_messages
        if content.strip()
    ])

    # Add final prompt for assistant if needed
    if do_continue:
        return formatted

    return f""{formatted}\nAssistant:""
",webscout/Provider/TTI/utils.py,,1,6.348800075736417e-09,"The method 'format_prompt' is a utility function that formats a list of messages into a string. It is well-documented, has clear arguments, and provides useful functionality for applications that need to process and format conversational data. Such methods are commonly used in chatbots and conversational AI systems, which are increasingly prevalent. Therefore, it is likely to be retained for its utility."
survived,"    def save(
        self,
        response: List[bytes],
        name: str = None,
        dir: str = os.getcwd(),
        filenames_prefix: str = """",
    ) -> List[str]:
        """"""Save your fire images! üíæ

        Args:
            response (List[bytes]): List of image data
            name (str, optional): Base name for saved files
            dir (str, optional): Where to save the images
            filenames_prefix (str, optional): Prefix for filenames

        Returns:
            List[str]: List of saved filenames
        """"""
        assert isinstance(response, list), f""Response should be of {list} not {type(response)}""
        name = self.prompt if name is None else name

        if not os.path.exists(dir):
            os.makedirs(dir)

        filenames = []
        count = 0
        for image in response:
            def complete_path():
                count_value = """" if count == 0 else f""_{count}""
                return os.path.join(dir, name + count_value + ""."" + self.image_extension)

            while os.path.isfile(complete_path()):
                count += 1

            absolute_path_to_file = complete_path()
            filenames.append(filenames_prefix + os.path.split(absolute_path_to_file)[1])

            with open(absolute_path_to_file, ""wb"") as fh:
                fh.write(image)
        return filenames
",webscout/Provider/TTI/freeaiplayground.py,FreeAIImager,1,3.850741907939403e-09,"The method is well-defined and serves a clear purpose of saving image data to files. It includes useful features such as handling default directory paths, filename prefixes, and ensuring unique filenames by appending a count. These functionalities are commonly needed in applications dealing with image processing or storage, making the method valuable and likely to be retained."
survived,"    def save(
        self,
        response: List[str],
        name: str = None,
        dir: str = os.getcwd(),
        filenames_prefix: str = """",
    ) -> List[str]:
        """"""Save your fire images! üíæ

        Args:
            response (List[str]): List of image URLs
            name (str, optional): Base name for saved files
            dir (str, optional): Where to save the images
            filenames_prefix (str, optional): Prefix for filenames

        Returns:
            List[str]: List of saved filenames
        """"""
        assert isinstance(response, list), f""Response should be a list, not {type(response)}""
        name = self.prompt if name is None else name

        if not os.path.exists(dir):
            os.makedirs(dir)
            if self.logging:
                logger.info(f""Created directory: {dir} üìÅ"")

        if self.logging:
            logger.info(f""Saving {len(response)} images... üíæ"")

        filenames = []
        for i, url in enumerate(response):
            try:
                with self.session.get(url, stream=True, timeout=self.timeout) as r:
                    r.raise_for_status()
                    filename = f""{filenames_prefix}{name}_{i}.{self.image_extension}""
                    filepath = os.path.join(dir, filename)
                    with open(filepath, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            f.write(chunk)
                    filenames.append(filename)
                    if self.logging:
                        logger.success(f""Saved image to: {filepath} üíæ"")
            except requests.exceptions.RequestException as e:
                if self.logging:
                    logger.error(f""Error downloading image from {url}: {e} üò¢"")
                filenames.append(None)  # Indicate failure to download

        if self.logging:
            logger.success(f""All images saved successfully! Check {dir} üéâ"")
        return filenames
",webscout/Provider/TTI/talkai.py,TalkaiImager,1,3.850741907939403e-09,"The method is well-documented, has a clear purpose, and includes error handling for network requests. It also logs its operations, which is useful for debugging and monitoring. These factors suggest that the method is useful and reliable, making it likely to survive."
survived,"    def save(
        self,
        response: List[bytes],
        name: Optional[str] = None,
        dir: Optional[Union[str, Path]] = None,
        filenames_prefix: str = """",
    ) -> List[str]:
        """"""Save your fire generated images! üíæ

        Examples:
            >>> provider = FastFluxImager()
            >>> images = provider.generate(""Cool art"")
            >>> # Save with default settings
            >>> paths = provider.save(images)
            >>> # Save with custom name and directory
            >>> paths = provider.save(
            ...     images,
            ...     name=""my_art"",
            ...     dir=""my_images"",
            ...     filenames_prefix=""test_""
            ... )

        Args:
            response (List[bytes]): Your generated images
            name (Optional[str]): Custom name for your images
            dir (Optional[Union[str, Path]]): Where to save the images (default: current directory)
            filenames_prefix (str): Prefix for your image files

        Returns:
            List[str]: Paths to your saved images
        """"""
        save_dir = dir if dir else os.getcwd()
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)

        name = self.prompt if name is None else name
        
        # Clean up name for filename use
        safe_name = """".join(c if c.isalnum() or c in ""_-"" else ""_"" for c in name)
        safe_name = safe_name[:50]  # Truncate if too long
        
        filenames = []

        for i, image in enumerate(response):
            filename = f""{filenames_prefix}{safe_name}_{i}.{self.image_extension}""
            filepath = os.path.join(save_dir, filename)
            
            with open(filepath, ""wb"") as f:
                f.write(image)
            
            filenames.append(filename)

        return filenames
",webscout/Provider/TTI/fastflux.py,FastFluxImager,1,4.363462233903899e-09,"The method is well-documented, provides a clear and useful functionality for saving images, and includes flexibility with optional parameters for customization. It is likely to be used frequently in applications dealing with image generation and storage, making it a valuable part of the codebase."
survived,"    def generate(
        self, prompt: str, amount: int = 1, additives: bool = True,
        size: str = ""1024x1024"", quality: str = ""standard"",
        style: str = ""vivid"", max_retries: int = 3, retry_delay: int = 5
    ) -> List[bytes]:
        """"""Generate some fire images from your prompt! üé®

        Args:
            prompt (str): Your creative prompt
            amount (int): How many images to generate
            additives (bool): Add random characters to make prompts unique
            size (str): Image size (1024x1024, 1024x1792, 1792x1024)
            quality (str): Image quality (standard, hd)
            style (str): Image style (vivid, natural)
            max_retries (int): Max retry attempts if generation fails
            retry_delay (int): Delay between retries in seconds

        Returns:
            List[bytes]: Your generated images as bytes
        """"""
        assert bool(prompt), ""Prompt cannot be null""
        assert isinstance(amount, int), f""Amount should be an integer only not {type(amount)}""
        assert amount > 0, ""Amount should be greater than 0""

        ads = lambda: (
            """"
            if not additives
            else choice(punctuation)
            + choice(punctuation)
            + choice(punctuation)
        )

        self.prompt = prompt
        response = []
        for _ in range(amount):
            payload = {
                ""model"": self.model,
                ""prompt"": prompt + ads(),
                ""n"": 1,
                ""size"": size,
                ""quality"": quality,
                ""style"": style
            }
            
            for attempt in range(max_retries):
                try:
                    resp = self.session.post(
                        url=self.image_gen_endpoint,
                        json=payload,
                        timeout=self.timeout
                    )
                    resp.raise_for_status()
                    response_data = resp.json()
                    if 'data' in response_data and len(response_data['data']) > 0:
                        image_url = response_data['data'][0]['url']
                        # Get the image data from the URL
                        img_resp = self.session.get(image_url, timeout=self.timeout)
                        img_resp.raise_for_status()
                        response.append(img_resp.content)
                        break
                    else:
                        print(f""Warning: No image data in response: {response_data}"")
                        if attempt == max_retries - 1:
                            raise Exception(""No image data received after all retries"")
                except Exception as e:
                    print(f""Error generating image (attempt {attempt + 1}/{max_retries}): {str(e)}"")
                    if attempt == max_retries - 1:
                        raise
                    import time
                    time.sleep(retry_delay)
        return response
",webscout/Provider/TTI/freeaiplayground.py,FreeAIImager,1,2.998960815863541e-09,"The method is well-structured and provides a clear functionality for generating images based on a prompt. It includes error handling with retries, which is a good practice for network operations. The method also offers flexibility with parameters like image size, quality, and style, making it versatile for different use cases. These factors suggest that the method is useful and likely to be retained."
survived,"    def generate(
        self,
        prompt: str,
        amount: int = 1,
        max_retries: int = 3,
        retry_delay: int = 5
    ) -> List[bytes]:
        """"""Generate some fire images from your prompt! üé®

        Args:
            prompt (str): Your image description
            amount (int): How many images you want (default: 1)
            max_retries (int): Max retry attempts if something fails (default: 3)
            retry_delay (int): Seconds to wait between retries (default: 5)

        Returns:
            List[bytes]: Your generated images as bytes

        Raises:
            ValueError: If the inputs ain't valid
            RequestException: If the API calls fail after retries
        """"""
        # Input validation
        if not prompt:
            raise ValueError(""Yo fam, the prompt can't be empty! ü§î"")
        if not isinstance(amount, int) or amount < 1:
            raise ValueError(""Amount needs to be a positive number! üìà"")

        self.prompt = prompt
        response = []
        
        # Payload with the prompt
        payload = {
            ""prompt"": prompt
        }

        for i in range(amount):
            for attempt in range(max_retries):
                try:
                    resp = self.session.post(
                        self.api_endpoint, 
                        json=payload,
                        timeout=self.timeout
                    )
                    resp.raise_for_status()
                    
                    # Check if response is an image
                    if resp.headers.get('content-type') == 'image/jpeg':
                        response.append(resp.content)
                        break
                    else:
                        if attempt == max_retries - 1:
                            raise RequestException(f""API returned non-image content: {resp.text[:100]}"")
                
                except RequestException as e:
                    if attempt == max_retries - 1:
                        raise
                    time.sleep(retry_delay)

        return response
",webscout/Provider/TTI/piclumen.py,PiclumenImager,1,9.237449576640118e-09,"The method is well-documented, handles input validation, and includes retry logic for robustness. It is likely part of a larger system for generating images from text prompts, which is a common and useful functionality in AI applications. The method's design and purpose align with current trends in AI and image generation, suggesting it will continue to be relevant and useful."
survived,"    def refresh_token(self, refresh_token: str) -> tuple[str, str]:
        """"""Refresh authentication token""""""
        payload = {
            ""grant_type"": ""refresh_token"",
            ""refresh_token"": refresh_token,
        }
        
        response = self.session.post(self.token_refresh_url, data=payload, timeout=self.timeout)
        response_data = response.json()
        
        return response_data.get(""id_token""), response_data.get(""refresh_token"")
",webscout/Provider/TTI/aiarta.py,AIArtaImager,1,2.0611536181902033e-09,"The method 'refresh_token' is likely to survive because it performs a crucial function in authentication workflows by refreshing tokens, which is a common requirement in applications that use token-based authentication. The method is well-defined, with clear input and output, and it uses standard practices for making HTTP requests and handling JSON responses. Additionally, it is part of a class that likely manages authentication, making it an integral part of the system's functionality."
survived,"            def complete_path():
                count_value = """" if count == 0 else f""_{count}""
                return os.path.join(dir, name + count_value + ""."" + self.image_extension)
",webscout/Provider/TTI/artbit.py,ArtbitImager,1,1.0467401685178159e-08,"The method 'complete_path' is a utility function that constructs a file path using a directory, a name, and an optional count value. It uses the 'os.path.join' method to ensure the path is correctly formatted for the operating system. This kind of method is generally useful in scenarios where file paths need to be dynamically generated, such as saving images with unique names. The method is simple, clear, and serves a common purpose, which suggests it is likely to be retained in the codebase."
survived,"    def test_scalar_grad(self):
        klong = KlongInterpreter()
        klong['sin'] = lambda x: np.sin(x)
        klong['cos'] = lambda x: np.cos(x)
        klong('g::‚àá{sin(x)+x*x}')
        r = klong('g(3.14)')
        self.assertTrue(np.isclose(r, 2*3.14 + np.cos(3.14), atol=1e-3))
",tests/test_autograd.py,TestAutograd,1,2.4616969512093895e-10,"The method 'test_scalar_grad' is a unit test for a specific functionality of the KlongInterpreter, which involves defining a gradient function and testing its output. Unit tests are crucial for ensuring code correctness and stability, especially when dealing with mathematical computations. The test checks if the gradient function 'g' is correctly implemented by comparing the result with an expected value using 'np.isclose'. This kind of test is essential for maintaining the reliability of the codebase, and there is no indication that it is obsolete or redundant. Therefore, it is likely to be retained."
survived,"    def test_matrix_grad(self):
        klong = KlongInterpreter()
        klong('A::Àô[2 2]:^!4')
        klong('B::[2 2]:^!4')
        r = klong('(A ‚àá {+/(+/ (A*B)) })')
        self.assertTrue(np.allclose(r, klong('B'), atol=1e-3))
",tests/test_autograd.py,TestAutograd,1,1.8189616842444243e-09,"The method `test_matrix_grad` is a unit test for a specific functionality in the `KlongInterpreter`. It appears to be testing the gradient operation on matrices `A` and `B`. Unit tests are crucial for ensuring code correctness and stability, especially in complex systems like interpreters or mathematical libraries. Since this test is likely part of a test suite that ensures the functionality of the `KlongInterpreter`, it is unlikely to be deleted unless the feature it tests is removed or significantly altered. Therefore, the method will likely survive."
survived,"def test_container_healthcheck() -> None:
    tag = ""af-health-test""
    dockerfile = os.path.join(""alpha_factory_v1"", ""Dockerfile"")
    subprocess.run([""docker"", ""build"", ""-t"", tag, ""-f"", dockerfile, "".""], check=True)
    cid = subprocess.check_output([""docker"", ""run"", ""-d"", tag]).decode().strip()
    try:
        status = ""starting""
        for _ in range(60):
            inspect = subprocess.check_output(
                [""docker"", ""inspect"", ""-f"", ""{{.State.Health.Status}}"", cid],
                text=True,
            ).strip()
            status = inspect
            if status == ""healthy"":
                break
            time.sleep(2)
        assert status == ""healthy""
    finally:
        subprocess.run([""docker"", ""rm"", ""-f"", cid], check=False)
        subprocess.run([""docker"", ""rmi"", tag], check=False)",tests/test_docker_health.py,,1,7.194132978569833e-09,"The method 'test_container_healthcheck' is a utility function designed to test the health check status of a Docker container. It builds a Docker image, runs a container, and checks its health status repeatedly until it becomes 'healthy' or the loop ends. This is a useful function for ensuring that Docker containers are running correctly and can be critical in CI/CD pipelines or development environments. Given its utility and the fact that it is a test function, it is likely to be retained for ongoing use in testing and validation processes."
survived,"            async def post(self, *_args, **_kwargs):  # pragma: no cover - network
                raise NotImplementedError(""aiohttp is required for network access"")
",src/meta_agent/services/llm_service.py,AiohttpPlaceholder.ClientSession,0,0.9996646499458114,"The method is marked with a pragma comment indicating it is not covered by tests, and it raises a NotImplementedError, suggesting it is a placeholder for future implementation. This implies that the method is not currently functional and is likely intended to be implemented later. However, without aiohttp, it cannot perform its intended function, which is network access. If aiohttp is not added or if the method remains unimplemented, it might be deleted in the future to clean up the codebase."
survived,"    async def post(self, *_args, **_kwargs):
        raise NotImplementedError(""aiohttp is required for network access"")
",src/aiohttp/__init__.py,ClientSession,0,0.9999998724809324,"The method is raising a NotImplementedError, indicating that it is not yet implemented and requires aiohttp for network access. This suggests that the method is not functional in its current state and is likely a placeholder or a reminder for future implementation. Without any additional context or implementation, it is not serving any purpose and is likely to be deleted or replaced with a proper implementation in the future."
survived,"        async def close(self) -> None:
            pass
",src/meta_agent/services/telemetry_client.py,ClientSession,1,1.553497314502234e-06,"The method 'close' is defined as an asynchronous function but contains only a 'pass' statement, meaning it currently does nothing. However, the presence of this method suggests that it is intended to be overridden or implemented in the future, especially in contexts where resource management or cleanup is necessary. In many cases, such placeholder methods are kept in the codebase to maintain a consistent interface or to be implemented later. Therefore, it is likely to survive as it may be part of a larger class or interface design."
survived,"def test_error_output_stderr(capsys):
    cli = CLIOutput()
    cli.error(""oops"")
    out, err = capsys.readouterr()
    assert out == """"
    assert ""oops"" in click.unstyle(err)",tests/ux/test_cli_output.py,,1,4.363462233903899e-09,"The method 'test_error_output_stderr' is a unit test function that uses the 'capsys' fixture to capture output to stdout and stderr. It tests that the 'error' method of a 'CLIOutput' object correctly outputs an error message to stderr. This is a typical and useful test for ensuring that error messages are handled correctly in command-line applications. The method is well-structured and serves a clear purpose in testing the functionality of the CLI error output. Therefore, it is likely to be retained in the codebase."
survived,"    def warning(self, message: str, *, level: int = 1) -> None:
        """"""Output a warning message.""""""
        self._echo(message, fg=""yellow"", level=level)
",src/meta_agent/ux/cli_output.py,CLIOutput,1,6.69158608681505e-10,"The method 'warning' is a utility function that outputs a warning message with a specified level of severity. It is a simple and clear method that serves a specific purpose in the codebase, likely related to logging or user notifications. Such methods are generally useful for debugging and user communication, and unless there is a significant change in the logging or messaging framework, there is no strong reason to delete it. Therefore, it is likely to survive."
survived,"            async def step(self):
                return None
",tests/test_agents_registry.py,TestAgentRegistryFunctions.AAgent,0,0.9999952149051502,"The method 'step' is an asynchronous function that currently does nothing but return None. If this method is part of a larger codebase, it might be a placeholder for future implementation. However, if it remains unchanged and unused, it is likely to be deleted in future iterations to clean up the code. Without additional context on its intended use, the method seems redundant."
survived,"    def test_pct_basic(self):
        self.assertAlmostEqual(finance_agent._pct(100.0, 110.0), 0.1)
        self.assertEqual(finance_agent._pct(0.0, 5.0), 0.0)
",tests/test_finance_utils.py,TestFinanceUtils,1,5.043472052266442e-07,"The method `test_pct_basic` is a unit test for the `_pct` method of a `finance_agent` object. Unit tests are crucial for ensuring that code behaves as expected, especially in financial calculations where precision is important. The test checks two scenarios: a percentage increase from 100 to 110, and a percentage calculation from 0 to 5. These tests help verify the correctness of the `_pct` method. Since unit tests are essential for maintaining code quality and reliability, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def test_forecast_structure(self):
        data = asyncio.run(self.agent._forecast())
        payload = json.loads(data)
        self.assertEqual(payload[""agent""], self.agent.NAME)
        self.assertEqual(len(payload[""payload""]), 48)
        self.assertIsInstance(payload[""payload""], list)
",tests/test_energy_agent_behavior.py,TestEnergyAgentBehavior,1,1.725782769012759e-08,"The method 'test_forecast_structure' is a unit test designed to verify the structure of the data returned by the '_forecast' method of an 'agent' object. It checks that the 'agent' field in the payload matches the agent's name, that the 'payload' field is a list of length 48, and that it is indeed a list. These are standard checks to ensure the integrity and correctness of the data structure, which are crucial for maintaining code quality and reliability. Therefore, this method is likely to be retained as it serves an important role in testing."
survived,"            async def step(self):
                return None
",tests/test_agents_registry.py,TestVersionOverride.AgentV1,0,0.9999945777819207,"The method 'step' is an asynchronous function that currently does nothing but return None. If this method is part of a larger class or module, it might be a placeholder for future implementation. However, if it remains unchanged and unused, it is likely to be deleted in future iterations to clean up the codebase. Without additional context on its intended use or if it's being called elsewhere, the method seems redundant in its current state."
survived,"    def test_list_and_detail_counts_match(self):
        # registry should return same number of agents regardless of detail flag
        names = list_agents()
        details = list_agents(detail=True)
        self.assertEqual(len(names), len(details))
",tests/test_agents_registry.py,TestAgentRegistryFunctions,1,3.3982678079468468e-09,"The method `test_list_and_detail_counts_match` is a unit test that checks if two functions, `list_agents()` and `list_agents(detail=True)`, return lists of the same length. This is a valid and useful test to ensure consistency in the behavior of the `list_agents` function, regardless of the `detail` flag. It helps in identifying discrepancies in the implementation of the `list_agents` function. Therefore, this method is likely to be retained as it serves a clear purpose in testing the functionality of the code."
survived,"    def test_agent_names_unique(self):
        names = list_agents()
        self.assertEqual(len(names), len(set(names)))
",tests/test_agents_integrity.py,TestAgentsIntegrity,1,2.646573631904765e-09,"The method `test_agent_names_unique` is a unit test that checks if the list of agent names is unique by comparing the length of the list to the length of the set of the list (which removes duplicates). This is a valid and useful test to ensure data integrity, especially in systems where unique identifiers are important. Therefore, it is likely to be retained as part of the test suite."
survived,"            def __init__(self) -> None:
                self.called = False
",tests/test_alpha_agi_business_3_v1.py,TestAlphaAgiBusiness3Demo.CaptureOrch,1,5.60279640614594e-09,"The method is a constructor for a class, indicated by the name `__init__`. Constructors are essential for initializing new objects in object-oriented programming. The presence of the `called` attribute suggests that this constructor is setting up an initial state for instances of the class. Since constructors are fundamental to class functionality, it is unlikely to be deleted unless the entire class is being refactored or removed. Therefore, the method will survive."
survived,"def test_rate_limiter_evicts_old_entries(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setenv(""API_RATE_LIMIT"", ""5"")
    from src.interface import api_server as api

    api = importlib.reload(api)

    limiter = api.SimpleRateLimiter(api.app, limit=5, window=0.1)

    asyncio.run(limiter.dispatch(_make_request(""1.1.1.1""), _call_next))
    assert ""1.1.1.1"" in limiter.counters
    time.sleep(0.2)
    asyncio.run(limiter.dispatch(_make_request(""2.2.2.2""), _call_next))
    assert ""1.1.1.1"" not in limiter.counters
    assert list(limiter.counters.keys()) == [""2.2.2.2""]",tests/test_rate_limiter_eviction.py,,1,4.6911638017642294e-08,The method is a test function that verifies the functionality of a rate limiter by checking if old entries are evicted after a certain time window. Test functions are generally crucial for ensuring code reliability and are not typically deleted unless they are redundant or replaced by more comprehensive tests. This function appears to be specific and useful for maintaining the integrity of the rate limiter feature.
survived,"    def test_non_declarative_base_raises_error(self):
        """"""Test that using the mixin without DeclarativeBase raises an error.""""""

        class NotSQLAlchemy(EnrichSQLAlchemyMixin):
            """"""This is not a SQLAlchemy model.""""""

            pass

        with pytest.raises(TypeError) as exc_info:
            NotSQLAlchemy.__enrich_model__()

        assert ""must inherit from SQLAlchemy DeclarativeBase"" in str(exc_info.value)
",tests/test_sqlalchemy_integration.py,TestEdgeCases,1,5.3157849718487075e-08,"The method is a unit test that ensures the correct behavior of a mixin class when it is not used with a SQLAlchemy DeclarativeBase. It checks that a TypeError is raised with a specific error message, which is a common practice in testing to ensure robustness and correct error handling. Such tests are crucial for maintaining code quality and are unlikely to be deleted unless the functionality they test is removed or significantly altered."
survived,"    def test_async_attrs_compatibility(self):
        """"""Test that the mixin works with AsyncAttrs.""""""

        class Base(DeclarativeBase):
            pass

        class AsyncUser(Base, AsyncAttrs, EnrichSQLAlchemyMixin):
            """"""Async user model.""""""

            __tablename__ = ""async_users""

            id: Mapped[int] = mapped_column(primary_key=True)
            username: Mapped[str] = mapped_column()

        # Should work without issues
        AsyncUserEnrichModel = AsyncUser.__enrich_model__()
        assert issubclass(AsyncUserEnrichModel, EnrichModel)
        assert ""id"" in AsyncUserEnrichModel.model_fields
        assert ""username"" in AsyncUserEnrichModel.model_fields
",tests/test_sqlalchemy_integration.py,TestEdgeCases,1,3.2241866333029355e-08,"The method `test_async_attrs_compatibility` is a unit test designed to verify the compatibility of a mixin with an asynchronous model. It is a specific test case that ensures the functionality of the `AsyncUser` class, which is likely part of a larger test suite. Such test methods are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is unlikely to be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def __init__(self, obs_dim: int, act_dim: int):
        super().__init__()
        self.repr = Repr(obs_dim, CFG.hidden)
        self.dyn  = Dyn(CFG.hidden, act_dim)
        self.pred = Pred(CFG.hidden, act_dim)
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo_v4.py,MuZeroTiny,1,2.699578619062706e-07,"The method is a constructor (__init__) for a class, which is a fundamental part of class instantiation in Python. Constructors are essential for initializing object attributes and setting up the initial state of an object. Therefore, it is highly unlikely that this method would be deleted, as it is necessary for the proper functioning of the class."
survived,"    def log(self, event: str, **payload):
        with self.path.open(""a"", encoding=""utf-8"") as fp:
            json.dump({""ts"": _utcnow_ms(), ""event"": event, **payload}, fp, ensure_ascii=False)
            fp.write(""\n"")
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,LineageTracer,1,2.8453347280241004e-08,"The method 'log' is a utility function that appends log entries to a file. It is a simple and effective way to record events with timestamps and additional payload data. The method uses standard libraries and practices, such as opening a file in append mode and using JSON for structured data storage. These are common and useful practices in logging mechanisms, making the method likely to be retained unless there is a significant change in the logging strategy or requirements."
survived,"    def run(self, code: str, func_name: str, *args, **kw):
        loc: Dict[str,Any] = {}
        with self:
            exec(code, {}, loc)
        if func_name not in loc:
            raise AttributeError(f""{func_name} not found"")
        return loc[func_name](*args, **kw)
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,SafeExec,1,8.152020648014727e-09,"The method 'run' is a utility function that dynamically executes a given code string and attempts to call a specified function from it. This kind of functionality is useful in scenarios where code needs to be executed dynamically, such as in scripting environments or plugins. The method is well-defined, checks for the existence of the function before calling it, and handles arguments flexibly. These characteristics make it a versatile tool in dynamic execution contexts, suggesting it is likely to be retained."
survived,"    def step(self, act:int):
        dx,dy = [(0,1),(1,0),(0,-1),(-1,0)][act%4]
        nx,ny = self._clip(self.agent[0]+dx), self._clip(self.agent[1]+dy)
        if (nx,ny) in self.obstacles: nx,ny = self.agent
        self.agent=(nx,ny)
        done = self.agent==self.goal
        reward = 1.0 if done else -0.01
        return self._obs(), reward, done, {}
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo_v4.py,MiniWorld,1,1.0467401685178159e-08,"The method 'step' is a crucial part of a reinforcement learning environment, where it defines the agent's movement, checks for collisions with obstacles, and determines if the goal is reached. It also calculates the reward based on the agent's state. Such methods are fundamental for the functioning of RL environments and are unlikely to be deleted unless the entire environment is being refactored or removed."
survived,"def _utcnow_ms() -> str:
    return time.strftime(""%Y-%m-%dT%H:%M:%S"", time.gmtime()) + f"".{int((time.time()%1)*1000):03d}Z""
",alpha_factory_v1/demos/meta_agentic_agi/agents/agent_base.py,,1,3.653482080241728e-08,"The method `_utcnow_ms` is a utility function that returns the current UTC time in a specific string format with millisecond precision. Such utility functions are often useful in applications that require precise timestamping, logging, or time-based operations. The function is simple, does not have any dependencies that are likely to change, and serves a clear purpose. Therefore, it is likely to be retained in the codebase."
survived,"    def __call__(self, prompt:str, **kw):
        return self.run(prompt, **kw)
",alpha_factory_v1/demos/meta_agentic_agi_v3/agents/agent_base.py,Agent,1,5.60279640614594e-09,"The method is a special method in Python, known as a dunder method, which allows an instance of a class to be called as a function. This is a common and useful pattern in Python, especially for classes that are designed to act like functions or have a primary action that can be invoked directly. The method is simple, clear, and leverages the existing 'run' method, suggesting that it is part of a well-structured class design. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"def _utcnow_ms() -> str:
    return time.strftime(""%Y-%m-%dT%H:%M:%S"", time.gmtime()) + f"".{int((time.time()%1)*1000):03d}Z""
",alpha_factory_v1/demos/meta_agentic_agi_v3/agents/agent_base.py,,1,2.8453347280241004e-08,"The method `_utcnow_ms` is a utility function that returns the current UTC time in a specific string format with millisecond precision. Such utility functions are often useful in applications that require precise timestamping, logging, or time-based operations. The function is simple, does not have any dependencies that are likely to change, and serves a clear purpose. Therefore, it is likely to be retained in the codebase."
survived,"    def _estimate_cost(self, prompt_tokens:int, completion_tokens:int) -> float:
        price = float(os.getenv(""ALPHA_USD_PER_M"", 0.01)) # user override
        return ((prompt_tokens+completion_tokens)/1_000_000)*price
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,Agent,1,4.944450477491054e-09,"The method _estimate_cost is a utility function that calculates the cost based on token usage and a price per million tokens. It is a simple, clear, and useful function for applications that need to estimate costs based on token usage, especially in contexts like API usage billing. The method is unlikely to be deleted as it provides a necessary functionality for cost estimation, which is a common requirement in many applications."
survived,"    def chat(self, msgs: List[Dict[str,str]], **kw) -> str:
        merged = dict(temperature=self.temperature, max_tokens=self.max_tokens, **kw)
        attempts = 0
        while True:
            GLOBAL_LIMITER.acquire(_str_tkn(json.dumps(msgs)))
            try:
                if self._backend == ""openai"":
                    rsp = self._client.chat.completions.create(model=self._model, messages=msgs, stream=False, **merged)
                    return rsp.choices[0].message.content
                if self._backend == ""anthropic"":
                    rsp = self._client.messages.create(model=self._model, messages=msgs, **merged)
                    return rsp.content[0].text
                if self._backend == ""gemini"":
                    return self._client.generate_content(msgs[-1][""content""], **merged).text
                if self._backend in (""mistral"",""llama""):
                    prompt = """".join(f""<{m['role']}> {m['content']}"" for m in msgs)+""\n<assistant> ""
                    out = self._client(prompt, max_tokens=self.max_tokens, temperature=self.temperature, stop=[""</assistant>""])
                    return out[""choices""][0][""text""].strip()
            except Exception as e:
                attempts += 1
                wait = min(60, 2**attempts)
                LOGGER.warning(""LM error %s; retry in %.1fs"", e, wait)
                time.sleep(wait)
",alpha_factory_v1/demos/meta_agentic_agi/agents/agent_base.py,LMClient,1,2.998960815863541e-09,"The method 'chat' is likely to survive because it is a core function that handles communication with different AI backends (openai, anthropic, gemini, mistral, llama). It includes error handling and retry logic, which are essential for robust operation in production environments. The method is versatile, supporting multiple backends and allowing for additional keyword arguments, making it adaptable to future changes or expansions in backend services."
survived,"    def log():
        if not path.exists():
            return ""(no events yet)""
        return flask.escape(path.read_text(""utf-8""))
",alpha_factory_v1/demos/meta_agentic_agi_v3/agents/agent_base.py,,1,9.736200303530205e-10,"The method 'log' is a simple utility function that checks if a path exists and reads its content if it does. It uses 'flask.escape' to ensure the text is safe for HTML, which is a common practice in web applications to prevent XSS attacks. The method is straightforward, performs a useful function, and follows good security practices. There is no indication that it is obsolete or redundant, so it is likely to be retained."
survived,"def emit_notebook(fp:Path=Path(""alpha_asi_world_model_demo.ipynb"")):
    import nbformat as nbf
    nb=nbf.v4.new_notebook()
    nb.cells=[nbf.v4.new_markdown_cell(""# Œ±‚ÄëASI demo ‚Äì quickstart""), nbf.v4.new_code_cell(""!python -m alpha_asi_world_model_demo --demo &"")]
    nbf.write(nb,fp); print(""Notebook ‚Üí"",fp)
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo_v4.py,,1,1.2501528648238603e-09,"The method 'emit_notebook' is a utility function that creates a Jupyter notebook with a specific structure and writes it to a file. It uses the 'nbformat' library to create a new notebook and add a markdown cell and a code cell. This kind of utility function is useful for automating the creation of notebooks, which can be a common task in data science and educational contexts. The function is straightforward, does not have any apparent issues, and serves a clear purpose. Therefore, it is likely to be retained in the codebase."
survived,"    def __exit__(self, exc_type, exc, tb):
        if signal:
            resource.setrlimit(resource.RLIMIT_CPU, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))
        return False  # do not suppress
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,SafeExec,1,4.6911638017642294e-08,"The method is a custom implementation of the __exit__ method, which is part of the context management protocol in Python. It is used to define cleanup actions when exiting a context managed by a 'with' statement. The method checks if a 'signal' is present and then sets the CPU time limit to infinity using the 'resource' module. This is a specific use case that might be necessary for certain applications where CPU time limits need to be managed dynamically. The method returns False, indicating that exceptions should not be suppressed, which is a standard practice in context managers to allow exceptions to propagate. Given its specific functionality and adherence to context management protocol, it is likely to be useful in scenarios where resource limits need to be controlled, thus it is likely to survive."
survived,"    def __enter__(self):
        if resource:
            resource.setrlimit(resource.RLIMIT_CPU, (self.cpu_sec, self.cpu_sec))
            resource.setrlimit(resource.RLIMIT_AS, (self.mem_mb*1024*1024, self.mem_mb*1024*1024))
        return self
",alpha_factory_v1/demos/meta_agentic_agi_v3/agents/agent_base.py,SafeExec,1,5.043472052266442e-07,"The method is part of a context manager implementation, indicated by the presence of the __enter__ method. Context managers are a common and useful pattern in Python for resource management, ensuring that resources are properly acquired and released. The method sets resource limits for CPU and memory, which is a valid and useful operation in many applications to prevent excessive resource usage. Therefore, it is likely to be retained as it serves a specific and useful purpose."
survived,"def serve_lineage(path: pathlib.Path, port: int=8000):
    import flask, threading
    app = flask.Flask(""lineage-viewer"")

    @app.route(""/"")
    def idx():
        return VIEW_HTML

    @app.route(""/log"")
    def log():
        if not path.exists():
            return ""(no events yet)""
        return flask.escape(path.read_text(""utf-8""))

    th = threading.Thread(target=app.run, kwargs=dict(port=port, host=""0.0.0.0"", debug=False))
    th.daemon = True
    th.start()
    LOGGER.info(""Lineage viewer at http://localhost:%d"", port)
    return th
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,,1,1.8189616842444243e-09,"The method 'serve_lineage' is a utility function that sets up a simple Flask web server to serve log files from a specified path. It is useful for developers or users who need to quickly view logs in a web browser. The function is straightforward, uses common libraries, and serves a clear purpose. There is no indication of deprecated libraries or practices, and it provides a useful feature for debugging or monitoring purposes. Therefore, it is likely to be retained in the codebase."
survived,"    def _parse(self, ep: str):
        if "":"" not in ep:
            raise ValueError(""Endpoint must be <backend>:<model>"")
        return ep.split("":"",1)
",alpha_factory_v1/demos/meta_agentic_agi_v3/agents/agent_base.py,LMClient,1,6.69158608681505e-10,"The method _parse is a utility function that checks if a string contains a colon and splits it into two parts. This is a common pattern for parsing configuration strings or identifiers in software systems. The method is simple, performs a specific task, and raises an appropriate error if the input does not meet the expected format. Such utility functions are often retained as they encapsulate a specific piece of logic that might be reused in different parts of the codebase. Therefore, it is likely to be Survived."
survived,"    def run(self, code: str, func_name: str, *args, **kw):
        loc: Dict[str,Any] = {}
        with self:
            exec(code, {}, loc)
        if func_name not in loc:
            raise AttributeError(f""{func_name} not found"")
        return loc[func_name](*args, **kw)
",alpha_factory_v1/demos/meta_agentic_agi/agents/agent_base.py,SafeExec,1,1.7603431343301488e-06,"The method 'run' is a dynamic code execution utility that allows executing arbitrary code and calling a function from it. This is a powerful feature often used in environments where code needs to be executed dynamically, such as in scripting engines or plugin systems. However, it poses significant security risks, as executing arbitrary code can lead to vulnerabilities if not properly sandboxed or validated. Despite these risks, such methods are often retained in systems that require high flexibility and are used with caution. Therefore, the method is likely to survive due to its utility in specific contexts, provided it is used with appropriate security measures."
survived,"def _sha(text: str) -> str:
    return hashlib.sha256(text.encode()).hexdigest()[:10]
",alpha_factory_v1/demos/meta_agentic_agi_v2/agents/agent_base.py,,1,9.237449576640118e-09,"The method '_sha' is a utility function that generates a SHA-256 hash of a given text and returns the first 10 characters of the hash. Such utility functions are often useful in various applications for creating unique identifiers or checksums. The method is concise, performs a specific task, and is likely to be reused in different parts of a codebase. Therefore, it is more likely to be retained rather than deleted."
survived,"    def read_csv_file(file_path: str) -> pd.DataFrame:
        """"""Read a CSV file into a pandas DataFrame.""""""
        return pd.read_csv(file_path)
",datamax/parser/csv_parser.py,CsvParser,1,8.592166611791576e-10,"The method 'read_csv_file' is a simple utility function that reads a CSV file into a pandas DataFrame. This is a common and useful operation in data processing and analysis tasks. The function is straightforward, uses a well-known library (pandas), and performs a task that is frequently needed in data-related projects. Therefore, it is likely to be retained in the codebase."
survived,"def test_send_beacon_opt_in() -> None:
    dist = Path(__file__).resolve().parents[1] / ""dist"" / ""index.html""
    url = dist.as_uri()

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.goto(url)
        page.evaluate(
            ""window.OTEL_ENDPOINT='https://example.com';""
            ""window.confirm=() => true;""
            ""navigator.sendBeacon=(...a)=>{window.beacon=a;return true;}""
        )
        page.reload()
        page.wait_for_selector(""#controls"")
        page.click(""text=Share"")
        page.evaluate(""window.dispatchEvent(new Event('beforeunload'))"")
        assert page.evaluate(""Array.isArray(window.beacon)"")
        browser.close()",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_telemetry.py,,1,3.3982678079468468e-09,"The method `test_send_beacon_opt_in` is a test function that uses Playwright to automate a browser and test the functionality of a web page. It sets up a mock environment to test the `sendBeacon` API, ensuring that the beacon is sent correctly when a certain action is performed on the page. This kind of test is crucial for verifying the behavior of web applications, especially when dealing with analytics or telemetry data. Given the importance of testing in software development and the specific use case of this test, it is likely to be maintained as part of the test suite."
survived,"def list_ids(command: ListIdsCommand) -> List[str]:
    """"""List all item IDs in the database, optionally filtered by tags.""""""
    normalized_tags = normalize_tags(command.tags) if command.tags else []

    db = init_db(command.db_path)

    try:
        if normalized_tags:
            placeholders = ', '.join(['?'] * len(normalized_tags))
            query = f""""""
                SELECT id
                FROM POCKET_PICK
                WHERE id IN (
                    SELECT id
                    FROM POCKET_PICK
                    WHERE (
                        SELECT COUNT(*)
                        FROM json_each(tags)
                        WHERE json_each.value IN ({placeholders})
                    ) = ?
                )
                ORDER BY created DESC
                LIMIT ?
            """"""
            params = [*normalized_tags, len(normalized_tags), command.limit]
        else:
            query = """"""
                SELECT id
                FROM POCKET_PICK
                ORDER BY created DESC
                LIMIT ?
            """"""
            params = [command.limit]

        cursor = db.execute(query, params)
        results = [row[0] for row in cursor.fetchall()]
        return results
    except Exception as e:
        logger.error(f""Error listing ids: {e}"")
        raise
    finally:
        db.close()",src/mcp_server_pocket_pick/modules/functionality/list_ids.py,,1,2.5109990926928157e-08,"The method 'list_ids' is well-structured and serves a clear purpose of retrieving item IDs from a database, optionally filtered by tags. It handles database initialization, query execution, and error logging effectively. The use of parameterized queries helps prevent SQL injection, and the method includes error handling and resource cleanup in the 'finally' block. These are all good practices in software development, making it unlikely for the method to be deleted."
survived,"def test_list_ids_all(populated_db):
    command = ListIdsCommand(
        limit=10,
        db_path=populated_db,
    )

    results = list_ids(command)

    assert len(results) == 5
    for expected in [
        ""python-1"",
        ""sql-1"",
        ""testing-1"",
        ""regex-1"",
        ""learning-1"",
    ]:
        assert expected in results
",src/mcp_server_pocket_pick/tests/functionality/test_list_ids.py,,1,8.592166611791576e-10,"The method 'test_list_ids_all' is a unit test function that verifies the behavior of the 'list_ids' function. It checks if the 'list_ids' function returns a list of IDs that match the expected values. This is a typical and necessary part of software development to ensure code reliability and correctness. Since testing is a crucial aspect of maintaining code quality, this method is likely to be retained as part of the test suite to ensure that the 'list_ids' function works as intended. Therefore, it will survive."
survived,"def handle_heartbeat(runners: Dict[str, AgentRunner], env: object) -> None:
    """"""Update the heartbeat timestamp for ``env.sender`` if it exists.""""""
    payload = getattr(env, ""payload"", None)
    if payload and getattr(payload, ""get"", lambda *_: None)(""heartbeat""):
        sender = getattr(env, ""sender"", None)
        if sender in runners:
            r = runners[sender]
            r.last_beat = getattr(env, ""ts"", time.time())
            r.restart_streak = 0
",alpha_factory_v1/backend/orchestrator_utils.py,,1,1.6052280526088547e-09,"The method 'handle_heartbeat' is likely to survive because it performs a specific and useful function: updating the heartbeat timestamp for a given sender if it exists in the runners dictionary. This is a common pattern in systems that need to track the activity or status of agents or services, ensuring they are still active and responsive. The method is concise, checks for necessary conditions, and updates relevant attributes, which are typical requirements for maintaining system health and monitoring."
survived,"def test_rejects_low_entropy_patch() -> None:
    diff = _read(""red_team.diff"")
    assert not is_patch_safe(diff)",tests/test_patch_entropy.py,,1,2.998960815863541e-09,"The method `test_rejects_low_entropy_patch` is a unit test function that checks if a patch with low entropy is correctly identified as unsafe by the `is_patch_safe` function. Unit tests are crucial for ensuring code reliability and correctness, especially in security-related contexts like patch safety. Therefore, this method is likely to be retained as it contributes to the robustness of the codebase by verifying that the system behaves as expected when encountering low entropy patches."
survived,"def _load_insider_patterns() -> list[str]:
    policy_path = _POLICY_DIR / ""deny_insider.rego""
    try:
        text = policy_path.read_text(encoding=""utf-8"")
    except FileNotFoundError:
        return []
    return re.findall(r're_match\(""([^""]+)"",\s*input.text\)', text)
",src/utils/opa_policy.py,,1,1.493094675974231e-10,"The method _load_insider_patterns is likely to survive because it performs a specific and useful function: it reads a policy file and extracts patterns using regular expressions. This functionality is essential for applications that need to dynamically load and apply security policies or rules. The method handles exceptions gracefully by returning an empty list if the file is not found, which is a good practice. Additionally, the use of type hints improves code readability and maintainability. There is no indication of redundancy or inefficiency that would warrant deletion."
survived,"    def test_create_venv_runs_commands_when_missing(self):
        with mock.patch('subprocess.check_call') as cc:
            venv = Path('/tmp/qsvenv')
            if venv.exists():
                import shutil
                shutil.rmtree(venv)
            quickstart._create_venv(venv)
            pip = quickstart._venv_pip(venv)
            req = Path('alpha_factory_v1/requirements.lock')
            if not req.exists():
                req = Path('alpha_factory_v1/requirements.txt')
            self.assertEqual(cc.call_args_list[0].args[0][:3], [sys.executable, '-m', 'venv'])
            self.assertIn(str(venv), cc.call_args_list[0].args[0])
            called = [call.args[0] for call in cc.call_args_list]
            self.assertIn([str(pip), 'install', '-U', 'pip'], called)
            self.assertIn([str(pip), 'install', '-r', str(req)], called)
",alpha_factory_v1/tests/test_quickstart.py,QuickstartUtilsTest,1,3.3982678079468468e-09,"The method is a unit test that verifies the behavior of a function responsible for creating a virtual environment and installing dependencies. It uses mocking to simulate subprocess calls, ensuring that the correct commands are executed. This is a common and necessary test to ensure the functionality of the virtual environment setup process, especially in a development or CI/CD pipeline context. Therefore, it is likely to be retained as it provides value in maintaining code quality and reliability."
survived,"def play_episode(agent: MiniMu, render: bool = True, max_steps: int = 500) -> Tuple[List, float]:
    """"""Run a full episode using the agent.""""""
    obs = agent.reset()
    frames: List = []
    total_reward = 0.0
    done = False
    truncated = False
    while not done and not truncated and len(frames) < max_steps:
        if render:
            frames.append(agent.env.render())
        action = agent.act(obs)
        obs, reward, done, truncated, _ = agent.env.step(action)
        total_reward += float(reward)
    if render:
        frames.append(agent.env.render())
    agent.env.close()
    return frames, total_reward
",alpha_factory_v1/demos/muzero_planning/minimuzero.py,,1,1.0261879630648829e-10,"The method 'play_episode' is a well-defined function that serves a clear purpose: running a full episode using a given agent. It includes parameters for rendering, maximum steps, and returns both the frames and total reward, which are useful for evaluating the agent's performance. The method is likely to be used in reinforcement learning scenarios where observing the agent's behavior and performance is crucial. Additionally, the method is flexible with its rendering option and handles episode termination conditions effectively. These factors make it a valuable utility in its context, suggesting it will be Survived."
survived,"    def test_queue_job(self):
        self.server, self.thread = _start_server()
        host, port = self.server.server_address
        client = MarketplaceClient(host, port)
        job = {""agent"": ""foo""}
        resp = client.queue_job(job)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(_Handler.received_path, ""/agent/foo/trigger"")
        self.assertEqual(json.loads(_Handler.received_body.decode()), job)
",alpha_factory_v1/tests/test_marketplace_client.py,MarketplaceClientTest,1,1.9171715133907573e-10,"The method `test_queue_job` is a unit test designed to verify the functionality of queuing a job in a server-client setup. It checks if the job is correctly queued by asserting the response status code and the received path and body. Unit tests are crucial for ensuring code reliability and are typically maintained as long as the functionality they test is relevant. Therefore, this method is likely to be Survived (1) as it serves an important role in testing the system's behavior."
survived,"    def test_parse_args_defaults(self):
        args = parse_args([])
        sample = Path(
            ""alpha_factory_v1/demos/alpha_agi_marketplace_v1/examples/sample_job.json""
        ).resolve()
        self.assertEqual(Path(args.job_file), sample)
        self.assertEqual(args.host, ""localhost"")
        self.assertEqual(args.port, 8000)
",alpha_factory_v1/tests/test_marketplace_client.py,MarketplaceClientTest,1,3.2241866333029355e-08,"The method 'test_parse_args_defaults' is a unit test designed to verify the default behavior of the 'parse_args' function. Unit tests are crucial for ensuring code reliability and are typically retained in the codebase to facilitate ongoing testing and validation. This method checks if the default arguments are correctly set, which is a fundamental aspect of testing argument parsing functionality. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality."
survived,"def load_job(path: str | Path) -> dict[str, Any]:
    """"""Load a job description from a JSON file.""""""
    return json.loads(Path(path).read_text())
",alpha_factory_v1/demos/alpha_agi_marketplace_v1/marketplace.py,,1,9.736200303530205e-10,"The method 'load_job' is a simple utility function that loads a JSON file and returns its contents as a dictionary. This is a common and useful operation in many applications, especially those dealing with configuration files or data interchange. The function is concise, uses type hints, and leverages Python's standard library effectively. There is no indication of redundancy or obsolescence in the code, and it follows good practices. Therefore, it is likely to be retained in the codebase."
survived,"    def tearDown(self):
        if hasattr(self, ""server""):
            self.server.shutdown()
            self.thread.join()
            self.server.server_close()
",alpha_factory_v1/tests/test_marketplace_client.py,MarketplaceClientTest,1,6.825604231969389e-08,"The method `tearDown` is a common method used in unit testing frameworks like `unittest` in Python. It is typically used to clean up resources after a test case has been executed. The presence of `tearDown` suggests that this method is part of a test suite, and the operations it performs (shutting down a server, joining a thread, and closing the server) are crucial for ensuring that tests do not interfere with each other and that resources are properly released. Therefore, it is unlikely to be deleted as it serves an important purpose in maintaining the integrity and reliability of the test suite."
survived,"    def test_rest_endpoints(self):
        if not dependencies_available or TestClient is None:
            self.skipTest(""fastapi or dependencies missing"")
        with TestClient(demo.app) as client:
            res = client.get(""/agents"")
            self.assertEqual(res.status_code, 200)
            self.assertIsInstance(res.json(), list)
            self.assertGreaterEqual(len(res.json()), 5)
            client.post(""/command"", json={""cmd"": ""stop""})
",alpha_factory_v1/tests/test_alpha_asi_world_model.py,TestAlphaASIWorldModel,1,1.0467401685178159e-08,"The method 'test_rest_endpoints' is a unit test designed to verify the functionality of REST API endpoints. It checks if the necessary dependencies are available and uses a test client to make requests to the endpoints, asserting the expected responses. This is a common practice in software development to ensure that API endpoints behave as expected. Given the importance of testing in maintaining code quality and the fact that this method is actively checking the functionality of endpoints, it is likely to be retained in the codebase."
survived,"    def __init__(self):
        self.messages = []
",alpha_factory_v1/tests/test_ping_agent.py,DummyOrchestrator,1,2.1024340680345882e-07,"The method is a constructor for a class, initializing an instance variable 'messages' as an empty list. This is a common and necessary practice in object-oriented programming to set up initial state for objects. Such methods are fundamental to class design and are unlikely to be deleted unless the class itself is being removed or significantly refactored."
survived,"    def test_main_success_and_failure(self):
        with mock.patch.multiple(
            preflight,
            check_python=lambda: True,
            check_cmd=lambda cmd: True,
            check_docker_daemon=lambda: True,
            check_docker_compose=lambda: True,
            check_pkg=lambda pkg: True,
            ensure_dir=lambda p: None,
            banner=lambda *a, **k: None,
        ):
            preflight.main()
        with mock.patch.multiple(
            preflight,
            check_python=lambda: False,
            check_cmd=lambda cmd: False,
            check_docker_daemon=lambda: False,
            check_docker_compose=lambda: False,
            check_pkg=lambda pkg: False,
            ensure_dir=lambda p: None,
            banner=lambda *a, **k: None,
        ):
            with self.assertRaises(SystemExit):
                preflight.main()
",alpha_factory_v1/tests/test_preflight.py,PreflightTest,1,4.1399375473943306e-08,"The method 'test_main_success_and_failure' is a unit test designed to test the 'preflight.main()' function under two scenarios: when all checks pass and when all checks fail. This is a typical pattern in unit testing to ensure that the function behaves correctly in both success and failure cases. The method uses mocking to simulate different conditions, which is a common practice in testing to isolate the function being tested from its dependencies. Since this method is a well-structured test case, it is likely to be retained in the codebase to ensure the reliability of the 'preflight.main()' function."
survived,"    def test_alpha_factory_chart(self):
        chart = HELM_DIR / ""alpha-factory"" / ""Chart.yaml""
        values = HELM_DIR / ""alpha-factory"" / ""values.yaml""
        self.check_chart_file(chart)
        self.assertTrue(values.is_file(), ""values.yaml missing for alpha-factory"")
",alpha_factory_v1/tests/test_helm_charts.py,HelmChartTests,1,5.905303995456778e-10,"The method `test_alpha_factory_chart` is a unit test that checks the existence of specific files related to a Helm chart. It verifies the presence of 'Chart.yaml' and 'values.yaml' files in the 'alpha-factory' directory. This is a basic but essential test to ensure that the necessary files for deploying a Helm chart are present. Such tests are crucial for maintaining the integrity of deployment configurations and are unlikely to be deleted unless the project structure changes significantly or the testing strategy is overhauled. Therefore, the method is likely to survive."
survived,"    def test_vector_ram_mode(self):
        self.assertEqual(self.fabric.vector._mode, ""ram"")
        self.fabric.add_memory(""X"", ""data"")
        self.assertEqual(self.fabric.search(""data""), [])
",alpha_factory_v1/tests/test_memory_provider.py,MemoryFabricFallbackTest,1,6.475946147757848e-07,"The method `test_vector_ram_mode` is a unit test that checks the behavior of a system when operating in 'ram' mode. It verifies that initially, the mode is set to 'ram', and after adding memory, a search for the added data returns an empty list. This suggests that the test is checking for a specific behavior or bug, possibly ensuring that data is not retrievable immediately after being added, which might be a feature or a bug being tested. The method is likely to be retained as it serves a purpose in validating the system's behavior, which is crucial for maintaining code quality and reliability."
survived,"def test_replay_outputs_rows(tmp_path) -> None:
    path = tmp_path / ""log.db""
    path.touch()
    with patch.object(cli.config.CFG, ""ledger_path"", path):
        with patch.object(cli.logging, ""Ledger"") as led_cls, patch.object(cli.time, ""sleep"", return_value=None):
            led = led_cls.return_value
            led.tail.return_value = [SAMPLE_LEDGER_ROW]
            res = CliRunner().invoke(cli.main, [""replay""])
    assert ""a -> b"" in res.output",tests/test_cli_runner_ext.py,,1,7.73442280641062e-08,"The method `test_replay_outputs_rows` is a unit test function that is designed to test the functionality of a command-line interface (CLI) command. It uses the `pytest` framework's `tmp_path` fixture to create a temporary file path for testing, and it employs the `unittest.mock.patch` method to mock certain objects and methods. The test checks if the output of the CLI command contains a specific string, indicating that the command is functioning as expected. This is a typical pattern for writing tests in Python, and there is no indication that this method is obsolete or redundant. Therefore, it is likely to be retained in the codebase."
survived,"def main(argv=None) -> None:
    parser = argparse.ArgumentParser(prog=""sprc"")
    subparsers = parser.add_subparsers(dest=""command"")

    download_parser = subparsers.add_parser(""download"")
    download_subparsers = download_parser.add_subparsers(dest=""target"")

    vosk_parser = download_subparsers.add_parser(""vosk"")
    vosk_parser.add_argument(
        ""--url"",
        default=""https://alphacephei.com/vosk/models/vosk-model-small-en-us-0.15.zip"",
    )
    vosk_parser.add_argument(""--dir"", default=""model"")

    def _download_vosk(args):
        download_vosk_model(args.url, args.dir)

    vosk_parser.set_defaults(func=_download_vosk)

    args = parser.parse_args(argv)
    if hasattr(args, ""func""):
        args.func(args)
    else:
        parser.print_help()
",speech_recognition/cli.py,,1,4.599055376537186e-10,"The method 'main' is a well-structured entry point for a command-line interface (CLI) application. It uses argparse to handle command-line arguments and subcommands, which is a common and effective way to manage CLI inputs. The method is functional, clear, and follows best practices for CLI applications. There is no indication of deprecated practices or inefficiencies that would warrant its removal. Therefore, it is likely to be retained in the codebase."
survived,"def wb_run_step_validator(s: Optional[int]) -> Optional[int]:
    if s is None:
        return None
    if not isinstance(s, int):
        raise TypeError(""wb_run_step must be an int"")
    if s < 0:
        raise ValueError(""wb_run_step must be non-negative"")
    return s
",weave/trace_server/validation.py,,1,1.9171715133907573e-10,"The method wb_run_step_validator is a utility function that validates an input parameter 's'. It checks if 's' is None, if it is an integer, and if it is non-negative. These are common validation checks that are useful in many applications to ensure data integrity and prevent errors. The function is well-defined, handles edge cases, and raises appropriate exceptions when the input is invalid. Such utility functions are often retained in codebases because they encapsulate common validation logic that can be reused across different parts of an application. Therefore, it is likely to be Survived."
survived,"def shuffle(xs):
    arr = xs
    i = len(arr) - 1
    while i > 0:
        j = _now() % (i + 1)
        tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        i = i - 1
    return arr
",tests/rosetta/transpiler/Python/concurrent-computing-3.py,,0,0.9999999006880476,"The method is likely to be deleted because it uses a non-standard and potentially insecure way to shuffle a list. The use of '_now()' for generating random indices is not a reliable method for shuffling, as it depends on the current time, which can lead to predictable patterns. A more standard and secure approach would be to use Python's built-in 'random.shuffle()' method, which is specifically designed for this purpose and uses a robust random number generator."
survived,"def someCondition():
    return False",tests/rosetta/transpiler/Python/conditional-structures-7.py,,0,0.9999999317439577,"The method 'someCondition' is a simple function that always returns False. It doesn't take any parameters or perform any operations other than returning a constant value. Such methods are often considered redundant unless they are placeholders for future logic or used as part of a larger framework where the constant return value is significant. Without additional context indicating its necessity, it's likely to be deleted as it doesn't contribute any meaningful functionality."
survived,"def example9():
    while True:
        if True:
            break
        print(""I want out!"")",tests/rosetta/transpiler/Python/conditional-structures-9.py,,0,0.9999980052698925,"The method 'example9' contains a while loop that will always break immediately due to the 'if True' condition, making the loop and the print statement inside it unreachable. This renders the method effectively useless as it performs no meaningful operation. Such code is typically considered for deletion during code maintenance or refactoring processes because it does not contribute to the functionality of the program and can be seen as dead code."
survived,"def example1(flag):
    if flag:
        None",tests/rosetta/transpiler/Python/conditional-structures-1.py,,0,0.9999999936511998,"The method 'example1' is likely to be deleted because it does not perform any meaningful operation. The function takes a parameter 'flag' and checks its truthiness, but regardless of the condition, it only executes 'None', which has no effect. This makes the function redundant and unnecessary in any codebase."
survived,"def fetch_():
    return """"
",tests/rosetta/transpiler/Python/conditional-structures-7.py,,0,0.9999999006880476,"The method 'fetch_' is a placeholder function that returns an empty string. It does not perform any meaningful operation or provide any functionality. Without additional context or usage, it is likely to be considered unnecessary and removed in a production environment."
survived,"def lifeString(l):
    out = """"
    y = 0
    while y < l.h:
        x = 0
        while x < l.w:
            if state(l.a, x, y):
                out = out + ""*""
            else:
                out = out + "" ""
            x = x + 1
        out = out + ""\n""
        y = y + 1
    return out
",tests/rosetta/transpiler/Python/conways-game-of-life.py,,1,9.237449576640118e-09,"The method 'lifeString' is a utility function that generates a string representation of a 2D grid, where each cell is represented by either '*' or ' ' based on the state of the cell. This type of function is commonly used in simulations or visualizations, such as Conway's Game of Life, to display the current state of the grid. The method is straightforward, performs a clear task, and is likely to be useful in contexts where a visual representation of a grid is needed. Therefore, it is likely to be retained in the codebase."
survived,"def test_ws_progress_receives_updates() -> None:
    """"""A POST to /simulate should emit progress events over the WebSocket.""""""
    from alpha_factory_v1.demos.alpha_agi_insight_v1.src.interface import api_server

    client = TestClient(api_server.app)
    headers = {""Authorization"": ""Bearer test-token""}

    with client.websocket_connect(""/ws/progress"", headers=headers) as ws:
        resp = client.post(
            ""/simulate"",
            json={""horizon"": 1, ""pop_size"": 2, ""generations"": 1, ""k"": 5.0, ""x0"": 0.0},
            headers=headers,
        )
        assert resp.status_code == 200
        sim_id = resp.json()[""id""]

        data = ws.receive_json()
        assert data[""id""] == sim_id
        assert data[""year""] == 1
        assert isinstance(data[""capability""], float)
",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_api_ws_progress.py,,1,3.2241866333029355e-08,The method 'test_ws_progress_receives_updates' is a test function that verifies the functionality of a WebSocket connection in a web application. It checks if progress events are emitted correctly when a POST request is made to the '/simulate' endpoint. This is a crucial part of ensuring the reliability and correctness of the application's real-time features. Test functions like this are essential for maintaining software quality and are unlikely to be deleted unless the feature they test is removed or significantly changed.
survived,"    def __init__(
        self,
        config: SanskritPoetryEnvConfig,
        server_configs: List[APIServerConfig],
        slurm: bool = True,
        testing: bool = False,
    ):
        super().__init__(config, server_configs, slurm, testing)
        # Create reward function using registry for easy configuration
        self.reward_fn = registry.create(
            {""type"": ""chandas_meter"", ""params"": {""meter"": config.meter}}
        )
        self.iter = 0
",environments/sanskrit_poetry_env.py,SanskritPoetryEnv,1,1.8553915987649156e-07,"The method is a constructor (__init__) for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects and setting up initial states. This particular constructor is setting up configurations and creating a reward function, which are likely crucial for the functionality of the class. Therefore, it is unlikely to be deleted unless the entire class is being refactored or removed."
survived,"    async def score(self, rollout_group_data: List) -> Optional[ScoredDataGroup]:
        scored = ScoredDataGroup()
        scored[""tokens""] = []
        scored[""masks""] = []
        scored[""scores""] = []
        for traj in rollout_group_data:
            reward = self.reward_fn([traj[-1][""content""]])[0]
            out_dict = tokenize_for_trainer(self.tokenizer, traj)
            scored[""tokens""].append(out_dict[""tokens""])
            scored[""masks""].append(out_dict[""masks""])
            scored[""scores""].append(reward)
        return scored
",environments/sanskrit_poetry_env.py,SanskritPoetryEnv,1,1.4166087846364157e-09,"The method 'score' is likely to survive because it appears to be a functional and coherent piece of code that performs a specific task: scoring a group of data based on a reward function and tokenizing the data for a trainer. The method is structured logically, with a clear input and output, and it uses asynchronous programming, which is often necessary for handling I/O-bound operations efficiently. Additionally, the method uses a tokenizer and a reward function, suggesting it is part of a larger system, likely related to machine learning or data processing, where such functionality is essential."
survived,"def iast_to_slp1(text: str) -> str:
    """"""Convert a string from IAST to SLP1.""""""
    def _replace(match: re.Match) -> str:
        for iast, slp in _IAST_TO_SLP1:
            if match.group(0) == iast:
                return slp
        return match.group(0)

    text = _DIGRAPH_RE.sub(_replace, text)
    return """".join(_SINGLE_CHAR_MAP.get(ch, ch) for ch in text)
",atroposlib/envs/reward_fns/chandas_meter_reward.py,,1,1.6918979223288786e-10,"The method `iast_to_slp1` is a utility function that converts a string from the International Alphabet of Sanskrit Transliteration (IAST) to the Sanskrit Library Phonetic (SLP1) scheme. This type of function is useful in linguistic processing, especially for applications dealing with Sanskrit texts. The function is well-defined, uses regular expressions for pattern matching, and handles character mapping efficiently. Such functions are typically retained in codebases that deal with text processing or language conversion tasks. Therefore, it is likely to survive."
survived,"    async def arecord(self, agent_name: str, phase: str, payload: Any) -> None:
        """"""Async wrapper around :meth:`record`.""""""
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, self.record, agent_name, phase, payload)
",alpha_factory_v1/backend/tracer.py,Tracer,1,8.152020648014727e-09,"The method 'arecord' is an asynchronous wrapper around a synchronous method 'record'. This pattern is useful for running blocking I/O operations in a non-blocking way, which is a common requirement in asynchronous programming. The use of 'asyncio.get_running_loop().run_in_executor()' is a standard approach to offload blocking operations to a separate thread, allowing the event loop to remain responsive. Given the increasing adoption of asynchronous programming in Python, this method is likely to be useful and relevant, especially in applications that require non-blocking I/O operations. Therefore, it is likely to be retained."
survived,"def Tool(*_args, **_kwargs):
    def decorator(func):
        return func

    return decorator",stubs/openai_agents/__init__.py,,1,4.222835268240621e-06,"The method 'Tool' is a decorator factory that returns a decorator function. This decorator function, when applied to another function, simply returns the function itself without any modification. This pattern is often used as a placeholder or a base for more complex decorators that might be developed in the future. Since it doesn't perform any operations, it might seem redundant, but it provides a structure for future enhancements. Therefore, it is likely to survive as it can be useful for extending functionality later."
survived,"    def decorator(func):
        return func
",stubs/openai_agents/__init__.py,,0,0.9999417087232136,"The method 'decorator' is a simple function that takes another function as an argument and returns it without any modification. This is a basic implementation of a decorator pattern, but it doesn't add any additional functionality or modify the behavior of the function it decorates. While it is syntactically correct, it doesn't serve any practical purpose in its current form. However, it is a valid starting point for creating more complex decorators. Without additional context on its usage or plans for extension, it is likely to be deleted as it doesn't provide any added value."
survived,"    def __init__(self, *a, **k):
        pass
",tests/test_selfheal_entrypoint_offline.py,DummyButton,0,0.9999957771647318,"The method is a constructor (__init__) that takes any number of positional and keyword arguments but does nothing with them. This is often used as a placeholder or when subclassing to ensure compatibility with a superclass constructor. However, if the class is intended to be used in a meaningful way, this constructor would likely need to be expanded to initialize instance variables or perform setup tasks. Without additional context, it's difficult to determine its necessity, but as it stands, it doesn't contribute any functionality. Therefore, it is likely to be deleted or replaced with a more functional constructor."
survived,"    def click(self, *a, **k):
        pass
",tests/test_selfheal_entrypoint_offline.py,DummyButton,0,0.9982992777753472,"The method 'click' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it is a placeholder for future functionality. If the method is part of a larger class or module that is actively being developed, it might be retained for future use. However, if there is no plan to implement it or if it has been in this state for a long time without any updates, it might be considered for deletion to clean up the codebase. Without additional context, it's difficult to determine the exact intention, but generally, such methods are often deleted if they remain unimplemented for extended periods."
survived,"def wealth_projection(scenario: str) -> None:
    """"""Print projected cash flows for SCENARIO JSON file.""""""
    result = projection_from_json(Path(scenario))
    click.echo(json.dumps(result, indent=2))
",alpha_factory_v1/scripts/wealth_projection.py,,1,1.1861120010657661e-08,"The method 'wealth_projection' is a simple utility function that reads a JSON file and prints its contents in a formatted manner. It is a straightforward function that serves a clear purpose, which is to display projected cash flows from a given scenario file. Such utility functions are often useful in scripts and applications for debugging, logging, or user interaction purposes. Unless there is a significant change in the requirements or the function is replaced by a more comprehensive solution, it is likely to survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/machine/x/python/cross_join.py,Auto1,0,0.9999869928752253,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/machine/x/python/right_join.py,Order,0,0.9999984465026855,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/machine/x/python/left_join_multi.py,Order,0,0.999997438718515,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/machine/x/python/right_join.py,Customer,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/machine/x/python/group_by_join.py,Customer,0,0.999998629043345,"The method is incorrectly implemented. The `__contains__` method is supposed to check for membership, typically in a collection or container, and return a boolean indicating whether the specified key or item is present. However, using `hasattr(self, key)` checks if the object has an attribute with the name `key`, which is not the intended use of `__contains__`. This method should be checking if `key` is in a collection attribute of the object, not if it's an attribute name itself. Therefore, this method is likely to be deleted or significantly modified to correctly implement membership checking."
survived,"        def _tool(*_a, **_kw):
            def _decorator(func):
                return func

            return _decorator
",tests/test_macro_adk_integration.py,,1,3.726639116582555e-06,"The method _tool is a decorator factory that returns a decorator (_decorator) which, in turn, returns the original function without any modification. This pattern is often used as a placeholder or a base for more complex decorators. Since it doesn't perform any operations or modifications, it might be considered redundant in its current form. However, it can be useful as a starting point for future development or as a placeholder in a codebase. Without additional context on its usage, it's likely to survive as it provides a flexible structure for future enhancements."
survived,"    def visit_Expr(self, node: ast.Expr) -> None:
        if (
            isinstance(node.value, ast.Call)
            and isinstance(node.value.func, ast.Name)
            and node.value.func.id == ""print""
        ):
            args = "", "".join(self.convert_expr(a) for a in node.value.args)
            self.emit(f""print({args})"")
        else:
            self.emit(self.convert_expr(node.value))
",tools/any2mochi/py/py2mochi.py,Converter,1,6.348800075736417e-09,"The method `visit_Expr` is a part of a visitor pattern implementation for traversing and transforming an abstract syntax tree (AST). It specifically handles expressions, checking if they are print calls and converting them accordingly. This is a common task in compilers or interpreters for languages that use Python-like syntax. The method is well-defined, serves a clear purpose, and is likely part of a larger system that processes or transforms code. Therefore, it is unlikely to be deleted unless the entire system is being deprecated or significantly refactored."
survived,"    def visit_Module(self, node: ast.Module) -> None:
        # first collect dataclass information
        for stmt in node.body:
            if isinstance(stmt, ast.ClassDef):
                dec_names = [
                    getattr(d, ""id"", None) or getattr(d, ""attr"", None)
                    for d in stmt.decorator_list
                ]
                if ""dataclass"" not in dec_names:
                    continue
                fields: list[tuple[str, str]] = []
                methods: list[ast.FunctionDef] = []
                for sub in stmt.body:
                    if isinstance(sub, ast.AnnAssign) and isinstance(
                        sub.target, ast.Name
                    ):
                        fields.append(
                            (sub.target.id, self.convert_type(sub.annotation))
                        )
                    if isinstance(sub, ast.FunctionDef):
                        methods.append(sub)
                base = stmt.bases[0].id if stmt.bases else None
                self.dataclasses.add(stmt.name)
                if base:
                    self.unions.setdefault(base, []).append((stmt.name, fields))
                else:
                    self.structs[stmt.name] = (fields, methods)

        # emit structs
        for name, (fields, methods) in self.structs.items():
            self.emit(f""type {name} {{"")
            self.indent += 1
            for n, t in fields:
                self.emit(f""{n}: {t}"")
            for m in methods:
                args = [
                    f""{a.arg}: {self.convert_type(a.annotation)}"" for a in m.args.args[1:]
                ]
                ret = self.convert_type(m.returns)
                self.emit(f""fun {m.name}({', '.join(args)}): {ret} {{"")
                self.indent += 1
                for st in m.body:
                    self.visit(st)
                self.indent -= 1
                self.emit(""}"")
            self.indent -= 1
            self.emit(""}"")

        # emit unions
        for base, variants in self.unions.items():
            self.emit(f""type {base} ="")
            self.indent += 1
            for i, (name, fields) in enumerate(variants):
                field_str = "", "".join(f""{n}: {t}"" for n, t in fields)
                if field_str:
                    self.emit(
                        f""{name}({field_str})"" + ("" |"" if i < len(variants) - 1 else """")
                    )
                else:
                    self.emit(f""{name} {{}}"" + ("" |"" if i < len(variants) - 1 else """"))
            self.indent -= 1

        # now handle remaining statements
        for stmt in node.body:
            if (
                isinstance(stmt, ast.If)
                and isinstance(stmt.test, ast.Compare)
                and isinstance(stmt.test.left, ast.Name)
                and stmt.test.left.id == ""__name__""
            ):
                continue
            if isinstance(stmt, ast.FunctionDef) and stmt.name in {""_get"", ""_fetch"", ""_sort_key"", ""_load"", ""_save""}:
                continue
            if isinstance(stmt, ast.FunctionDef) and stmt.name == ""main"":
                for sub in stmt.body:
                    if isinstance(sub, ast.Global):
                        continue
                    if (
                        isinstance(sub, ast.Expr)
                        and isinstance(sub.value, ast.Call)
                        and isinstance(sub.value.func, ast.Name)
                        and sub.value.func.id.startswith(""test_"")
                    ):
                        continue
                    self.visit(sub)
                continue
            if isinstance(stmt, ast.FunctionDef):
                self.visit(stmt)
                continue
            if isinstance(stmt, ast.ClassDef):
                continue
            if isinstance(stmt, ast.Assign):
                self.visit(stmt)
",tools/any2mochi/py/py2mochi.py,Converter,1,1.0467401685178159e-08,"The method `visit_Module` is a core part of a visitor pattern implementation for traversing and processing an abstract syntax tree (AST). It handles the collection of dataclass information, emits structures and unions, and processes remaining statements. This functionality is essential for the purpose of the code, which appears to be related to code generation or transformation based on ASTs. Such methods are typically central to the functionality of the system they are part of, making it unlikely to be removed unless the entire system is deprecated or significantly refactored."
survived,"    def visit_Assert(self, node: ast.Assert) -> None:
        expr = self.convert_expr(node.test)
        self.emit(f""expect {expr}"")
",tools/any2mochi/py/py2mochi.py,Converter,1,4.944450477491054e-09,"The method `visit_Assert` is a part of a visitor pattern for traversing and transforming an abstract syntax tree (AST). The method is responsible for handling `assert` statements in the AST by converting the test expression and emitting a corresponding expectation statement. This functionality is essential for any tool or library that processes Python code, such as a transpiler, linter, or code analyzer. Therefore, it is likely to be retained as it serves a specific purpose in the context of AST manipulation."
survived,"    def visit_For(self, node: ast.For) -> None:
        target = self.convert_expr(node.target)
        iter_ = self.convert_expr(node.iter)
        self.emit(f""for {target} in {iter_} {{"")
        self.indent += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent -= 1
        self.emit(""}"")
",tools/any2mochi/py/py2mochi.py,Converter,1,2.7894680920908113e-10,"The method `visit_For` is a part of a visitor pattern implementation for traversing and transforming an abstract syntax tree (AST). This method specifically handles `for` loop nodes, converting them into a different format, likely for a custom language or a specific output format. Such methods are crucial in compilers, interpreters, or code analysis tools for transforming or analyzing code. Given its specific role in processing AST nodes, it is unlikely to be deleted unless the entire visitor pattern or the need to process `for` loops is removed, which is uncommon. Therefore, the method is likely to survive."
survived,"    def emit(self, line: str) -> None:
        self.lines.append(""  "" * self.indent + line)
",tools/any2mochi/py/py2mochi.py,Converter,1,1.9171715133907573e-10,"The method 'emit' is a simple utility function that appends a formatted string to a list. It is likely part of a larger class that deals with text processing or code generation. Such methods are generally useful for maintaining structured output and are unlikely to be removed unless the entire class or its functionality is deprecated. Therefore, it is more likely to survive."
survived,"        def clear_tool_stats_route() -> dict[str, str]:
            self._clear_tool_stats()
            return {""status"": ""cleared""}
",src/serena/dashboard.py,SerenaDashboardAPI,1,2.998960815863541e-09,"The method `clear_tool_stats_route` is a simple utility function that calls another method `_clear_tool_stats` and returns a dictionary indicating the status. This method is likely part of a larger system where clearing tool statistics is a necessary operation. The method is straightforward, performs a clear action, and provides feedback, which is a common pattern in API design. Unless the functionality of clearing tool stats is no longer needed, this method is likely to survive as it serves a clear purpose."
survived,"    def __enter__(self):
        return self
",tests/test_agent_experience_entrypoint.py,DummyBlocks,1,1.725782769012759e-08,"The method `__enter__` is part of the context management protocol in Python, which is used to set up a runtime context for the `with` statement. This method is essential for objects that are intended to be used with the `with` statement, as it allows the object to perform any setup actions and return the object itself or another value to be used within the `with` block. Given its importance in resource management and ensuring proper setup and teardown of resources, this method is likely to be retained in the code."
survived,"def test_main_ollama(monkeypatch: pytest.MonkeyPatch) -> None:
    base = _run_main(monkeypatch, openai_key="""", base_url=""http://ollama"")
    assert base == ""http://ollama""",tests/test_agent_experience_entrypoint.py,,1,1.1861120010657661e-08,"The method 'test_main_ollama' is a test function that uses the 'monkeypatch' fixture from pytest to modify the behavior of the '_run_main' function. It checks if the '_run_main' function returns the expected base URL when provided with specific arguments. This is a typical unit test pattern in Python, and there is no indication that it is obsolete or incorrect. Therefore, it is likely to be retained as part of the test suite to ensure the correct behavior of the '_run_main' function."
deleted,"    def validate_validation_dataset(cls, dataset_name: str | None) -> str | None:
        if dataset_name is None:
            return None
        try:
            url = f""https://huggingface.co/api/datasets/{dataset_name}/tree/main""
            response = requests.get(url, timeout=5)
            if response.status_code != 200:
                raise ValueError()
            return dataset_name
        except Exception:
            raise ValueError(
                f""Dataset {dataset_name} is not a valid, public Hugging Face dataset. Please check the URL and try again. Your dataset name should be in the format <username>/<dataset_name>"",
            )
",phosphobot/phosphobot/am/base.py,TrainingRequest,1,6.69158608681505e-10,"The method 'validate_validation_dataset' is likely to survive because it performs a useful function of validating whether a given dataset name corresponds to a valid, public dataset on Hugging Face. It handles both the case where the dataset name is None and where the dataset name is invalid, providing clear error messages. This functionality is important for ensuring that the dataset being used is accessible and correctly formatted, which is a common requirement in data processing and machine learning workflows."
survived,"        async def policy(self, obs, _ctx):  # type: ignore[override]
            params = obs if isinstance(obs, dict) else {}
            return await run_insight_search(
                episodes=int(params.get(""episodes"", 5)),
                target=int(params.get(""target"", 3)),
                model=params.get(""model""),
                rewriter=params.get(""rewriter""),
                sectors=params.get(""sectors""),
            )
",alpha_factory_v1/demos/alpha_agi_insight_v0/openai_agents_bridge.py,InsightAgent,1,3.3982678079468468e-09,The method 'policy' is an asynchronous function that processes an observation 'obs' and extracts parameters from it. It then calls another function 'run_insight_search' with these parameters. The method is likely to survive because it is a straightforward implementation of a policy function that is flexible in handling different types of input (dict or otherwise) and delegates the main task to another function. This modularity and clarity in handling parameters make it a useful and maintainable piece of code.
survived,"    def test_bridge_fallback(self) -> None:
        result = subprocess.run(
            [
                sys.executable,
                ""-m"",
                ""alpha_factory_v1.demos.alpha_agi_insight_v0.openai_agents_bridge"",
                ""--episodes"",
                ""1"",
                ""--target"",
                ""2"",
                ""--model"",
                DEFAULT_MODEL_NAME,
            ],
            capture_output=True,
            text=True,
        )
        self.assertEqual(result.returncode, 0, result.stderr)
        self.assertIn(""demo"", result.stdout.lower())
",tests/test_alpha_agi_insight_bridge.py,TestAlphaAgiInsightBridge,1,4.599055376537186e-10,"The method 'test_bridge_fallback' is a unit test designed to verify the functionality of a specific script or module. It uses subprocess to run a command and checks the output and return code to ensure the script behaves as expected. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, this method is likely to be retained as part of the test suite to ensure ongoing reliability of the codebase."
survived,"def test_call_summary_editable(client):
    @weave.op()
    def my_op():
        call = call_context.get_current_call()
        call.summary[""foo""] = 1
        call.summary[""bar""] = 2
        return ""done""

    my_op()
    calls = list(client.get_calls())
    assert len(calls) == 1
    summary = calls[0].summary
    assert summary[""foo""] == 1
    assert summary[""bar""] == 2
    assert summary[RESERVED_SUMMARY_STATUS_COUNTS_KEY][tsi.TraceStatus.SUCCESS] == 1",tests/trace/test_current_call.py,,1,1.8189616842444243e-09,"The method 'test_call_summary_editable' is a test function that verifies the functionality of a custom operation 'my_op'. It checks if the operation correctly updates a call's summary with specific key-value pairs and asserts the expected outcomes. Test functions like this are crucial for ensuring code reliability and are typically retained in the codebase to prevent regressions. Therefore, it is likely to survive."
survived,"    def drop_path(self):
        ''' Removes a document from a path starting from this node (leaf) upwards '''
        node = self
        while node is not None:
            node.customers -= 1
            if node.customers == 0 and node.parent is not None:
                node.parent.remove(node)
            node = node.parent
",src/hlda/sampler.py,NCRPNode,1,1.637377179507321e-07,"The method `drop_path` is a utility function that seems to be part of a tree-like data structure. It is responsible for decrementing a `customers` count from a node upwards to its parent nodes, and potentially removing nodes if their `customers` count reaches zero. This type of functionality is common in data structures that manage hierarchical relationships, such as file systems or organizational charts. The method is likely to be useful in scenarios where nodes need to be dynamically removed based on certain conditions, which is a common requirement in many applications. Therefore, it is likely to be retained as it provides essential functionality for managing the tree structure."
survived,"    def is_leaf(self):
        ''' Check if this node is a leaf node '''
        return self.level == self.num_levels-1
",src/hlda/sampler.py,NCRPNode,1,4.363462233903899e-09,"The method `is_leaf` is a simple utility function that checks if a node is a leaf node by comparing its level to the total number of levels minus one. This is a common operation in tree structures, such as decision trees or hierarchical data structures, where determining if a node is a leaf is essential for traversal, insertion, or deletion operations. The method is straightforward, efficient, and likely to be used frequently in contexts where tree structures are involved. Therefore, it is unlikely to be deleted as it serves a fundamental purpose in managing tree nodes."
survived,"    def sample_path(self, d):

        # define a path starting from the leaf node of this doc
        path = np.zeros(self.num_levels, dtype=object)
        node = self.document_leaves[d]
        for level in range(self.num_levels-1, -1, -1): # e.g. [3, 2, 1, 0] for num_levels = 4
            path[level] = node
            node = node.parent

        # remove this document from the path, deleting empty nodes if necessary
        self.document_leaves[d].drop_path()

        ############################################################
        # calculates the prior p(c_d | c_{-d}) in eq. (4)
        ############################################################

        node_weights = {}
        self.calculate_ncrp_prior(node_weights, self.root_node, 0.0)

        ############################################################
        # calculates the likelihood p(w_d | c, w_{-d}, z) in eq. (4)
        ############################################################

        level_word_counts = {}
        for level in range(self.num_levels):
            level_word_counts[level] = {}
        doc_levels = self.levels[d]
        doc = self.corpus[d]

        # remove doc from path
        for n in range(len(doc)): # for each word in the doc

            # count the word at each level
            level = doc_levels[n]
            w = doc[n]
            if w not in level_word_counts[level]:
                level_word_counts[level][w] = 1
            else:
                level_word_counts[level][w] += 1

            # remove word count from the node at that level
            level_node = path[level]
            level_node.word_counts[w] -= 1
            level_node.total_words -= 1
            assert level_node.word_counts[w] >= 0
            assert level_node.total_words >= 0

        self.calculate_doc_likelihood(node_weights, level_word_counts)

        ############################################################
        # pick a new path
        ############################################################

        nodes = np.array(list(node_weights.keys()))
        weights = np.array([node_weights[node] for node in nodes])
        weights = np.exp(weights - np.max(weights)) # normalise so the largest weight is 1
        weights = weights / np.sum(weights)

        choice = self.random_state.multinomial(1, weights).argmax()
        node = nodes[choice]

        # if we picked an internal node, we need to add a new path to the leaf
        if not node.is_leaf():
            node = node.get_new_leaf()

        # add the doc back to the path
        node.add_path()                     # add a customer to the path
        self.document_leaves[d] = node      # store the leaf node for this doc

        # add the words
        for level in range(self.num_levels-1, -1, -1): # e.g. [3, 2, 1, 0] for num_levels = 4
            word_counts = level_word_counts[level]
            for w in word_counts:
                node.word_counts[w] += word_counts[w]
                node.total_words += word_counts[w]
            node = node.parent
",src/hlda/sampler.py,HierarchicalLDA,1,1.0467401685178159e-08,"The method 'sample_path' is a core part of a hierarchical model, likely used in a probabilistic topic model or similar structure. It involves complex operations such as path sampling, likelihood calculation, and node weight adjustments, which are essential for the model's functionality. Such methods are typically retained as they are integral to the model's operation and performance."
survived,"def test_attention_paged_decode_matches_full_prefill():
    B = Axis(""batch"", 2)
    Pos = Axis(""position"", 4)
    Embed = Axis(""embed"", 16)

    cfg = AttentionConfig(Embed=Embed, num_heads=2, num_kv_heads=2, rope=None, attn_backend=AttentionBackend.VANILLA)
    attn_key, x_key = jrandom.split(jrandom.PRNGKey(0))
    attn = Attention.init(cfg, key=attn_key)

    x = hax.random.normal(x_key, (B, Pos, Embed)) * 0.2
    full_out = attn(x, AttentionMask.causal(), key=jrandom.PRNGKey(1))

    cache = _build_page_cache(cfg, B, Pos)
    pos_ids = hax.arange(Pos, dtype=jnp.int32)
    decode_out, _ = _jit_paged_decode(attn, x, pos_ids, cache)

    assert_trees_all_close(full_out.array, decode_out.array, atol=1e-4, rtol=1e-4)
",tests/test_attention.py,,1,7.3382086014706e-07,"The method is a test function that verifies the correctness of an attention mechanism by comparing the output of a full prefill with a paged decode. Test functions are generally crucial for ensuring code reliability and correctness, especially in complex systems like neural networks. Therefore, it is unlikely to be deleted unless the functionality it tests is removed or significantly altered."
survived,"def test_quickstart_offline() -> None:
    repo = Path(__file__).resolve().parents[1]
    dist = repo / ""alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/dist""
    pdf_src = repo / ""docs/insight_browser_quickstart.pdf""
    pdf_dest = dist / ""insight_browser_quickstart.pdf""
    if not pdf_dest.exists() and pdf_src.exists():
        pdf_dest.write_bytes(pdf_src.read_bytes())

    url = (dist / ""index.html"").as_uri()
    try:
        with sync_playwright() as p:
            browser = p.chromium.launch()
            context = browser.new_context()
            page = context.new_page()
            page.goto(url)
            page.wait_for_selector(""#controls"")
            page.wait_for_function(""navigator.serviceWorker.ready"")
            page.reload()
            page.wait_for_function(""navigator.serviceWorker.controller !== null"")
            assert page.evaluate(""(await fetch('insight_browser_quickstart.pdf')).ok"")
            context.set_offline(True)
            page.reload()
            page.wait_for_selector(""#controls"")
            assert page.evaluate(""(await fetch('insight_browser_quickstart.pdf')).ok"")
            browser.close()
    except PlaywrightError as exc:
        pytest.skip(f""Playwright browser not installed: {exc}"")",tests/test_quickstart_offline.py,,1,6.348800075736417e-09,"The method `test_quickstart_offline` is a test function that verifies the offline capabilities of a web application using Playwright. It checks if a PDF file can be fetched both online and offline, ensuring the service worker is functioning correctly. This is a valuable test for ensuring the robustness of the application's offline functionality, which is crucial for user experience in scenarios with intermittent connectivity. The method is well-structured, uses exception handling to skip the test if Playwright is not installed, and is likely part of a test suite that ensures the quality of the application. Therefore, it is unlikely to be deleted as it serves an important purpose in the testing process."
survived,"            async def send_transaction(self, tx: object, *args: object) -> None:
                if raise_err:
                    raise RuntimeError(""fail"")
                captured[""root""] = tx.instructions[0].data.decode()
",tests/test_merkle_broadcast.py,TestMerkleBroadcast.DummyClient,0,0.9999999865595903,"The method 'send_transaction' is likely to be deleted because it contains a reference to an undefined variable 'raise_err', which would cause a NameError when executed. Additionally, the method's functionality is limited to raising an error or decoding a single instruction's data, which may not be sufficient for a transaction sending function. Without further context or error handling, this method seems incomplete or not fully implemented, suggesting it might be removed or replaced with a more robust solution."
survived,"    def path_raw_retro_route():
        args = request.args
        currtime = int(args[""currtime""])
        data = rs.path_raw_retro(args[""origin""], args[""dest""], currtime)
        return Response(data, mimetype=""text/plain"")
",pygs/graphserver/ext/routeserver/routeserver.py,,1,2.5109990926928157e-08,"The method 'path_raw_retro_route' is a simple Flask route handler that processes HTTP GET requests. It extracts query parameters, calls a function 'rs.path_raw_retro' with these parameters, and returns the result as a plain text response. This method is likely to survive because it serves a clear purpose in a web application, handling a specific route and returning data based on user input. There is no indication of redundancy or obsolescence in the code provided."
survived,"    def vertices():
        return Response(rs.vertices(), mimetype=""text/plain"")
",pygs/graphserver/ext/routeserver/routeserver.py,,1,3.0590235908148916e-07,"The method 'vertices' is a simple wrapper around 'rs.vertices()' and returns a response with a specific mimetype. Without additional context, such as the purpose of 'rs.vertices()' or how this method fits into the larger codebase, it's difficult to determine its necessity. However, if 'rs.vertices()' is a critical function call and 'vertices()' is used frequently in the codebase to standardize the response format, it is likely to survive. If 'rs.vertices()' is deprecated or if the response format is no longer needed, it might be deleted. Given the limited information, I predict it will survive as it seems to serve a purpose in formatting the response."
survived,"def _softmax(x: np.ndarray) -> np.ndarray:
    e = np.exp(x - float(np.max(x)))
    return e / (e.sum() + 1e-12)
",src/evaluators/novelty.py,,1,2.5109990926928157e-08,"The method implements a softmax function, which is a fundamental component in many machine learning models, particularly in classification tasks. The implementation is efficient, using numpy for vectorized operations, and includes a numerical stability improvement by subtracting the maximum value from the input array. This is a standard practice to prevent overflow in the exponential function. The addition of a small constant (1e-12) to the sum ensures numerical stability by preventing division by zero. Given its utility and correct implementation, this method is likely to be retained in the codebase."
survived,"    def divergence(self, text: str) -> float:
        vec = embed(text)
        if self.count == 0:
            return 1.0
        p = _softmax(vec[0])
        q = _softmax(self.mean)
        kl = float(np.sum(p * np.log((p + 1e-12) / (q + 1e-12))))
        return kl",src/evaluators/novelty.py,NoveltyIndex,1,2.1724399346070676e-10,"The method 'divergence' is likely to survive because it appears to be a well-defined function that calculates the Kullback-Leibler divergence between the softmax of an embedded text vector and a stored mean vector. This is a common operation in machine learning and natural language processing for measuring the difference between two probability distributions. The method handles edge cases, such as when 'self.count' is zero, by returning a default value of 1.0, which suggests robustness. Additionally, the use of small constants (1e-12) to prevent division by zero indicates attention to numerical stability."
survived,"    def test_runtime_port_env(self, monkeypatch: ""pytest.MonkeyPatch"") -> None:
        """"""AgentRuntime receives AGENTS_RUNTIME_PORT.""""""
        import importlib
        import sys
        import types

        captured: dict[str, int] = {}

        class DummyRuntime:
            def __init__(self, *a: object, port: int = 5001, **_k: object) -> None:
                captured[""port""] = port

            def register(self, *_a: object, **_k: object) -> None:
                pass

            def run(self) -> None:
                pass

        stub = types.ModuleType(""openai_agents"")
        stub.Agent = object
        stub.AgentRuntime = DummyRuntime
        stub.OpenAIAgent = object

        def _tool(*_a: object, **_k: object) -> Callable[[object], object]:
            def dec(f: object) -> object:
                return f

            return dec

        stub.Tool = _tool
        monkeypatch.setitem(sys.modules, ""openai_agents"", stub)
        monkeypatch.delitem(sys.modules, ""agents"", raising=False)
        monkeypatch.setenv(""AGENTS_RUNTIME_PORT"", ""6101"")

        mod = importlib.import_module(""alpha_factory_v1.demos.aiga_meta_evolution.alpha_opportunity_stub"")
        importlib.reload(mod)
        mod.main([])
        self.assertEqual(captured[""port""], 6101)
",tests/test_alpha_opportunity_stub.py,TestAlphaOpportunityStub,1,3.2241866333029355e-08,"The method `test_runtime_port_env` is a unit test that verifies the behavior of a system when the `AGENTS_RUNTIME_PORT` environment variable is set. It uses the `monkeypatch` fixture from `pytest` to modify the environment and system modules temporarily, ensuring that the test is isolated and does not affect other tests or the system state. This is a common practice in testing to ensure that the code behaves as expected under different configurations. The method is likely to survive because it serves a clear purpose in testing the functionality of the system, ensuring that the port is correctly captured and used by the `AgentRuntime`. Such tests are crucial for maintaining code quality and reliability."
survived,"def main() -> None:
    if len(sys.argv) != 2:
        print(f""Usage: {Path(sys.argv[0]).name} <wheel>"", file=sys.stderr)
        raise SystemExit(1)
    wheel = Path(sys.argv[1])
    if not wheel.is_file():
        print(f""Wheel not found: {wheel}"", file=sys.stderr)
        raise SystemExit(1)
    if verify(wheel):
        print(f""OK: {wheel}"")
        raise SystemExit(0)
    print(f""FAILED: {wheel}"", file=sys.stderr)
    raise SystemExit(2)
",alpha_factory_v1/scripts/verify_wheel_sig.py,,1,2.5109990926928157e-08,"The method is a main function that checks command-line arguments, verifies a file, and exits with appropriate status codes. It is a complete and functional script for a specific task, likely part of a larger application or utility. Such main functions are typically retained unless the entire script is deprecated or replaced. The code is clear, follows good practices, and serves a specific purpose, making it unlikely to be deleted without a replacement."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q22.py,Auto2,0,0.9999957771647318,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical or expected behavior for `__contains__`, which is usually used to check membership in a collection, not attribute existence. This could lead to confusion and misuse, as it does not align with the standard use of `__contains__`. Therefore, it is likely to be deleted or refactored to better align with expected behavior."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q2.py,Nation,0,0.999983298584886,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q5.py,Auto2,0,0.9999417087232136,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q11.py,Supplier,0,0.9999599363048656,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not fulfill its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q7.py,Order,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to better fit its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q13.py,Auto2,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, as it should be checking membership in a collection, not attributes of an object. Therefore, this method is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q2.py,Part,1,0.04208772986809034,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually implemented to check for membership in a collection like a list, set, or dictionary. However, if the class is designed to treat its attributes as a collection of keys, this implementation could be valid. Without additional context, it's difficult to determine if this is the intended use. If the class is indeed meant to treat its attributes as keys, this method could survive. Otherwise, it might be considered incorrect and subject to deletion or modification."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q11.py,Auto1,0,0.9999339478346898,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be used for membership testing in collections like lists, sets, or dictionaries. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate method for checking membership in a collection."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q4.py,Lineitem,0,0.9999599363048656,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate method for checking membership."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q8.py,Order,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate membership check."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q19.py,Lineitem,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate membership check."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q20.py,Nation,0,0.9999952149051502,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q10.py,Customer,0,0.9999251538028718,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually implemented to check for membership in a collection like a list, set, or dictionary. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior expected from `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q9.py,Supplier,0,0.9999921107349486,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the typical use case for `__contains__`, which is expected to work with collections like lists, sets, or dictionaries. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior of `__contains__`. Therefore, it is likely to be deleted or refactored to better fit its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q7.py,Supplier,0,0.9999984465026855,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the typical or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of `__contains__` is likely to lead to confusion and errors, as it does not align with the standard behavior expected from this method. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-h/compiler/py/q21.py,Auto1,0,0.9999687980937693,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list, set, or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may be deleted or replaced with a more appropriate implementation."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q25.py,Auto9,0,0.9999945777819207,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may lead to unexpected behavior, suggesting it should be deleted or significantly revised."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q29.py,Auto2,0,0.999983298584886,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto7,1,1.3440409770490404e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, the method is likely to be retained as it serves a clear purpose and follows Python's design principles."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q9.py,Auto5,1,4.539785574814975e-05,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. In this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not a typical use of `__contains__`, as it should generally check for membership in a collection rather than the presence of an attribute. However, if the class is designed to treat its attributes as a collection of keys, this implementation could be valid. Without additional context, it's hard to definitively say if this is a misuse or a creative use. Given the flexibility of Python and potential for unconventional but valid use cases, this method is likely to survive unless it causes confusion or errors in the intended application."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q31.py,Auto3,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the implementation here uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q30.py,Auto3,1,5.60279640614594e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q24.py,Auto2,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate implementation that checks for key membership in a collection."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/job/compiler/py/q12.py,,1,1.522997951276035e-08,"The method '_key' is a utility function that is likely used internally within a module or class to generate a key for sorting purposes. It is a simple and straightforward function that converts the result of a 'sortKey' function into a string if it is a list, tuple, or dictionary. This kind of utility function is common in codebases where sorting or ordering of complex data structures is required. Since it serves a specific purpose and is not overly complex or redundant, it is likely to be retained in the codebase."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q16.py,Auto2,0,0.999985261023967,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q22.py,Auto2,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q25.py,Auto7,1,5.3157849718487075e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q30.py,Auto9,0,0.9999984465026855,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, this implementation uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of `__contains__` is likely to lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership testing. Therefore, it is likely to be deleted or replaced with a more appropriate implementation."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q18.py,Auto6,1,1.955568070542584e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It provides a clear and concise way to access attributes dynamically, which can be very useful in various applications. Therefore, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q7.py,Auto1,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not fulfill its intended purpose. Therefore, it is likely to be deleted or replaced with a more appropriate implementation that correctly checks for key presence in a collection."
survived,"def _sort_key(k):
    if hasattr(k, ""__dataclass_fields__""):
        return str(k)
    if isinstance(k, list):
        return tuple((_sort_key(x) for x in k))
    if isinstance(k, tuple):
        return tuple((_sort_key(x) for x in k))
    if isinstance(k, dict):
        return str(k)
    return k
",tests/dataset/job/compiler/py/q13.py,,1,1.3440409770490404e-08,"The method `_sort_key` is a utility function designed to generate a sorting key for various data types, including dataclasses, lists, tuples, and dictionaries. It is a versatile function that can be useful in many contexts where sorting of complex data structures is required. The function handles different data types gracefully and provides a consistent way to convert them into a sortable format. This kind of utility function is often retained in codebases because it abstracts away the complexity of sorting heterogeneous data structures, making it easier for developers to sort collections without having to write custom sorting logic each time. Therefore, it is likely to be retained in the codebase."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q20.py,Auto7,0,0.9999977396747258,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q16.py,Auto1,1,6.348800075736417e-09,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for classes that need to provide dictionary-like access to their attributes. Since it serves a clear purpose and is implemented correctly, it is likely to be retained in the codebase."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q19.py,Auto3,0,0.9999977396747258,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, this implementation uses `hasattr`, which checks if an object has an attribute with the given name. This is not the intended use of `__contains__`, as it should be used for membership testing in collections, not attribute existence. This misuse of the method is likely to lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership testing. Therefore, it is likely to be deleted or refactored to correctly implement membership testing."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto8,0,0.9999945777819207,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q15.py,Auto6,1,8.152020648014727e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q20.py,Auto8,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is designed to behave like a dictionary or when dynamic attribute access is needed. Therefore, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q32.py,Auto3,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q27.py,Auto6,1,1.955568070542584e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is a simple and effective way to provide dynamic access to object attributes, which can be particularly useful in data handling or configuration classes. Therefore, this method is likely to be retained as it serves a clear purpose and follows Python's conventions for special methods."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q16.py,Auto4,1,5.60279640614594e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, the method is likely to be retained as it serves a clear purpose and is implemented correctly."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q14.py,Auto5,1,1.955568070542584e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. This implementation uses `getattr` to dynamically retrieve an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q29.py,Auto9,1,2.9023122007764653e-06,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in collections like lists or dictionaries. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid use case if the object is designed to allow attribute access via indexing, which can be useful in certain dynamic or flexible data structures. However, it might not be the most common or recommended practice as it can lead to confusion between attribute access and item access. Despite this, the method is functional and serves a purpose, so it is likely to survive unless there is a specific design decision to remove it for clarity or to enforce a different access pattern."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto1,0,0.9999417087232136,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q20.py,,1,2.0611536181902033e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate complex logic that would otherwise need to be repeated in multiple places. Therefore, it is likely to survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q19.py,Auto7,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q22.py,Auto5,0,0.9999869928752253,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto4,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the intended use of `__contains__`, as it should check for membership rather than attribute existence. This misuse of the method is likely to lead to confusion and incorrect behavior when the method is used in the context of checking membership in a collection. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q21.py,Auto5,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may be deleted or replaced with a more appropriate implementation."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto1,1,1.725782769012759e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, this method is likely to be retained as it provides a clear and useful functionality."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q33.py,,1,3.3982678079468468e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate common patterns of data manipulation, making them reusable and reducing code duplication. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto6,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate membership check."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q22.py,Auto3,0,0.9999930377415741,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical or expected behavior for `__contains__`, which is usually used for membership testing in collections like lists, sets, or dictionaries. This misuse of the method could lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership testing. Therefore, it is likely to be deleted or refactored to align with its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q13.py,Auto2,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use of `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q16.py,Auto10,1,1.8553915987649156e-07,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in collections like lists or dictionaries. In this code, it is implemented to return an attribute of the object using `getattr`. This is a non-standard use of `__getitem__`, as it bypasses the typical use case of accessing elements by index or key in a collection. However, it can be useful in certain scenarios where an object is designed to mimic dictionary-like behavior for its attributes. Since this method provides a flexible way to access object attributes dynamically, it is likely to be retained if the design intention is to allow such access. Therefore, the method will likely survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q21.py,Auto10,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the codebase."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q27.py,,1,2.1024340680345882e-07,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It appears to be a utility function that could be part of a larger data processing or querying library. Such functions are often essential for handling data transformations and are unlikely to be deleted unless they are replaced by a more efficient or updated version. Given its comprehensive functionality and potential utility, it is more likely to be maintained or refactored rather than deleted."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto12,0,0.9999251538028718,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate method for checking membership."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q4.py,Auto5,0,0.999983298584886,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q31.py,Auto1,0,0.9999984465026855,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or replaced with a more appropriate implementation."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q23.py,Auto8,1,4.363462233903899e-09,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is unlikely to be deleted unless the design of the class changes significantly, as it provides a flexible way to access object attributes. Therefore, the method will likely survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q29.py,Auto1,0,0.9999957771647318,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use of `__contains__`, which is expected to check membership in a collection rather than the presence of an attribute. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"def test_Q13_finds_earliest_German_movie_info():
    assert result == Auto1(
        release_date=""1997-05-10"", rating=""6.0"", german_movie=""Alpha""
    )
",tests/dataset/job/compiler/py/q13.py,,1,6.825604231969389e-08,"The method `test_Q13_finds_earliest_German_movie_info` is a unit test function. Unit tests are crucial for ensuring that code behaves as expected and for catching bugs early in the development process. This function is likely part of a test suite that verifies the functionality of a larger codebase. Since testing is an essential part of software development, especially in maintaining code quality and reliability, this method is likely to be retained unless the functionality it tests is deprecated or the testing framework changes significantly."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q19.py,Auto6,1,4.6911638017642294e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python, especially in classes that aim to mimic dictionary behavior or provide dynamic attribute access. Therefore, this method is likely to be retained as it serves a clear purpose and follows Python's design principles."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q16.py,Auto9,0,0.999983298584886,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not attribute existence. This misuse of the method's intended purpose is likely to lead to confusion and incorrect behavior when the method is used. Therefore, it is likely that this method will be deleted or refactored to align with its intended use."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q1.py,Auto2,0,0.9999417087232136,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not the presence of an attribute. This misuse of the method's intended purpose suggests that it might be deleted or refactored to align with its conventional use."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q31.py,Auto1,1,1.1861120010657661e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python to allow more flexible and dynamic access to object properties. Therefore, this method is likely to be retained as it serves a clear purpose and follows Python's conventions for special methods."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q31.py,,1,2.3355930333443423e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate complex logic in a reusable manner. Therefore, it is likely to survive."
survived,"def _min(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""min() expects list or group"")
    vals = [it for it in v if it is not None]
    if not vals:
        return 0
    return min(vals)
",tests/dataset/job/compiler/py/q32.py,,1,5.42221743297629e-06,"The method '_min' is a custom implementation of the built-in 'min' function with additional handling for objects with an 'Items' attribute and filtering out 'None' values. However, it raises an exception if the input is not a list or does not have an 'Items' attribute, which might not be the most flexible approach. Despite this, the method serves a specific purpose and handles a specific case that the built-in 'min' does not, which could be useful in certain contexts. Therefore, it is likely to be retained if it is used in a codebase that requires this specific functionality."
survived,"def test_Q33_finds_linked_TV_series_with_low_rated_sequel():
    assert result == [
        Auto1(
            first_company=""US Studio"",
            second_company=""GB Studio"",
            first_rating=""7.0"",
            second_rating=""2.5"",
            first_movie=""Series A"",
            second_movie=""Series B"",
        )
    ]
",tests/dataset/job/compiler/py/q33.py,,1,1.637377179507321e-07,"The method `test_Q33_finds_linked_TV_series_with_low_rated_sequel` is a unit test function, which is typically used to verify that a specific piece of code behaves as expected. Unit tests are crucial for maintaining code quality and ensuring that changes do not introduce new bugs. The presence of an assertion indicates that this test is checking for a specific condition or output, which is a standard practice in software development. Therefore, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q7.py,Auto9,0,0.9999952149051502,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the typical use case for `__contains__`, which is expected to check membership rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q12.py,Auto3,1,1.637377179507321e-07,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a simple and effective way to allow attribute access via keys, which can be particularly useful in data handling or configuration classes. Therefore, this method is likely to be retained as it provides a clear and functional purpose."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q24.py,Auto13,1,2.2159489282323004e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically retrieve an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method is implementing a standard Python protocol and is useful for enhancing the flexibility and usability of the class, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q1.py,Auto4,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not attribute existence. This misuse of the method is likely to lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership checks. Therefore, it is likely that this method will be deleted or significantly modified to align with its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q24.py,Auto6,0,0.9999898700118929,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q21.py,Auto8,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto5,1,8.76424914819242e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python to allow dynamic access to object attributes, especially in cases where the object is used to represent a collection of data. Therefore, this method is likely to be retained as it provides a flexible and Pythonic way to access object attributes."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q17.py,Auto7,1,6.023574641292144e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q29.py,Auto12,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q19.py,Auto1,0,0.999997438718515,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually used to check for membership in a collection like a list, set, or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may lead to confusion or errors. It is more appropriate to use `__contains__` to check for membership in a collection rather than checking for attributes. Thus, this method is likely to be deleted or refactored."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto3,0,0.999985261023967,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto3,0,0.9999251538028718,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not the presence of an attribute. This misuse of the method's intended purpose suggests that it might be deleted or refactored to align with its conventional use."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q23.py,Auto8,0,0.999998790133938,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the standard or expected behavior for `__contains__`, which should typically check for membership in a collection like a list or dictionary. This misuse of `__contains__` is likely to lead to confusion and errors, as it does not align with the conventional use of the method. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q25.py,Auto2,0,0.99999960721363,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not fulfill its intended purpose of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q13.py,Auto7,1,7.194132978569833e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically retrieve an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method is straightforward, functional, and aligns with Python's design principles, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q18.py,Auto7,1,3.653482080241728e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is designed to behave like a dictionary or when dynamic attribute access is needed. Therefore, it is likely to be retained in the code."
survived,"def _min(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""min() expects list or group"")
    vals = [it for it in v if it is not None]
    if not vals:
        return 0
    return min(vals)
",tests/dataset/job/compiler/py/q26.py,,1,1.4738976032926566e-05,"The method '_min' is a custom implementation of the built-in 'min' function, with additional handling for objects with an 'Items' attribute and filtering out 'None' values. However, it raises an exception if the input is not a list or does not have an 'Items' attribute, which might not be the most flexible or user-friendly approach. Additionally, returning 0 for an empty list might not be the expected behavior for all use cases. Despite these issues, the method provides specific functionality that might be useful in certain contexts, such as when dealing with objects that have an 'Items' attribute. Therefore, it is likely to survive if it is used in a specific context where these features are needed."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q33.py,Auto9,0,0.9999898700118929,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/job/compiler/py/q24.py,Auto8,0,0.9999869928752253,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement the intended functionality."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q15.py,Auto9,1,1.1861120010657661e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/job/compiler/py/q28.py,Auto7,1,1.2501528648238603e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, the method is likely to be Survived."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q26.py,CustomerDemo,0,0.9999898700118929,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"def _q0():
    _groups = {}
    _order = []
    for r in catalog_returns:
        _k = r.state
        _ks = str(_k)
        g = _groups.get(_ks)
        if not g:
            g = _Group(_k)
            _groups[_ks] = g
            _order.append(_ks)
        g.Items.append(r)
    _items1 = [_groups[k] for k in _order]
    return [
        Auto1(
            state=g.key,
            avg_amt=(
                sum([x.amt for x in g]) / len([x.amt for x in g])
                if [x.amt for x in g]
                else 0
            ),
        )
        for g in _items1
    ]
",tests/dataset/tpc-ds/compiler/py/q81.py,,1,1.955568070542584e-08,"The method '_q0' is a utility function that processes a list of 'catalog_returns' to group them by 'state', calculate the average amount for each group, and return a list of 'Auto1' objects. This method is likely to survive because it performs a specific and useful task of data aggregation and transformation, which is a common requirement in data processing applications. The logic is clear, and the method is self-contained, making it reusable and maintainable."
survived,"    def __init__(self, key: K):
        self.key = key
        self.Items: list[T] = []
        self.items = self.Items
",tests/dataset/tpc-ds/compiler/py/q81.py,_Group,1,2.699578619062706e-07,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes. The code snippet shows a typical pattern where an attribute is initialized and a list is created. This is a common and necessary practice in class design, so it is unlikely to be deleted."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q1.py,Auto3,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is used as a dictionary-like structure, allowing for flexible and dynamic access to its attributes. Therefore, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q34.py,DateDim,0,0.9999687980937693,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q96.py,StoreSale,0,0.9999952149051502,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement the intended functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q11.py,Customer,0,0.9999962733608834,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"def _q0():
    _groups = {}
    _order = []
    for j in joined:
        _k = Auto3(i_item_id=j.i_item_id, i_item_desc=j.i_item_desc, s_state=j.s_state)
        _ks = str(_k)
        g = _groups.get(_ks)
        if not g:
            g = _Group(_k)
            _groups[_ks] = g
            _order.append(_ks)
        g.Items.append(j)
    _items1 = [_groups[k] for k in _order]
    return [
        Auto1(
            i_item_id=g.key[""i_item_id""],
            i_item_desc=g.key[""i_item_desc""],
            s_state=g.key[""s_state""],
            store_sales_quantitycount=len([_ for _ in g]),
            store_sales_quantityave=(
                sum([x.qty for x in g]) / len([x.qty for x in g])
                if [x.qty for x in g]
                else 0
            ),
            store_sales_quantitystdev=0.0,
            store_sales_quantitycov=0.0,
            store_returns_quantitycount=len([_ for _ in g]),
            store_returns_quantityave=(
                sum([x.ret for x in g]) / len([x.ret for x in g])
                if [x.ret for x in g]
                else 0
            ),
            store_returns_quantitystdev=0.0,
            store_returns_quantitycov=0.0,
            catalog_sales_quantitycount=len([_ for _ in g]),
            catalog_sales_quantityave=(
                sum([x.csq for x in g]) / len([x.csq for x in g])
                if [x.csq for x in g]
                else 0
            ),
            catalog_sales_quantitystdev=0.0,
            catalog_sales_quantitycov=0.0,
        )
        for g in _items1
    ]
",tests/dataset/tpc-ds/compiler/py/q17.py,,1,1.725782769012759e-08,"The method '_q0' is a utility function that processes a collection of items ('joined') and groups them based on certain attributes. It then calculates various statistics for each group, such as counts and averages for sales and returns. The method is structured and performs a specific task that is likely useful in the context of data processing or analysis. It doesn't have any obvious issues or redundancies that would warrant its deletion. Additionally, the method's functionality seems to be a core part of a larger system, likely used for generating reports or summaries, which suggests it is important for the application's operation."
survived,"def _avg(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""avg() expects list or group"")
    if not v:
        return 0
    s = 0.0
    for it in v:
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception(""avg() expects numbers"")
    return s / len(v)
",tests/dataset/tpc-ds/compiler/py/q39.py,,1,3.3982678079468468e-09,"The method '_avg' is a utility function that calculates the average of a list of numbers. It includes error handling for cases where the input is not a list or contains non-numeric values. This kind of utility function is commonly used in various applications to perform basic statistical calculations. Since it is a generic and useful function, it is likely to be retained in the codebase."
survived,"    def __len__(self):
        return len(self.Items)
",tests/dataset/tpc-ds/compiler/py/q71.py,_Group,1,1.1861120010657661e-08,"The method `__len__` is a special method in Python that is used to define the behavior of the `len()` function for instances of a class. This method is essential for any class that represents a collection or container of items, as it allows users to easily determine the number of items in the collection. The implementation provided is straightforward and correctly returns the length of the `Items` attribute, assuming `Items` is a list or similar iterable. Therefore, this method is likely to be retained as it provides necessary functionality for the class."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q2.py,WebSale,1,1.444980317078884e-07,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. In this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is a valid use case if the intention is to check for the presence of attributes rather than elements in a collection. Since this method aligns with a specific use case and is syntactically correct, it is likely to be useful in certain contexts where objects are treated as collections of attributes. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q33.py,CatalogSale,1,0.0850990461671829,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually implemented to check for membership in a collection like a list, set, or dictionary. However, if the class is designed to treat its attributes as a collection of keys, this implementation could be valid. Without additional context, it's difficult to determine if this is the intended use. If the class is indeed meant to treat its attributes as keys, this method could survive. Otherwise, it might be considered incorrect and subject to deletion or modification."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q9.py,Reason,0,0.9999687980937693,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may be deleted or replaced with a more appropriate implementation."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q88.py,TimeDim,0,0.9999546021442518,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and incorrect functionality when the object is used in contexts expecting standard membership testing. Therefore, it is likely that this method will be deleted or refactored to align with the expected behavior of `__contains__`."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q72.py,CatalogSale,1,1.1861120010657661e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern and does not have any apparent issues that would necessitate its deletion. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q80.py,StoreSale,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q21.py,Auto4,1,2.8453347280241004e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q21.py,Auto3,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return an attribute of the object using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q24.py,Customer,1,6.475946147757848e-07,"The method is a custom implementation of the `__contains__` method, which is used to define behavior for the `in` keyword. However, the implementation simply checks if the object has an attribute with the name `key` using `hasattr`. This is a valid use case if the intention is to check for the presence of attributes rather than elements in a collection. The method is straightforward and serves a specific purpose, so it is likely to be retained unless the design requirements change significantly."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q91.py,CustomerDemographic,1,2.2159489282323004e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It provides a clear and concise way to access attributes dynamically, which can be very useful in various applications. There is no indication that this method is redundant or harmful, so it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q20.py,DateDim,0,0.9999945777819207,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute in an object, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q8.py,Customer,0,0.999985261023967,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q29.py,Store,1,6.023574641292144e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in container-like objects such as lists, dictionaries, or custom objects that mimic these behaviors. In this code, `__getitem__` is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation if the object is designed to allow attribute access via indexing, which can be a convenient feature in certain contexts. Since this method provides a clear and potentially useful functionality, it is likely to be retained in the codebase unless there are specific design changes that render it unnecessary or inappropriate."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q22.py,Auto1,1,1.0467401685178159e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q22.py,,1,2.5109990926928157e-08,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate common patterns of data manipulation, making them reusable and reducing code duplication. Therefore, it is likely to be retained."
survived,"def _sum(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""sum() expects list or group"")
    s = 0.0
    for it in v:
        if it is None:
            continue
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception(""sum() expects numbers"")
    return s
",tests/dataset/tpc-ds/compiler/py/q76.py,,1,8.481104769395558e-05,"The method '_sum' is a utility function that calculates the sum of a list of numbers. It includes error handling for non-list inputs and non-numeric elements within the list. This function is useful for summing elements in a list, especially when the input might be a custom object with an 'Items' attribute. The method is straightforward, performs a common task, and includes necessary error checks, making it a candidate for survival. However, its survival depends on the context of the codebase and whether there are more efficient or standardized alternatives available, such as Python's built-in 'sum' function. If the codebase requires custom handling as implemented here, it is likely to survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q77.py,Auto3,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q8.py,StoreSale,0,0.9999945777819207,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement the intended functionality."
survived,"    def __len__(self):
        return len(self.Items)
",tests/dataset/tpc-ds/compiler/py/q27.py,_Group,1,1.2501528648238603e-09,"The method `__len__` is a special method in Python used to define the behavior of the `len()` function for instances of a class. This method is essential for any class that represents a collection or container of items, as it allows users to easily determine the number of items in the collection. The implementation provided is straightforward and correctly returns the length of the `Items` attribute, assuming `Items` is a list or similar iterable. Therefore, this method is likely to be useful and necessary for the class's functionality, leading to its survival."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q51.py,Auto3,0,0.9999546021442518,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate implementation that checks for membership in the intended collection."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q33.py,Item,1,4.6911638017642294e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is a simple and effective way to provide dynamic access to object attributes, which can be particularly useful in data handling or configuration classes. Therefore, this method is likely to be retained as it serves a clear purpose and is implemented correctly."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q91.py,CatalogReturn,1,9.931195248674785e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that need to behave like dictionaries or provide dynamic attribute access. It is likely to be retained as it provides a clear and concise way to access object attributes using keys."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q42.py,Auto1,1,3.653482080241728e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name, which can be useful for objects that need to provide dictionary-like access to their attributes. This is a valid and potentially useful implementation, especially in cases where the object is designed to act like a dictionary or needs to provide flexible attribute access. Therefore, it is likely to be retained in the code."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q1.py,,1,2.2159489282323004e-08,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate common patterns of data manipulation that can be reused across different parts of an application. Therefore, it is likely to be retained."
survived,"def _q1():
    _groups = {}
    _order = []
    for cs in catalog_sales:
        _k = Auto1(customer_sk=cs.cs_bill_customer_sk, item_sk=cs.cs_item_sk)
        _ks = str(_k)
        g = _groups.get(_ks)
        if not g:
            g = _Group(_k)
            _groups[_ks] = g
            _order.append(_ks)
        g.Items.append(cs)
    _items1 = [_groups[k] for k in _order]
    return [
        Auto1(customer_sk=g.key[""customer_sk""], item_sk=g.key[""item_sk""])
        for g in _items1
    ]
",tests/dataset/tpc-ds/compiler/py/q97.py,,1,1.1253518384332553e-07,"The method `_q1()` is a utility function that processes a collection of `catalog_sales` objects, grouping them by a combination of `customer_sk` and `item_sk`. It uses a dictionary to store these groups and maintains an order of keys to preserve insertion order. The function then returns a list of `Auto1` objects, each representing a unique combination of `customer_sk` and `item_sk` from the input data.

This method is likely to survive because it performs a specific and useful task: grouping and transforming data into a desired format. Such utility functions are common in data processing tasks, and unless there is a significant change in requirements or a more efficient method is introduced, this function will likely remain useful and relevant."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q1.py,DateDim,1,1.955568070542584e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return an attribute of the object using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in cases where the object is used like a dictionary or needs to provide flexible access to its attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q27.py,,1,4.944450477491054e-09,"The method '_key' is a utility function that is likely used internally within a module or class to generate a key for sorting purposes. It takes an iterable 'it', applies a sorting key function from 'opts', and ensures the key is a string if it's a complex data type. This kind of function is common in data processing or sorting operations, and unless the entire module or class is being refactored or removed, such utility functions are typically retained. Therefore, it is likely to survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q50.py,StoreSale,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name, which can be useful for objects that need to provide dictionary-like access to their attributes. This is a valid and potentially useful implementation, especially in cases where the object is designed to act like a dictionary or needs to provide flexible attribute access. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q8.py,DateDim,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q54.py,Auto2,0,0.9999251538028718,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the standard or expected behavior for `__contains__`, which is usually used for membership testing in collections like lists, sets, or dictionaries. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the typical use of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q50.py,Store,1,1.3440409770490404e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, the method is likely to be retained as it serves a clear purpose and follows Python's design principles."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q54.py,Auto4,0,0.9999938558278723,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q32.py,DateDim,0,0.999985261023967,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually used to check for membership in a collection like a list, set, or dictionary. This misuse of `__contains__` could lead to confusion and unexpected behavior, as it does not align with the standard behavior expected from this method. Therefore, it is likely that this method will be deleted or refactored to better fit its intended purpose."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q34.py,,1,5.60279640614594e-09,"The method '_key' is a utility function that is likely used for sorting purposes, as indicated by the use of 'opts[""sortKey""]'. It converts the key to a string if it is a list, tuple, or dictionary, which is a common practice to ensure consistent sorting behavior. This method is simple, performs a specific task, and is likely used in conjunction with other sorting operations. Therefore, it is likely to be retained in the codebase as it serves a useful purpose."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q98.py,,1,3.850741907939403e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be used in various data processing scenarios, making it versatile and potentially useful in many contexts. The function is not overly specific to a single use case, which increases its chances of being retained in the codebase. Additionally, the function is well-structured and handles various options, indicating it is designed to be flexible and reusable. These characteristics suggest that the method is likely to survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q8.py,CustomerAddres,1,2.2159489282323004e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for cases where the object is designed to behave like a dictionary or similar container, allowing attribute access via keys. Since this method provides a clear and functional purpose, it is likely to be retained in the code."
survived,"    def __init__(self, key: K):
        self.key = key
        self.Items: list[T] = []
        self.items = self.Items
",tests/dataset/tpc-ds/compiler/py/q77.py,_Group,1,1.1253518384332553e-07,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes. The code snippet shows a typical pattern where an attribute is initialized and a list is created. This is a common and necessary practice in class design, so it is unlikely to be deleted."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q7.py,Item,0,0.9999967112522585,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, this implementation uses `hasattr`, which checks if an object has an attribute with the given name. This is not the intended use of `__contains__`, as it should be checking membership in a collection, not attributes of an object. This misuse of the method suggests it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q93.py,Auto1,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. It is likely to be retained because it provides a flexible and Pythonic way to access object attributes, enhancing the usability of the class."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q26.py,CustomerDemographic,1,4.6911638017642294e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"def test_TPCDS_Q68_simplified():
    assert result == 68
",tests/dataset/tpc-ds/compiler/py/q68.py,,1,4.4508487281649027e-07,"The method `test_TPCDS_Q68_simplified` is a test function that asserts whether the variable `result` is equal to 68. This is a very basic test, and its survival depends on the context in which it is used. If this test is part of a larger suite of tests for a system where `result` is expected to be 68, it will likely survive as it serves a purpose in verifying the correctness of the system. However, if `result` is not defined or the test is not relevant to the current codebase, it might be deleted. Without additional context, it's reasonable to assume that this test serves a purpose in its current context, so it is likely to survive."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q16.py,,1,2.998960815863541e-09,"The method '_group_by' is likely to survive because it provides a useful utility function for grouping elements of a list based on a key function. This is a common requirement in data processing and manipulation tasks. The method is generic, allowing it to work with any type of list elements and key functions, making it versatile and reusable. Additionally, the use of a dictionary to maintain groups and a list to preserve order is a well-established pattern for such operations. Unless there are significant changes in the requirements or a better alternative is introduced, this method is likely to remain useful."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q19.py,Auto2,0,0.9999038976006968,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method's intended purpose could lead to confusion and errors, suggesting that it might be deleted or refactored to better align with its intended use."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q35.py,CustomerDemographic,0,0.9999485577825553,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually used to check for membership in a collection like a list, set, or dictionary. This misuse of `__contains__` could lead to confusion and unexpected behavior, as it does not align with the standard behavior expected from this method. Therefore, it is likely that this method will be deleted or refactored to better align with its intended purpose."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q90.py,WebSale,1,7.73442280641062e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q76.py,Auto2,1,6.348800075736417e-09,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, this method is likely to be retained as it provides a clear and useful functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q73.py,Store,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not the presence of an attribute. This misuse of the method's intended purpose is likely to lead to confusion and errors, suggesting that the method should be deleted or re-implemented correctly."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q79.py,StoreSale,1,2.8453347280241004e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It provides a clear and concise way to access attributes dynamically, which can be very useful in various applications. There is no indication that this method is redundant or harmful, so it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q13.py,CustomerAddres,0,0.9999417087232136,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is usually implemented to check for membership in a collection like a list, set, or dictionary. Using `hasattr` could lead to confusion and misuse, as it doesn't align with the expected behavior of checking for membership in a collection. Therefore, this method is likely to be deleted or refactored to better fit the intended use of `__contains__`."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q27.py,,1,3.3982678079468468e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take', making it adaptable to various use cases. Such utility functions are often retained in codebases because they encapsulate common patterns and reduce code duplication. Therefore, it is likely to be Survived."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q94.py,CustomerAddress,0,0.9999945777819207,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q65.py,_Group,1,9.736200303530205e-10,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, such as those representing collections or sequences. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q38.py,WebSale,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute in an object, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"def _avg(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""avg() expects list or group"")
    if not v:
        return 0
    s = 0.0
    for it in v:
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception(""avg() expects numbers"")
    return s / len(v)
",tests/dataset/tpc-ds/compiler/py/q32.py,,1,4.599055376537186e-10,"The method '_avg' is a utility function that calculates the average of a list of numbers. It includes error handling for non-list inputs and non-numeric elements within the list. Such utility functions are commonly used in various applications to perform basic operations on data structures. The method is well-defined, checks for edge cases (like empty lists), and raises exceptions for invalid inputs, which makes it robust. Therefore, it is likely to be retained in the codebase as it provides a useful and reusable functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q14.py,StoreSale,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking for membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q9.py,Auto1,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of `__contains__` is likely to lead to confusion and bugs, as it does not align with the typical use case of the method. Therefore, it is likely that this method will be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q16.py,DateDim,0,0.999964643742472,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list, set, or dictionary. Therefore, this implementation is likely incorrect and may be deleted or replaced with a more appropriate membership check."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q30.py,CustomerAddres,0,0.9999982396568657,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not fulfill its intended purpose of checking membership in a collection. Therefore, it is likely to be deleted or replaced with a more appropriate implementation."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q12.py,_Group,1,1.1032560311263802e-09,"The method `__iter__` is a standard Python method used to make an object iterable. It is implemented here to return an iterator over `self.Items`, which suggests that `self.Items` is a collection (like a list or a set). This is a common and useful pattern in Python, allowing objects to be used in loops and other iterable contexts. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q48.py,CustomerAddres,1,2.2159489282323004e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically retrieve an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q1.py,DateDim,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of an item in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement the intended functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q30.py,WebReturn,0,0.999999694097641,"The method is likely to be deleted because it does not correctly implement the expected behavior of the `__contains__` method. In Python, `__contains__` is used to check if a container contains a certain item, typically using the `in` keyword. The current implementation uses `hasattr`, which checks for the presence of an attribute, not whether an item is in a collection. This is misleading and does not align with the standard use of `__contains__`, which should check for membership in a collection, not attribute existence."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q13.py,HouseholdDemographic,1,1.0467401685178159e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for cases where an object needs to behave like a dictionary or list, allowing attribute access via keys. Since this method provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q99.py,ShipMode,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return an attribute of the object using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in cases where the object is used like a dictionary or needs to provide flexible access to its attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the codebase."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q93.py,StoreSale,1,1.522997951276035e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python to allow more flexible and dynamic access to object properties. Therefore, this method is likely to be retained as it provides a clear and functional purpose."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q77.py,,1,2.998960815863541e-09,"The method '_key' is a utility function that is likely used internally within a module or class to generate a key for sorting purposes. It takes an iterable 'it', applies a sorting key function from 'opts', and ensures the key is a string if it's a complex data type. This kind of function is common in data processing or sorting operations, and unless the entire module or class is being refactored or removed, such utility functions are generally retained. Therefore, it is likely to survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q39.py,DateDim,0,0.9999980052698925,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, this implementation uses `hasattr`, which checks if an object has an attribute with the given name. This is not the typical or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of `__contains__` is likely to lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership testing. Therefore, it is likely to be deleted or replaced with a more appropriate implementation."
survived,"def _q8():
    _src = web_sales
    _rows = _query(
        _src,
        [{""items"": date_dim, ""on"": lambda ws, d: d.d_date_sk == ws.ws_sold_date_sk}],
        {""select"": lambda ws, d: (ws, d)},
    )
    _groups = _group_by(_rows, lambda ws, d: ws.ws_web_page_sk)
    _items9 = _groups
    return [
        Auto6(
            wp_web_page_sk=g.key,
            sales=_sum([x[0].ws_ext_sales_price for x in g]),
            profit=_sum([x[0].ws_net_profit for x in g]),
        )
        for g in _items9
    ]
",tests/dataset/tpc-ds/compiler/py/q77.py,,1,2.0611536181902033e-09,"The method '_q8' is a private function (indicated by the underscore prefix) that performs a specific task of querying and processing sales data. It is likely part of a larger codebase dealing with data analysis or reporting. The function is well-structured, using helper functions like '_query', '_group_by', and '_sum', which suggests it is part of a modular and reusable codebase. Unless there is a significant change in the requirements or the architecture of the system, such utility functions are typically retained for their functionality. Therefore, it is more likely to survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q25.py,DateDim,1,9.237449576640118e-09,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"def test_TPCDS_Q70_simplified():
    assert result == [
        Auto1(s_state=""CA"", s_county=""Orange"", total_sum=15.0),
        Auto1(s_state=""TX"", s_county=""Travis"", total_sum=20.0),
    ]
",tests/dataset/tpc-ds/compiler/py/q70.py,,1,4.944450477491054e-09,"The method `test_TPCDS_Q70_simplified` is a test function, likely part of a test suite for a larger codebase. Test functions are generally not deleted unless they are redundant, incorrect, or replaced by more comprehensive tests. This function appears to be a straightforward assertion test, checking if the `result` matches an expected list of `Auto1` objects. Without additional context indicating that this test is obsolete or incorrect, it is reasonable to assume it serves a purpose in validating some functionality. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q90.py,TimeDim,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. In this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not a typical or correct implementation for `__contains__`, as it should check for membership in a collection rather than checking for attributes. This misuse of `__contains__` is likely to lead to confusion and incorrect behavior when the method is used. Therefore, it is likely to be deleted or replaced with a more appropriate implementation."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q95.py,Auto2,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in collections like lists or dictionaries. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid use case if the object is designed to allow attribute access via indexing, which can be useful in certain dynamic or flexible data structures. Since this method provides a clear and potentially useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q36.py,Item,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may be deleted or replaced with a more appropriate implementation."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q7.py,CustomerDemographic,0,0.999983298584886,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q12.py,,1,1.8189616842444243e-09,"The method '_group_by' is likely to survive because it provides a useful utility function for grouping elements of a list based on a key function. This is a common requirement in data processing and manipulation tasks. The method is generic, allowing it to be used with various types of data and key functions, which increases its applicability. Additionally, the use of a dictionary to maintain groups and a list to preserve order is a well-established pattern that balances efficiency and functionality. Unless there are significant changes in the requirements or a better alternative is introduced, this method is likely to remain useful."
survived,"def count_range(ssales, tdim, hour, start_min, end_min):
    total = 0.0
    for ss in ssales:
        for t in tdim:
            if (
                (
                    (
                        ss.get(""sold_time_sk"")
                        if isinstance(ss, dict)
                        else getattr(ss, ""sold_time_sk"")
                    )
                    == (
                        t.get(""time_sk"")
                        if isinstance(t, dict)
                        else getattr(t, ""time_sk"")
                    )
                    and (t.get(""hour"") if isinstance(t, dict) else getattr(t, ""hour""))
                    == hour
                )
                and (t.get(""minute"") if isinstance(t, dict) else getattr(t, ""minute""))
                >= start_min
            ) and (
                t.get(""minute"") if isinstance(t, dict) else getattr(t, ""minute"")
            ) < end_min:
                total = total + (
                    ss.get(""qty"") if isinstance(ss, dict) else getattr(ss, ""qty"")
                )
    return total
",tests/dataset/tpc-ds/compiler/py/q88.py,,1,1.3440409770490404e-08,"The method is a utility function that calculates the total quantity of sales within a specific time range. It is a straightforward and useful function for data analysis tasks, especially in sales and time-based data processing. The function is well-structured, handles both dictionary and object inputs, and performs a clear task without any apparent issues. Such utility functions are often retained as they serve a specific purpose and can be reused in various contexts."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q6.py,Customer,0,0.9999869928752253,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q55.py,DateDim,0,0.999985261023967,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q70.py,Auto1,1,2.5109990926928157e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q94.py,CustomerAddres,1,8.76424914819242e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python to allow objects to be more flexible and intuitive to use. Therefore, this method is likely to be retained as it provides a clear and functional purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q88.py,Store,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q64.py,StoreSale,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or replaced with a more appropriate implementation that correctly checks for key presence in a collection."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q91.py,CallCenter,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q71.py,Auto1,0,0.9999599363048656,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not attribute existence. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the conventional use of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q25.py,Item,1,2.5109990926928157e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q70.py,_Group,1,4.363462233903899e-09,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, and there is no indication that it is redundant or incorrect. Therefore, it is likely to be retained."
survived,"def _q0():
    _src = catalog_sales
    _rows = _query(
        _src,
        [
            {""items"": item, ""on"": lambda cs, i: cs.cs_item_sk == i.i_item_sk},
            {
                ""items"": date_dim,
                ""on"": lambda cs, i, d: cs.cs_sold_date_sk == d.d_date_sk,
            },
        ],
        {
            ""select"": lambda cs, i, d: (cs, i, d),
            ""where"": lambda cs, i, d: (
                i.i_category in [""A"", ""B"", ""C""] and d.d_date >= ""2000-02-01""
            )
            and d.d_date <= ""2000-03-02"",
        },
    )
    _groups = _group_by(
        _rows,
        lambda cs, i, d: Auto3(
            id=i.i_item_id,
            desc=i.i_item_desc,
            cat=i.i_category,
            _class=i.i_class,
            price=i.i_current_price,
        ),
    )
    _items1 = _groups
    return [
        Auto2(
            i_item_id=g.key[""id""],
            i_item_desc=g.key[""desc""],
            i_category=g.key[""cat""],
            i_class=g.key[""_class""],
            i_current_price=g.key[""price""],
            itemrevenue=sum([x[0].cs_ext_sales_price for x in g]),
        )
        for g in _items1
    ]
",tests/dataset/tpc-ds/compiler/py/q20.py,,1,4.944450477491054e-09,"The method '_q0' is a data processing function that performs a query on a dataset, filters the data based on certain conditions, groups the results, and then returns a list of objects with calculated revenue. This type of function is typically essential for data analysis tasks and is likely to be used in various data processing pipelines. It doesn't have any obvious issues or redundancies that would warrant its deletion. Therefore, it is likely to be retained in the codebase."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q15.py,,1,4.363462233903899e-09,"The method '_key' is a utility function that is likely used for sorting purposes, as indicated by the use of 'opts[""sortKey""]'. It converts the key to a string if it is a list, tuple, or dictionary, which is a common practice to ensure consistent sorting behavior. This method is simple, performs a specific task, and does not have any apparent issues or redundancies. Therefore, it is likely to be retained in the codebase."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q10.py,_Group,1,3.581747929000289e-10,"The method `__iter__` is a standard Python method used to make an object iterable. By returning an iterator over `self.Items`, it allows the object to be used in loops and other contexts where iteration is needed. This is a fundamental feature for many classes, especially those that represent collections or sequences. Unless there is a specific reason to remove iteration capability from the class, this method is likely to be retained."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q97.py,Auto1,1,3.2241866333029355e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __len__(self):
        return len(self.Items)
",tests/dataset/tpc-ds/compiler/py/q45.py,_Group,1,1.1032560311263802e-09,"The method `__len__` is a special method in Python used to define the behavior of the `len()` function for instances of a class. This method is essential for classes that represent collections or containers, as it allows users to easily determine the number of items in the collection. The implementation here is straightforward and correctly returns the length of the `Items` attribute, which is presumably a list or similar iterable. Therefore, this method is likely to be useful and necessary for the class's functionality, leading to its survival."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q30.py,_Group,1,2.998960815863541e-09,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, and there is no indication that it is redundant or incorrect. Therefore, it is likely to be retained."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q25.py,StoreSale,1,1.522997951276035e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. Since it serves a clear purpose and is implemented correctly, it is likely to be retained in the codebase."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q35.py,_Group,1,1.955568070542584e-08,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, such as those representing collections or sequences. Since it follows the expected pattern for making an object iterable, it is unlikely to be deleted unless the class design changes significantly, which is not indicated here."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q43.py,Store,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q40.py,CatalogReturn,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __len__(self):
        return len(self.Items)
",tests/dataset/tpc-ds/compiler/py/q17.py,_Group,1,7.582560422162384e-10,"The method `__len__` is a special method in Python used to define the behavior of the `len()` function for instances of a class. This method is essential for any class that represents a collection or container of items, as it allows users to easily determine the number of items in the collection. The implementation provided is straightforward and correctly returns the length of the `Items` attribute, assuming `Items` is a list or similar iterable. Therefore, this method is likely to be useful and necessary for the class's functionality, leading to its survival."
survived,"def _sort_key(k):
    if hasattr(k, ""__dataclass_fields__""):
        return str(k)
    if isinstance(k, list):
        return tuple((_sort_key(x) for x in k))
    if isinstance(k, tuple):
        return tuple((_sort_key(x) for x in k))
    if isinstance(k, dict):
        return str(k)
    return k
",tests/dataset/tpc-ds/compiler/py/q49.py,,1,1.8189616842444243e-09,"The method '_sort_key' is a utility function designed to generate a sorting key for various data types, including dataclasses, lists, tuples, and dictionaries. It is a recursive function that handles nested structures, which is a common requirement in sorting operations. The function is well-defined, handles multiple data types, and is likely to be useful in contexts where complex data structures need to be sorted. There are no apparent issues with the logic or implementation that would necessitate its deletion. Therefore, it is likely to be retained in the codebase."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q19.py,Auto1,1,3.653482080241728e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q26.py,CatalogSale,0,0.999891103056471,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the implementation here uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check for membership in a collection, not the presence of an attribute. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"def distinct(xs):
    out = []
    for x in xs:
        if not x in out:
            out = out + [x]
    return out
",tests/dataset/tpc-ds/compiler/py/q16.py,,1,0.00013982203410499962,"The method 'distinct' is a basic implementation of a function that removes duplicates from a list, returning a list of distinct elements. However, it is inefficient because it uses list concatenation in a loop, which results in O(n^2) time complexity. In Python, there are more efficient ways to achieve this, such as using a set to track seen elements or using the built-in 'set' function to directly convert the list to a set and back to a list. Despite its inefficiency, the method is functional and correctly implements the intended behavior, so it is likely to survive unless there is a strong emphasis on performance optimization in the context where it is used."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q7.py,Item,1,3.653482080241728e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q29.py,_Group,1,1.6052280526088547e-09,"The method `__iter__` is a standard Python method used to make an object iterable. It is implemented here to return an iterator over `self.Items`, which suggests that `self.Items` is a collection (like a list or a set). This is a common and useful pattern in Python, allowing objects to be used in loops and other iterable contexts. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def __init__(self, key: K):
        self.key = key
        self.Items: list[T] = []
        self.items = self.Items
",tests/dataset/tpc-ds/compiler/py/q75.py,_Group,1,8.76424914819242e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes. The code snippet shows a typical pattern of initializing instance variables, which is a common and necessary practice in class definitions. Therefore, it is unlikely that this method will be deleted as it serves a crucial role in the class's functionality."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q19.py,Auto2,1,1.522997951276035e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is used as a dictionary-like structure, allowing for flexible and dynamic access to its attributes. Therefore, it is likely to be retained in the code."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q3.py,,1,1.725782769012759e-08,"The method '_key' is a utility function that is likely used internally within a class or module to generate a key for sorting purposes. It takes an iterable 'it', applies a sorting key function from 'opts', and ensures the key is a string if it's a complex data type. This kind of function is common in data processing and sorting operations, and there is no indication that it is obsolete or redundant. Therefore, it is likely to be retained in the codebase."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q77.py,WebSale,0,0.9999952149051502,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the standard or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and bugs, as it does not align with the typical use case of `__contains__`. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q95.py,WebReturn,1,2.1024340680345882e-07,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It is likely to be retained as it provides a clear and concise way to access object attributes using keys, enhancing the usability of the class."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q75.py,_Group,1,6.348800075736417e-09,"The method is a standard implementation of the `__iter__` method in Python, which is used to make an object iterable. This is a common and necessary method for classes that need to support iteration, such as those representing collections or sequences. Since it returns an iterator over `self.Items`, it is likely essential for the functionality of the class, especially if `Items` is a list or another iterable. Therefore, it is unlikely to be deleted unless the class design changes significantly, which is not indicated here."
survived,"def test_TPCDS_Q60_simplified():
    assert result == 60
",tests/dataset/tpc-ds/compiler/py/q60.py,,1,6.825604231969389e-08,"The method `test_TPCDS_Q60_simplified` is a test function that asserts whether the variable `result` is equal to 60. This is a typical unit test structure used in software development to ensure that a specific piece of code behaves as expected. The method is likely to be retained because it serves a clear purpose in verifying the correctness of a particular functionality or calculation. Unless the test is redundant, incorrect, or no longer relevant due to changes in the codebase, it is generally beneficial to keep such tests to maintain code quality."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q2.py,CatalogSale,1,1.725782769012759e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, this method is likely to be retained as it serves a clear purpose and follows Python's design principles."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q31.py,WebSale,0,0.9999921107349486,"The method is incorrectly implemented. The `__contains__` method is supposed to check for membership, typically in a collection or container, and return a boolean indicating whether the specified key or item is present. However, using `hasattr(self, key)` checks if the object has an attribute with the name `key`, which is not the intended use of `__contains__`. This misuse of the method will likely lead to confusion and incorrect behavior when the method is used in contexts expecting standard membership testing. Therefore, it is likely to be deleted or rewritten to correctly implement membership testing."
survived,"    def __init__(self, key: K):
        self.key = key
        self.Items: list[T] = []
        self.items = self.Items
",tests/dataset/tpc-ds/compiler/py/q8.py,_Group,1,1.8553915987649156e-07,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes. The code snippet shows a typical pattern of initializing instance variables, which is a common and necessary practice in class design. Therefore, it is unlikely that this method will be deleted as it serves a crucial role in the class's functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q15.py,CustomerAddress,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q26.py,Item,1,1.3440409770490404e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to behave like a dictionary or similar container, allowing attribute access via keys. Since this method provides a clear and functional purpose, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q34.py,Customer,1,6.69158608681505e-10,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, the method is likely to be Survived."
survived,"def cumulative(xs):
    out = []
    acc = 0.0
    for x in xs:
        acc = acc + x.price
        out = out + [Auto1(date=x.date, cum=acc)]
    return out
",tests/dataset/tpc-ds/compiler/py/q51.py,,1,2.8453347280241004e-08,"The method 'cumulative' is a straightforward implementation of a cumulative sum calculation over a list of objects with 'price' attributes. It creates a new list of 'Auto1' objects, each containing a date and a cumulative sum up to that point. This type of utility function is commonly used in data processing tasks, such as financial calculations or time series analysis. Given its simplicity, clarity, and potential usefulness in various applications, it is likely to be retained in the codebase."
survived,"def test_TPCDS_Q65_simplified():
    assert result == 65
",tests/dataset/tpc-ds/compiler/py/q65.py,,1,3.0590235908148916e-07,"The method `test_TPCDS_Q65_simplified` is a test function that asserts a condition. It is likely part of a test suite for a larger codebase. Test functions are generally not deleted unless they are redundant, incorrect, or replaced by more comprehensive tests. Since this function is simple and directly asserts a condition, it is likely to be retained unless the test case itself becomes irrelevant or the testing framework changes significantly."
survived,"def test_TPCDS_Q97_overlap():
    assert (result[""store_only""] == 1 and result[""catalog_only""] == 1) and result[
        ""store_and_catalog""
    ] == 1
",tests/dataset/tpc-ds/compiler/py/q97.py,,1,2.1024340680345882e-07,"The method `test_TPCDS_Q97_overlap` is a test function, likely part of a test suite for a larger codebase. Test functions are generally not deleted unless they are redundant, incorrect, or the functionality they test is no longer relevant. Since this function is asserting specific conditions on a result, it seems to be actively checking the correctness of some logic related to 'store_only', 'catalog_only', and 'store_and_catalog'. Unless the feature being tested is deprecated or the test is incorrect, it is likely to be maintained to ensure code reliability."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q73.py,DateDim,1,3.2241866333029355e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is likely to survive as it provides a flexible way to access object attributes, assuming the class is designed to support this kind of access."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q38.py,CatalogSale,1,2.8453347280241004e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It provides a clear and concise way to access attributes dynamically, which can be very useful in various applications. Therefore, it is likely to be retained as it adds flexibility and utility to the class."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q23.py,Auto1,1,2.5109990926928157e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the indexing syntax (e.g., obj[key]). In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation, especially in dynamic or flexible data structures where attributes are accessed like dictionary keys. It is likely to be retained as it provides a clear and concise way to access object attributes dynamically."
survived,"def _q0():
    _src = store_sales
    _rows = _query(
        _src,
        [
            {""items"": date_dim, ""on"": lambda ss, d: ss.ss_sold_date_sk == d.d_date_sk},
            {""items"": item, ""on"": lambda ss, d, i: ss.ss_item_sk == i.i_item_sk},
        ],
        {
            ""select"": lambda ss, d, i: (ss, d, i),
            ""where"": lambda ss, d, i: d.d_year == 2000,
        },
    )
    _groups = _group_by(
        _rows, lambda ss, d, i: Auto1(item_sk=i.i_item_sk, date_sk=d.d_date_sk)
    )
    _items1 = _groups
    _items1 = [g for g in _items1 if len(g) > 4]
    return [g.key[""item_sk""] for g in _items1]
",tests/dataset/tpc-ds/compiler/py/q23.py,,0,0.9999999804443193,"The method _q0 is likely to be deleted because it appears to be a specific query function that is tightly coupled with a particular dataset and use case. Such methods are often written for specific data analysis tasks and may not be reusable or relevant in other contexts. Additionally, the method uses a custom query and grouping logic that might be replaced by more generic or optimized solutions as the codebase evolves. If the dataset or the requirements change, this method might become obsolete, leading to its deletion."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q3.py,_Group,1,1.1032560311263802e-09,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, and there is no indication that it is redundant or incorrect. Therefore, it is likely to be retained."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q98.py,,0,0.9998204719779977,"The method is likely to be deleted because it contains several issues that make it less efficient and potentially problematic. Firstly, the use of 'str' as a key for the dictionary is not ideal, especially when dealing with complex objects, as it can lead to unexpected behavior or collisions. Secondly, the method uses 'types.SimpleNamespace' to convert dictionaries to objects, which is an unusual and potentially unnecessary step that complicates the code. Additionally, the method lacks type annotations for the generic types 'T' and 'K', which can lead to confusion about the expected input and output types. These issues suggest that the method may be refactored or replaced with a more robust and clear implementation."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q93.py,,0,0.9999945777819207,"The method is likely to be deleted because it contains several issues that make it less maintainable and potentially error-prone. Firstly, the use of `list[T]` and `Callable[[T], K]` suggests that the code is intended to use Python's type hinting, but it is not using the correct syntax for generic types, which should be imported from `typing`. Secondly, the method uses a `dict[str, _Group[K, T]]` which is not compatible with the generic type `K` unless `K` is explicitly a string, which is not guaranteed. Thirdly, the conversion of `key` to a string using `str(key)` can lead to unexpected behavior if `key` is not inherently string-like. Lastly, the use of `types.SimpleNamespace` to convert a dictionary to an object is unconventional and may lead to confusion. These issues suggest that the method may not be robust or flexible enough for long-term use, leading to its potential deletion."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q75.py,CatalogSale,1,1.3440409770490404e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be used in scenarios where the object is designed to behave like a dictionary or to provide dynamic attribute access. Therefore, it is a useful method and is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q13.py,Auto1,1,3.2241866333029355e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this is a standard and useful implementation, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q37.py,Item,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a valid and useful implementation for cases where the object is designed to behave like a dictionary or similar container, allowing attribute access via keys. Since this method provides a clear and functional purpose, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q9.py,Auto1,1,4.6911638017642294e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q95.py,WebSite,1,1.725782769012759e-08,"The method is a simple implementation of the __getitem__ special method, which allows instances of the class to use the bracket notation (e.g., obj[key]) to access attributes. This is a common and useful pattern in Python, especially for classes that aim to mimic dictionary-like behavior. It provides a clear and concise way to access attributes dynamically, which can be very useful in various applications. Therefore, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q22.py,Inventory,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, the current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the intended use of `__contains__`, which should be checking membership in a collection like a list or dictionary. Therefore, the method is likely to be deleted or rewritten to correctly implement membership checking."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q25.py,StoreSale,0,0.9999910602998366,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement membership checking."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q46.py,CustomerAddres,1,2.5109990926928157e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is likely to survive because it provides a flexible way to access object attributes, which can be particularly useful in dynamic or reflective programming scenarios."
survived,"def _sum(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""sum() expects list or group"")
    s = 0.0
    for it in v:
        if it is None:
            continue
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception(""sum() expects numbers"")
    return s
",tests/dataset/tpc-ds/compiler/py/q91.py,,1,7.194132978569833e-09,"The method '_sum' is a utility function that calculates the sum of a list of numbers, handling cases where the input might be an object with an 'Items' attribute. It includes error handling for non-list inputs and non-numeric elements within the list. This function is useful for summing elements in a flexible way, especially when dealing with objects that encapsulate lists. Given its utility and the fact that it handles edge cases, it is likely to be retained in the codebase."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q39.py,Auto5,1,2.8453347280241004e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is designed to behave like a dictionary or when dynamic attribute access is needed. Therefore, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q76.py,WebSale,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q52.py,Item,0,0.9999930377415741,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical or expected behavior for `__contains__`, which should check for membership in a collection like a list or dictionary. Therefore, this method is likely to be deleted or refactored to correctly implement membership checking."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/tpc-ds/compiler/py/q71.py,,1,2.998960815863541e-09,"The method '_key' is a utility function that is likely used internally within a class or module to generate a key for sorting purposes. It takes an iterable 'it', applies a function from 'opts' dictionary to generate a key, and ensures the key is a string if it's a complex data type. This kind of method is typically useful for custom sorting operations and is unlikely to be removed unless the sorting mechanism is completely refactored or replaced. Therefore, it is more likely to survive."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q87.py,CatalogSale,0,0.9999785550602307,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in the collection's keys or elements. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical or expected behavior for `__contains__`, which should check for membership rather than attribute existence. This misuse of the method could lead to confusion and incorrect functionality when the object is used in contexts expecting standard membership testing. Therefore, it is likely that this method will be deleted or significantly modified to align with expected behavior."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q90.py,TimeDim,1,5.3157849718487075e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the codebase."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q30.py,,1,6.348800075736417e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It appears to be a utility function that could be part of a larger data processing or querying library. The function is well-structured and provides a lot of flexibility through its parameters, which suggests it is designed for reuse in various contexts. Such utility functions are often retained because they encapsulate complex logic that would otherwise need to be rewritten multiple times. Therefore, it is likely to be Survived."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q12.py,Auto1,1,4.6911638017642294e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a flexible and Pythonic way to access object attributes, it is likely to be retained in the code."
survived,"    def __iter__(self):
        return iter(self.Items)
",tests/dataset/tpc-ds/compiler/py/q54.py,_Group,1,2.3355930333443423e-09,"The method is a standard implementation of the __iter__ method in Python, which is used to make an object iterable. It returns an iterator over the 'Items' attribute of the object. This is a common and necessary method for classes that need to support iteration, and there is no indication that it is redundant or incorrect. Therefore, it is likely to be retained."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q39.py,Inventory,0,0.9999993524053853,"The method is likely to be deleted because it does not correctly implement the expected behavior of the `__contains__` method. In Python, `__contains__` is used to check if a container contains a certain item, typically using the `in` keyword. The current implementation uses `hasattr`, which checks for the presence of an attribute, not whether an item is in a collection. This could lead to incorrect behavior and confusion, prompting a refactor or deletion."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q77.py,Auto3,1,3.2241866333029355e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, typically in custom container classes. In this code, it is implemented to return an attribute of the object using `getattr`. This is a valid and useful implementation for cases where the object is designed to allow attribute access via indexing. It is a simple and effective way to provide dictionary-like access to object attributes, which can be particularly useful in dynamic or flexible data structures. Therefore, this method is likely to be retained as it serves a clear purpose and is correctly implemented."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q99.py,Warehouse,1,1.1861120010657661e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, this method is likely to be retained as it provides a clear and useful functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q15.py,Auto1,0,0.9999724643101549,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method's intended purpose could lead to confusion and errors, as it does not align with the expected behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to better fit its intended use."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q95.py,CustomerAddres,0,0.9999756997690634,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute on an object, not the presence of a key in a collection. This is a misuse of the `__contains__` method, as it does not align with the expected behavior of checking membership in a collection. Therefore, it is likely to be deleted or refactored to correctly implement the intended functionality."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q28.py,Auto1,0,0.9999810748526188,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr(self, key)`, which checks if the object has an attribute with the name `key`. This is not the typical use case for `__contains__`, which is expected to check membership in a collection rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, especially for users familiar with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to align with its intended purpose."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q34.py,Auto3,0,0.9999599363048656,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. The current implementation uses `hasattr`, which checks for the presence of an attribute rather than a key in a collection. This is not the typical use case for `__contains__`, which is usually implemented to check for membership in a collection like a list, set, or dictionary. Therefore, this implementation is likely incorrect for its intended purpose and may be deleted or replaced with a more appropriate implementation."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q2.py,,1,4.363462233903899e-09,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be used in various data processing scenarios, making it versatile and potentially useful in many contexts. The function is not overly specific to a single use case, which increases its chances of being retained in the codebase. Additionally, the function is well-structured and implements common data manipulation operations, which are often needed in software applications. Therefore, it is likely to survive."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q15.py,,1,2.2159489282323004e-08,"The method '_group_by' is a utility function that groups elements of a list based on a key function. Such utility functions are commonly used in data processing and transformation tasks. The method is generic, flexible, and can handle various input types, making it a valuable tool in many programming scenarios. Unless there is a specific reason to remove it, such as redundancy or a better alternative, it is likely to be retained."
survived,"def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types

            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [groups[k] for k in order]
",tests/dataset/tpc-ds/compiler/py/q37.py,,1,2.646573631904765e-09,"The method '_group_by' is likely to survive because it provides a useful utility function for grouping elements of a list based on a key function. This is a common requirement in data processing and manipulation tasks. The method is generic, allowing it to work with any type of list elements and key functions, making it versatile and reusable. Additionally, the use of a dictionary to store groups and a list to maintain order ensures efficient grouping and retrieval, which are desirable characteristics in such utility functions."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q38.py,Customer,0,0.9999869928752253,"The method `__contains__` is intended to check if a key is present in a collection, typically by checking if the key is in a dictionary or a list. However, in this implementation, it uses `hasattr`, which checks if an object has an attribute with the given name. This is not the typical use case for `__contains__`, which is expected to check membership rather than attribute existence. This misuse of the method could lead to confusion and unexpected behavior, as it does not align with the standard behavior of `__contains__`. Therefore, it is likely that this method will be deleted or refactored to better align with its intended purpose."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/tpc-ds/compiler/py/q14.py,,1,3.0590235908148916e-07,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It appears to be a utility function that could be part of a larger data processing or querying system. Such functions are often essential in applications that require dynamic data manipulation, especially in systems that mimic SQL-like operations in a non-SQL environment. Given its utility and the fact that it encapsulates a significant amount of logic for data processing, it is likely to be retained unless there is a major refactor or a shift to a more efficient library or framework that provides similar functionality."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q99.py,CatalogSale,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. It is likely to be retained because it provides a flexible and Pythonic way to access object attributes, enhancing the usability of the class."
survived,"def _sum(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""sum() expects list or group"")
    s = 0.0
    for it in v:
        if it is None:
            continue
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception(""sum() expects numbers"")
    return s
",tests/dataset/tpc-ds/compiler/py/q4.py,,1,2.5109990926928157e-08,"The method '_sum' is a utility function that calculates the sum of a list of numbers, with additional handling for objects that have an 'Items' attribute. It includes error handling for non-list inputs and non-numeric elements within the list. This functionality is quite useful in many scenarios where data might be encapsulated in objects or where input validation is necessary. The method is well-defined, performs a common operation, and includes error handling, making it a candidate for survival unless there is a direct replacement or redundancy in the codebase."
survived,"def test_TPCDS_Q59_simplified():
    assert result == [Auto1(s_store_id1=1, ratio=1.5)]
",tests/dataset/tpc-ds/compiler/py/q59.py,,1,1.522997951276035e-08,"The method `test_TPCDS_Q59_simplified` is a test function, likely part of a test suite for a larger codebase. Test functions are generally not deleted unless they are redundant, incorrect, or the functionality they test is no longer relevant. Since this function is asserting a specific result, it indicates that it is testing a particular behavior or output of the code. Unless the functionality being tested is removed or significantly altered, test functions are typically retained to ensure code reliability and correctness. Therefore, it is more likely to survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q29.py,Auto2,1,1.3440409770490404e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return the attribute of the object with the name `key` using `getattr`. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python to allow more flexible and dynamic access to object properties. Therefore, this method is likely to be retained as it serves a clear purpose and follows Python's conventions for special methods."
survived,"    def __contains__(self, key):
        return hasattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q25.py,Auto1,0,0.999988521231025,"The method `__contains__` is intended to check if a key is present in a collection, typically by using the `in` keyword. However, this implementation uses `hasattr`, which checks for the presence of an attribute, not a key in a collection. This is a misuse of the `__contains__` method, as it does not align with its intended purpose. Therefore, it is likely to be deleted or refactored to correctly implement key containment logic."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q21.py,Inventory,1,4.1399375473943306e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and often useful pattern for dynamic attribute access. This method is likely to be useful in scenarios where the object is designed to behave like a dictionary or when attributes need to be accessed dynamically. Therefore, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-ds/compiler/py/q35.py,StoreSale,1,3.653482080241728e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"def test_workers_in_sandbox_iframes() -> None:
    dist = Path(__file__).resolve().parents[1] / ""dist"" / ""index.html""
    url = dist.as_uri()

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.goto(url)
        page.wait_for_selector(""#controls"")
        page.wait_for_function(""document.querySelectorAll('iframe[sandbox]').length >= 2"")
        frames = page.query_selector_all(""iframe[sandbox]"")
        assert len(frames) >= 2
        for f in frames:
            assert f.get_attribute(""sandbox"") == ""allow-scripts""
        browser.close()",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_browser_ui.py,,1,1.1861120010657661e-08,"The method `test_workers_in_sandbox_iframes` is a test function that uses Playwright to automate a browser and verify certain conditions on a webpage. It checks for the presence of sandboxed iframes and their attributes, which is a common requirement in web testing to ensure security and functionality. The method is likely to be useful for maintaining the integrity of web applications, especially those that rely on sandboxed iframes for security. Therefore, it is unlikely to be deleted as it serves a critical testing purpose."
survived,"    def __call__(cls, *args, **kwargs):
        # Create the instance without invoking ``__init__`` so we can inject
        # the base initialization beforehand.
        obj = cls.__new__(cls, *args, **kwargs)
        if isinstance(obj, cls):
            # ``_base_init`` sets attributes that should exist on all modules
            # even when a subclass forgets to call ``super().__init__``.
            Module._base_init(obj)
            cls.__init__(obj, *args, **kwargs)

            # Guarantee existence of critical attributes if ``__init__`` didn't
            # create them.
            if not hasattr(obj, ""callbacks""):
                obj.callbacks = []
            if not hasattr(obj, ""history""):
                obj.history = []
        return obj
",dspy/primitives/program.py,ProgramMeta,1,9.931195248674785e-08,"The method is a custom implementation of the __call__ method for a class, which is used to control the instantiation process of objects. It provides a way to ensure that certain attributes are initialized even if a subclass does not properly call the superclass's __init__ method. This is a useful pattern in object-oriented programming to maintain consistency and reliability in object creation. Since it addresses a common problem in subclassing and provides a robust solution, it is likely to be retained in the codebase."
survived,"    def __init__(self) -> None:
        self._data: dict[str, any] = {}
",custom_components/gree/config_flow.py,ConfigFlow,1,6.825604231969389e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects and setting up initial state. The use of a dictionary to store data is common and does not indicate any issues or reasons for removal. Therefore, the method is likely to be retained."
survived,"    def __init__(self, config_entry: config_entries.ConfigEntry) -> None:
        self.config_entry = config_entry
",custom_components/gree/config_flow.py,OptionsFlowHandler,1,3.2241866333029355e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes or configurations. The presence of a constructor is crucial for the proper functioning of the class, especially when it involves setting up configurations as indicated by the parameter 'config_entry'. Therefore, it is unlikely that this method will be deleted."
survived,"    def _validate_requirements(self, errors: List[str]) -> None:
        req_path = self.bundle_dir / ""requirements.txt""
        if not req_path.exists():
            errors.append(""requirements.txt missing"")
            return
        for line in req_path.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith(""#""):
                continue
            if ""=="" not in line:
                errors.append(f""unpinned requirement: {line}"")
",src/meta_agent/bundle_validator.py,BundleValidator,1,3.850741907939403e-09,"The method '_validate_requirements' is a utility function that checks for the existence of a 'requirements.txt' file and validates its contents. It ensures that all requirements are pinned to specific versions, which is a common best practice in software development to avoid dependency issues. This method is useful for maintaining the integrity and stability of a software project by preventing unpinned dependencies. Given its utility and the fact that it addresses a common need in software projects, it is likely to be retained in the codebase."
survived,"def apply_unicode_escape_map(code: str, mapping: Dict[str, str]) -> str:
    """"""Replace characters in ``code`` with their escape sequences.""""""
    if not mapping:
        return code
    pattern = ""["" + """".join(re.escape(c) for c in mapping) + ""]""
    return re.sub(pattern, lambda m: mapping[m.group(0)], code)
",src/flynt/utils/utils.py,,1,3.3982678079468468e-09,"The method 'apply_unicode_escape_map' is a utility function that replaces characters in a string with their corresponding escape sequences based on a provided mapping. This is a useful function for text processing, especially when dealing with special characters that need to be escaped in certain contexts, such as JSON or HTML. The function is well-defined, uses regular expressions efficiently, and handles edge cases like an empty mapping. Given its utility and correctness, it is likely to be retained in the codebase."
survived,"def main() -> None:
    args = _parse_args()
    os.environ[""DEMO_ASSETS_REV""] = args.revision
    from data_feeds import OFFLINE_URLS  # noqa: E402

    offline_dir = Path(__file__).parent / ""offline_samples""
    offline_dir.mkdir(exist_ok=True)

    for name, url in OFFLINE_URLS.items():
        dest = offline_dir / name
        tmp = dest.with_suffix("".tmp"")
        print(f""Downloading {url} -> {dest}"")
        try:
            with urlopen(url, timeout=10) as r, open(tmp, ""wb"") as f:
                f.write(r.read())
            os.replace(tmp, dest)
        except Exception as exc:  # pragma: no cover - network errors
            if tmp.exists():
                tmp.unlink()
            print(f""Failed to download {url}: {exc}"", file=sys.stderr)
            raise SystemExit(1) from exc
",alpha_factory_v1/demos/macro_sentinel/refresh_offline_data.py,,1,1.955568070542584e-08,"The method is a main function that handles downloading files from specified URLs and saving them to a local directory. It includes error handling for network issues and ensures that temporary files are cleaned up in case of failure. This functionality is essential for applications that need to work with offline data or cache resources locally. The method is well-structured, uses environment variables for configuration, and handles exceptions gracefully, which are all good practices in software development. Therefore, it is likely to be retained in the codebase."
deleted,"    def message_dicts(self) -> List[dict[str, str | None]]:
        return [{""role"": m.role, ""content"": m.content} for m in self._messages]
",libs/core/kiln_ai/adapters/chat/chat_formatter.py,ChatFormatter,1,2.0611536181902033e-09,"The method 'message_dicts' is a straightforward and useful utility function that converts a list of message objects into a list of dictionaries, each containing the role and content of a message. This is a common pattern in data processing and serialization, especially when preparing data for JSON serialization or API responses. The method is clear, concise, and serves a practical purpose, making it unlikely to be deleted unless the entire data handling approach changes significantly."
deleted,"    def messages(self) -> List[ChatMessage]:
        return list(self._messages)
",libs/core/kiln_ai/adapters/chat/chat_formatter.py,ChatFormatter,1,1.8189616842444243e-09,"The method 'messages' is a simple getter that returns a list of chat messages from a private attribute '_messages'. Such methods are common in object-oriented programming to provide controlled access to private data. Since it is a straightforward and useful method for accessing the messages, it is likely to be retained in the codebase."
survived,"    def __init__(self, request: Request) -> None:
        self.request = request
",src/graphql_server/webob/views.py,WebobHTTPRequestAdapter,1,1.2501528648238603e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects with specific attributes or states. This particular constructor takes a 'request' object as a parameter and assigns it to an instance variable, which is a common pattern for setting up objects with necessary data. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def test_runtime_list_agents(self):
        runtime = MagicMock()
        with patch.object(bridge, ""AgentRuntime"", return_value=runtime) as rt_cls, \
                patch.object(bridge.requests, ""get"", return_value=DummyResponse([""a""])) as get:
            agent = bridge.InspectorAgent()
            rt = bridge.AgentRuntime(api_key=None)
            rt.register(agent)

            rt_cls.assert_called_once_with(api_key=None)
            runtime.register.assert_called_once_with(agent)

            result = asyncio.run(bridge.list_agents())
        get.assert_called_once_with(""http://localhost:7860/agents"", timeout=5)
        self.assertIsInstance(result, list)
",tests/test_inspector_bridge.py,TestInspectorAgent,1,8.76424914819242e-08,"The method 'test_runtime_list_agents' is a unit test designed to verify the behavior of the 'list_agents' function in the 'bridge' module. It uses mocking to simulate the behavior of external dependencies, such as HTTP requests and the 'AgentRuntime' class. The test checks that the 'AgentRuntime' is instantiated correctly, that an agent is registered, and that the 'list_agents' function returns a list. This is a typical and necessary test to ensure the functionality of the code, especially when dealing with external systems. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality and reliability."
survived,"def test_mongodb_connection_uri_generation():
    db = MongoDBDatabase(
        host='localhost',
        user='user name',
        password='p@ssword',
        database='mydb',
        port=1234,
        replicaSet='rs0'
    )
    mock_client = MagicMock()
    with patch('pymongo.MongoClient', return_value=mock_client) as mock_mc:
        db.connect()
        mock_mc.assert_called_once()
        uri = mock_mc.call_args.args[0]

    assert uri == 'mongodb://user+name:p%40ssword@localhost:1234/mydb?replicaSet=rs0'
    assert db.connection is mock_client
    assert db.db == mock_client.__getitem__.return_value",peepdb/tests/test_mongodb_uri.py,,1,5.3157849718487075e-08,"The method `test_mongodb_connection_uri_generation` is a unit test designed to verify the correct generation of a MongoDB connection URI and the proper functioning of the `connect` method in the `MongoDBDatabase` class. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with database connections. This test checks if the URI is correctly formatted, if the connection is established using a mock client, and if the database object is correctly set. Such tests are typically retained to maintain code quality and prevent regressions, making it unlikely for this method to be deleted."
survived,"def find_deps(code):
    deps = []
    for imp in re.findall(r""import[^'\""]*['\""](.*?)['\""]"", code):
        if imp.startswith('.'): # relative
            deps.append(imp)
    return deps
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/manual_build.py,,1,2.2159489282323004e-08,"The method 'find_deps' is a utility function that extracts relative import dependencies from a given code string. It uses regular expressions to find import statements and checks if they are relative imports. This functionality is useful for analyzing code dependencies, especially in projects with complex module structures. The method is simple, efficient, and serves a clear purpose, making it likely to be retained in the codebase."
survived,"    def wrapper(*args: Any, **kwargs: Any) -> T:
        for attempt in range(max_tries):
            try:
                return func(*args, **kwargs)
            except Exception as exc:  # pragma: no cover - runtime errors
                if attempt + 1 >= max_tries:
                    raise
                _log_retry(
                    {
                        ""tries"": attempt + 1,
                        ""exception"": exc,
                        ""target"": func,
                    }
                )
                time.sleep(2**attempt * 0.1)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/retry.py,,1,1.955568070542584e-08,"The method is a retry wrapper function that attempts to call a function multiple times before failing. This is a common and useful pattern in programming, especially in scenarios where transient errors might occur, such as network requests or database operations. The use of exponential backoff (time.sleep(2**attempt * 0.1)) is a well-regarded strategy for handling retries. The method is likely to be retained as it provides a robust mechanism for error handling and retry logic."
survived,"def test_refinement_merges_patch(tmp_path: Path) -> None:
    repo = _make_repo(tmp_path)
    logs = tmp_path / ""logs""
    logs.mkdir()
    (logs / ""log.json"").write_text(
        ""\n"".join([
            '{""hash"":""h0"",""ts"":0}',
            '{""hash"":""h1"",""ts"":1}',
            '{""hash"":""h2"",""ts"":5}'
        ]),
        encoding=""utf-8"",
    )

    reg = StakeRegistry()
    reg.set_stake(""meta"", 1.0)

    with (
        patch.object(harness, ""_run_tests"", return_value=0),
        patch.object(harness, ""run_preflight""),
        patch.object(
            harness.patcher_core,
            ""apply_patch"",
            lambda d, repo_path: (Path(repo_path) / ""metric.txt"").write_text(""2\n""),
        ),
    ):
        agent = MetaRefinementAgent(repo, logs, reg)
        merged = agent.refine()

    assert merged
    assert (repo / ""metric.txt"").read_text().strip() == ""2""
    generated = list((repo / ""tests"").glob(""test_generated_*.py""))
    assert generated",tests/test_meta_refinement_agent.py,,1,1.725782769012759e-08,"The method 'test_refinement_merges_patch' is a test function that verifies the behavior of a system involving a repository, logs, and a refinement agent. It uses mock objects to simulate parts of the system and checks if the refinement process correctly merges patches and generates test files. Test functions like this are crucial for ensuring code reliability and are typically not deleted unless they are replaced by more comprehensive tests or the functionality they test is removed. Since the method is actively testing a specific functionality, it is likely to be retained."
survived,"    def _load_logs(self) -> List[Mapping[str, object]]:
        records: List[Mapping[str, object]] = []
        for file in sorted(self.log_dir.glob(""*.json"")):
            for line in file.read_text(encoding=""utf-8"").splitlines():
                if not line.strip():
                    continue
                try:
                    records.append(json.loads(line))
                except json.JSONDecodeError:
                    continue
        return records
",src/agents/meta_refinement_agent.py,MetaRefinementAgent,1,1.0467401685178159e-08,"The method '_load_logs' is a utility function designed to load and parse JSON log files from a specified directory. It is implemented in a way that handles common issues such as empty lines and JSON decoding errors gracefully. This makes it robust and useful for applications that need to process log files. The method is likely to be retained because it performs a necessary and specific task efficiently, and there is no indication of redundancy or poor design that would warrant its removal."
survived,"    def _detect_bottleneck(entries: Iterable[Mapping[str, object]]) -> str | None:
        prev_ts: float | None = None
        max_delta = -1.0
        target: str | None = None
        for rec in entries:
            ts = float(rec.get(""ts"", 0.0))
            if prev_ts is not None:
                delta = ts - prev_ts
                if delta > max_delta:
                    max_delta = delta
                    target = str(rec.get(""hash"", """"))
            prev_ts = ts
        return target
",src/agents/meta_refinement_agent.py,MetaRefinementAgent,1,1.1032560311263802e-09,"The method '_detect_bottleneck' is a utility function that identifies the entry with the largest time gap between consecutive timestamps in a list of records. This is a common requirement in performance analysis and monitoring systems to identify potential bottlenecks. The method is well-defined, uses type hints, and performs a clear and useful task. It is likely to be retained in the codebase as it provides valuable functionality for analyzing time-series data."
survived,"    def dec(f: F) -> F:
        return f
",tests/resources/openai_agents.py,,1,6.144172127844639e-06,"The method 'dec' is a simple decorator function that takes a function 'f' as an argument and returns it unchanged. This is a common pattern in Python for creating decorators, even though this specific implementation does not modify the function in any way. Such a method is often used as a placeholder or a base for more complex decorators. Therefore, it is likely to be retained in the codebase for future use or extension."
survived,"    def register(self, *_a: object, **_k: object) -> None:
        pass
",tests/resources/openai_agents.py,AgentRuntime,0,0.9999999397642536,"The method 'register' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it is a placeholder for future functionality. However, without any implementation or documentation indicating its purpose, it is likely to be considered dead code. Unless there is a clear plan to implement this method or it is part of an interface that requires its presence, it is likely to be deleted in a codebase cleanup."
survived,"def title_case(text: str) -> str:
    words = re.split(r'(\s+|-)', text)
    # Count real words (exclude spaces/hyphens)
    real_words = [w for w in words if w and not re.match(r'(\s+|-)', w)]
    total = len(real_words)
    result = []
    index = 0
    for part in words:
        if re.match(r'(\s+|-)', part):
            result.append(part)
            continue
        word = part
        is_first = index == 0
        is_last = index == total - 1
        lower = word.lower()
        if word.isupper() or any(c.isupper() for c in word[1:]):
            result.append(word)
        elif not is_first and not is_last and lower in SMALL_WORDS:
            result.append(lower)
        else:
            result.append(word.capitalize())
        index += 1
    return ''.join(result)
",scripts/fix_titlecase.py,,1,7.194132978569833e-09,"The method 'title_case' is a utility function that converts a given string into title case, taking into account certain rules such as preserving the case of fully uppercase words and handling small words differently. This functionality is commonly needed in text processing and formatting tasks. The method is well-structured, uses regular expressions effectively, and handles edge cases like spaces and hyphens. Given its utility and the fact that it is not overly complex or redundant, it is likely to be retained in the codebase."
survived,"    def _strip_trailing_ws(self, part: doc.DocType) -> doc.DocType:
        """"""Recursively strip trailing whitespace from a Doc node.""""""
        if isinstance(part, doc.Concat) and part.parts:
            while part.parts and isinstance(part.parts[-1], doc.Text) and getattr(part.parts[-1], ""text"", """") == "" "":
                part.parts.pop()
            if part.parts:
                part.parts[-1] = self._strip_trailing_ws(part.parts[-1])
        elif isinstance(part, (doc.Group, doc.Indent, doc.Align)):
            part.contents = self._strip_trailing_ws(part.contents)
        return part
",jac/jaclang/compiler/passes/tool/doc_ir_gen_pass.py,DocIRGenPass,1,6.348800075736417e-09,"The method '_strip_trailing_ws' is a utility function designed to recursively strip trailing whitespace from a document node. This kind of functionality is often necessary in text processing and formatting tasks to ensure clean and consistent output. The method is implemented to handle different types of document nodes, such as 'Concat', 'Group', 'Indent', and 'Align', which suggests it is part of a larger document processing library or framework. Given its utility in maintaining document cleanliness and its recursive nature, which indicates careful handling of nested structures, it is likely to be a useful and necessary part of the codebase. Therefore, it is unlikely to be deleted."
survived,"    def test_calibration_unmodified(self):
        self.simulator = MonteCarloSimulator(
            self.calibration,
            self.block,
            self.dr,
            self.initial,
            agent_count=1,
        )

        self.simulator.initialize_sim()
        self.simulator.sim_one_period()

        self.assertEqual(self.calibration, {""G"": 1.05})",HARK/simulation/test_monte_carlo.py,test_MonteCarloSimulator,1,1.8189616842444243e-09,"The method 'test_calibration_unmodified' is a unit test that checks if the 'calibration' attribute remains unchanged after running a simulation. This is a valid and useful test to ensure that the simulation does not inadvertently modify the input parameters. Therefore, it is likely to be retained as part of the test suite to ensure the integrity of the simulation process."
survived,"def main():
    is_x86 = env['X86'] == '1'
    is_from_ci = 'from_ci' in sys.argv

    if is_windows():
        with CurrentDir('Tool/EffekseerLauncher'):
            run_command('call build_windows.bat')

    if is_mac():
        with CurrentDir('Tool/EffekseerLauncher'):
            run_command('sh build_macosx.sh')

    if env['IGNORE_BUILD'] == '0':
        os.makedirs('build', exist_ok=True)

        with CurrentDir('build'):

            if is_windows() or is_mac():
                # for auto restore of .csproj
                wget(r'https://dist.nuget.org/win-x86-commandline/v5.1.0/nuget.exe')

            if is_windows():
                suffix = ''
                if is_from_ci:
                    suffix += ' -D FROM_CI=ON'

                # run tests on x64
                run_command('cmake .. -A x64 -DBUILD_VIEWER=ON -D BUILD_TEST=ON -D BUILD_EXAMPLES=ON' + suffix)

            elif is_mac():
                run_command('cmake .. -G ""Xcode"" -DCMAKE_OSX_ARCHITECTURES=""arm64;x86_64"" -DBUILD_VIEWER=ON -D BUILD_TEST=ON -D BUILD_EXAMPLES=ON')
            elif shutil.which('ninja'):
                run_command('cmake .. -G Ninja -DBUILD_VIEWER=ON -D BUILD_TEST=ON -D BUILD_EXAMPLES=ON')
            else:
                run_command('cmake .. -G ""Unix Makefiles"" -DBUILD_VIEWER=ON')
            run_command('cmake --build . --config Release')

        if is_mac():
            run_command('dotnet build Dev/Editor/Effekseer/Effekseer.csproj')
            run_command('dotnet publish Dev/Editor/Effekseer/Effekseer.csproj -c Release --self-contained -r osx.10.11-x64')
            run_command('cp -r Dev/release/osx.10.11-x64/publish/* Dev/release/')
            run_command('rm -rf -r Dev/release/osx.10.11-x64')

        elif is_windows():
            run_command('dotnet build Dev/Editor/Effekseer/Effekseer.csproj')
            run_command('dotnet publish Dev/Editor/Effekseer/Effekseer.csproj -c Release --self-contained -r win-x64')
            shutil.copytree('Dev/release/win-x64/publish', 'Dev/release', dirs_exist_ok=True)
            shutil.rmtree('Dev/release/win-x64')
        else:
            run_command('dotnet build Dev/Editor/Effekseer/Effekseer.csproj')
            run_command('dotnet publish Dev/Editor/Effekseer/Effekseer.csproj -c Release --self-contained -r linux-x64')
            run_command('chmod +x Dev/release/Effekseer')
            run_command('chmod +x Dev/release/EffekseerMaterialEditor')
            run_command('chmod +x Dev/release/tools/fbxToEffekseerCurveConverter')
            run_command('chmod +x Dev/release/tools/fbxToEffekseerModelConverter')
            run_command('chmod +x Dev/release/tools/libfbxsdk.so')
            run_command('cp -r Dev/release/linux-x64/publish/* Dev/release/')
            run_command('rm -rf -r Dev/release/linux-x64')

    if env['PACKAGEING_FOR_MAC'] == '1' and is_mac():
        cd('Dev')
        mkdir('Mac/Effekseer.app/Contents/Resources/')
        copy_tree('release/', 'Mac/Effekseer.app/Contents/Resources/')

        mkdir('Mac/Effekseer.app/Contents/MacOS/')
        shutil.copy('../Tool/EffekseerLauncher/build_macosx/EffekseerLauncher', 'Mac/Effekseer.app/Contents/MacOS/')

        run_command('chmod +x Mac/Effekseer.app/Contents/Resources/tools/fbxToEffekseerCurveConverter')
        run_command('chmod +x Mac/Effekseer.app/Contents/Resources/tools/fbxToEffekseerModelConverter')

        os.makedirs('Mac/Package', exist_ok=True)

        copy_tree('Mac/Effekseer.app', 'Mac/Package/Effekseer.app')
        run_command('ln -s /Applications Applications > /dev/null 2>&1')
        run_command('mv Applications Mac/Package/')
        run_command('hdiutil create Effekseer.dmg -volname ""Effekseer"" -srcfolder ""Mac/Package""')

        cd('../')
        os.makedirs('EffekseerTool', exist_ok=True)
        shutil.copy('Dev/Effekseer.dmg', 'EffekseerTool/')
        shutil.copy('docs/Help_Ja.html', 'EffekseerTool/')
        shutil.copy('docs/Help_En.html', 'EffekseerTool/')
        shutil.copy('LICENSE_TOOL', 'EffekseerTool/LICENSE_TOOL')
        shutil.copy('readme_tool_mac.txt', 'EffekseerTool/readme.txt')

        os.makedirs('EffekseerTool/Sample/', exist_ok=True)
        copy_tree('Release/Sample', 'EffekseerTool/Sample')
        copy_tree('ResourceData/samples', 'EffekseerTool/Sample')
        shutil.copy('docs/readme_sample.txt', 'EffekseerTool/Sample/readme.txt')
",build.py,,1,1.3440409770490404e-08,"The method is a comprehensive build script that handles different operating systems and configurations. It is likely part of a larger build system for a project, and such scripts are typically maintained and updated rather than deleted. The script includes conditional logic for different environments, which suggests it is actively used in various scenarios. Unless the entire project is being deprecated or replaced, this method is likely to survive."
survived,"    def test_idempotent(self) -> None:
        logger = logging.getLogger(""alpha_factory.agents"")
        stream = io.StringIO()
        handler = logging.StreamHandler(stream)
        logger.addHandler(handler)

        demo.register_demo_agents()
        stream.truncate(0)
        stream.seek(0)
        demo.register_demo_agents()

        logger.removeHandler(handler)
        logs = stream.getvalue()
        self.assertNotIn(""Duplicate agent name"", logs)
",tests/test_demo_registration.py,TestRegisterDemoAgents,1,4.944450477491054e-09,"The method 'test_idempotent' is a unit test designed to ensure that the 'register_demo_agents' function is idempotent, meaning it can be called multiple times without causing unintended side effects, such as logging a 'Duplicate agent name' error. This is a valuable test to ensure the robustness and reliability of the 'register_demo_agents' function. Since it serves a clear purpose in testing the idempotency of a function, it is likely to be retained in the codebase."
survived,"    def test_repeated_close_safe(self):
        conn = self.fabric.vector._sql
        self.fabric.close()
        self.fabric.close()
        self.assertIsNone(self.fabric.vector._sql)
        with self.assertRaises(sqlite3.ProgrammingError):
            conn.execute(""SELECT 1"")
",tests/test_memory_fabric_sqlite.py,TestMemoryFabricSQLiteClose,1,4.944450477491054e-09,"The method 'test_repeated_close_safe' is a unit test designed to ensure that calling the 'close' method on 'self.fabric' multiple times does not cause errors and that the connection is properly closed. This is a common scenario that needs to be tested to ensure robustness of the code. The test checks that after closing, the connection is set to None and that any attempt to use the connection raises an appropriate error. Such tests are crucial for maintaining code quality and preventing resource leaks, so it is likely to be retained."
survived,"def _remote_available_space(address: str, path: str) -> int | None:
    """"""Return available bytes on remote machine or ``None`` on failure.""""""
    try:
        result = subprocess.run(
            [""ssh"", ""-o"", ""ConnectTimeout=5"", address, ""df"", ""-PB1"", path],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except subprocess.CalledProcessError:
        return None

    try:
        lines = result.stdout.strip().splitlines()
        if len(lines) >= 2:
            return int(lines[1].split()[3])
    except Exception:
        return None

    return None
",pioreactor/actions/leader/backup_database.py,,1,1.1032560311263802e-09,"The method '_remote_available_space' is likely to survive because it provides a useful utility function to check available space on a remote machine using SSH. It handles exceptions gracefully, returning 'None' on failure, which is a good practice for robustness. The method is also concise and uses standard libraries, making it easy to maintain and understand. Additionally, checking remote disk space is a common requirement in many applications, suggesting that this method has practical utility."
survived,"async def _run_unsubscribe():
    hub = TraceHub()
    q = await hub.subscribe()
    await hub.unsubscribe(q)
    with mock.patch(""alpha_factory_v1.backend.trace_ws.asyncio.create_task"", asyncio.ensure_future):
        await hub.broadcast(TraceEvent(label=""bye""))
        await asyncio.sleep(0.1)
    assert q.empty()
",tests/test_trace_hub.py,,0,0.9999921107349486,"The method `_run_unsubscribe` is likely to be deleted because it appears to be a test or utility function that is not part of the main application logic. It uses mocking and assertions, which are typical in test scenarios. If this function is part of a test suite, it might be removed if the test is no longer relevant or if the functionality it tests is deprecated or refactored. Additionally, the function name starts with an underscore, suggesting it is intended for internal use, which often means it can be removed or replaced without affecting the public API."
survived,"def test_portfolio_record_and_history():
    with tempfile.TemporaryDirectory() as tmpdir:
        path = os.path.join(tmpdir, ""book.jsonl"")
        p = portfolio.Portfolio(portfolio.Path(path))
        with mock.patch.object(portfolio.Portfolio, ""_broadcast"", lambda *a, **k: None):
            p.record_fill(""BTC"", 1.0, 100.0, ""BUY"")
            p.record_fill(""BTC"", 0.5, 110.0, ""SELL"")
            asyncio.run(p.arecord_fill(""BTC"", 0.5, 120.0, ""BUY""))
        assert p.position(""BTC"") == 1.0
        assert p.book()[""BTC""] == 1.0
        hist = list(p.history())
        assert len(hist) == 3
        assert hist[0].symbol == ""BTC""
        assert hist[1].side == ""SELL""
        # ensure persisted json
        with open(path) as fh:
            lines = fh.read().splitlines()
        assert len(lines) == 3
        rec = json.loads(lines[0])
        assert rec[""symbol""] == ""BTC""
        p.clear()
        assert p.book() == {}",tests/test_portfolio_basic.py,,1,5.3157849718487075e-08,"The method 'test_portfolio_record_and_history' is a unit test designed to verify the functionality of the 'Portfolio' class, specifically its ability to record and retrieve transaction history. It uses temporary directories and mock objects to isolate the test environment, ensuring no side effects on the actual file system or network. The test checks various aspects of the portfolio's behavior, such as recording fills, maintaining positions, and persisting data to a file. These are essential features for a financial application, and the test ensures they work correctly. Given its importance in validating critical functionality, this method is likely to be retained."
survived,"    async def step(self) -> None:
        await self.publish(""alpha.execution"", {""alpha"": ""order executed""})
",alpha_factory_v1/demos/alpha_agi_business_v1/alpha_agi_business_v1.py,AlphaExecutionAgent,1,3.160881453314576e-10,"The method 'step' is an asynchronous function that performs a specific task: publishing a message to a channel 'alpha.execution'. This is a common pattern in asynchronous programming, especially in systems that use message brokers or event-driven architectures. The method is concise, clear, and serves a specific purpose, which makes it unlikely to be deleted unless the entire messaging system or the specific functionality it supports is removed. Therefore, it is more likely to survive."
survived,"    def __init__(self) -> None:
        super().__init__()
        path = Path(__file__).with_name(""examples"") / ""alpha_opportunities.json""
        try:
            self._opportunities = json.loads(path.read_text(encoding=""utf-8""))
        except Exception:  # pragma: no cover - fallback when file missing
            self._opportunities = [
                {""alpha"": ""generic supply-chain inefficiency""}
            ]
",alpha_factory_v1/demos/alpha_agi_business_v1/alpha_agi_business_v1.py,AlphaOpportunityAgent,1,4.944450477491054e-09,"The method is likely to survive because it is a constructor method (`__init__`) which is essential for initializing instances of a class. It sets up the initial state by loading data from a JSON file and provides a fallback mechanism in case the file is missing. This functionality is crucial for the class to operate correctly, making it unlikely to be removed."
survived,"async def discover(num: int = 1) -> List[Dict[str, str]]:
    return discover_alpha(num=num)
",alpha_factory_v1/demos/cross_industry_alpha_factory/openai_agents_bridge.py,,0,0.9999999970010391,"The method 'discover' is a simple wrapper around another function 'discover_alpha'. It doesn't add any additional functionality or logic, making it redundant. Such methods are often removed to simplify the codebase unless they serve a specific purpose like maintaining backward compatibility or providing a more descriptive interface. Without additional context suggesting such a purpose, it's likely to be deleted."
survived,"async def check_health() -> str:
    """"""Check orchestrator /healthz endpoint.""""""
    resp = requests.get(f""{HOST}/healthz"", timeout=5)
    resp.raise_for_status()
    return resp.text
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,0,0.9999999895325983,"The method `check_health` is likely to be deleted (0) because it uses the `requests` library for making HTTP requests, but it is defined as an `async` function. This is inconsistent because `requests` is a synchronous library and does not support asynchronous operations. To properly implement an asynchronous HTTP request, a library like `aiohttp` should be used instead. This inconsistency suggests that the method may be refactored or removed in favor of a correct asynchronous implementation."
survived,"def _recent_alpha(limit: int = 5) -> list[dict]:
    resp = requests.get(
        f""{HOST}/memory/alpha_opportunity/recent"", params={""n"": limit}, timeout=5
    )
    resp.raise_for_status()
    return resp.json()
",alpha_factory_v1/demos/alpha_agi_business_v1/gradio_dashboard.py,,1,7.582560422162384e-10,"The method `_recent_alpha` is a utility function that fetches recent alpha opportunities from a specified host. It uses the `requests` library to make an HTTP GET request and returns the JSON response as a list of dictionaries. The method is straightforward, performs a specific task, and includes error handling with `raise_for_status()`. These characteristics suggest that the method is well-defined and useful for its intended purpose, making it likely to survive."
survived,"async def search_memory(query: str, limit: int = 5) -> list[str]:
    """"""Query the orchestrator memory vector store.""""""
    resp = requests.get(
        f""{HOST}/memory/search"",
        params={""q"": query, ""k"": limit},
        timeout=5,
    )
    resp.raise_for_status()
    return resp.json()
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,0,0.9999994284997149,"The method is likely to be deleted because it uses the 'requests' library for making HTTP requests, which is synchronous, in an asynchronous function. This is not optimal as it blocks the event loop, defeating the purpose of using async. A more appropriate approach would be to use an asynchronous HTTP client like 'aiohttp'."
survived,"def get_resource_type_from_arn(arn: str) -> str:
    """"""Return the resource type format expected by the Tagging API.

    The Resource Groups Tagging API requires resource types in the form
    ``service:resource``. Most ARNs embed the resource type in the fifth segment
    after the service name. Load balancer ARNs add an extra ``app`` or ``net``
    component that must be preserved. S3 and SQS ARNs only contain the service
    name.  This helper extracts the appropriate string so that ARNs can be
    grouped correctly for API calls.
    """"""

    parts = arn.split("":"", 5)
    service = parts[2]
    if service in {""s3"", ""sqs""}:
        return service

    resource = parts[5]
    if service == ""elasticloadbalancing"" and resource.startswith(""loadbalancer/""):
        segments = resource.split(""/"")
        if len(segments) > 2 and segments[1] in {""app"", ""net""}:
            resource_type = f""{segments[0]}/{segments[1]}""
        else:
            resource_type = segments[0]
    else:
        resource_type = resource.split(""/"")[0].split("":"")[0]

    return f""{service}:{resource_type}"" if resource_type else service
",cartography/intel/aws/resourcegroupstaggingapi.py,,1,1.2501528648238603e-09,"The method `get_resource_type_from_arn` is a utility function that extracts and formats the resource type from an Amazon Resource Name (ARN) string. This functionality is essential for interacting with AWS services, particularly when using the Resource Groups Tagging API, which requires a specific format for resource types. The method handles various cases, such as different ARN structures for services like S3, SQS, and Elastic Load Balancing. Given its utility in AWS resource management and the lack of any apparent issues or redundancies in the code, it is likely to be retained in the codebase."
survived,"def _group_tag_data_by_resource_type(
    tag_data: List[Dict],
    tag_resource_type_mappings: Dict,
) -> Dict[str, List[Dict]]:
    """"""Group raw tag data by the resource types Cartography supports.""""""

    grouped: Dict[str, List[Dict]] = {rtype: [] for rtype in tag_resource_type_mappings}
    for mapping in tag_data:
        rtype = get_resource_type_from_arn(mapping[""ResourceARN""])
        if rtype in grouped:
            grouped[rtype].append(mapping)
        else:
            logger.debug(
                ""Unknown tag resource type %s from ARN %s"",
                rtype,
                mapping[""ResourceARN""],
            )
    return grouped
",cartography/intel/aws/resourcegroupstaggingapi.py,,1,5.211412485172657e-10,"The method '_group_tag_data_by_resource_type' is a utility function that organizes data into a specific structure, which is a common requirement in data processing tasks. It is well-defined, has a clear purpose, and is likely used in multiple parts of a codebase that deals with tagging and resource management. The function also includes logging for unknown resource types, which is useful for debugging and maintaining the code. These characteristics suggest that the method is valuable and likely to be retained in the codebase."
survived,"def test_quickstart_pdf_offline() -> None:
    repo = Path(__file__).resolve().parents[1]
    dist = repo / ""alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/dist""
    pdf_src = repo / ""docs/insight_browser_quickstart.pdf""
    pdf_dest = dist / ""insight_browser_quickstart.pdf""
    if not pdf_dest.exists() and pdf_src.exists():
        pdf_dest.write_bytes(pdf_src.read_bytes())

    server, thread = _start_server(dist)
    host, port = server.server_address
    url = f""http://{host}:{port}""
    try:
        with sync_playwright() as p:
            browser = p.chromium.launch()
            context = browser.new_context()
            page = context.new_page()
            page.goto(url + ""/index.html"")
            page.wait_for_selector(""#controls"")
            page.wait_for_function(""navigator.serviceWorker.ready"")
            page.reload()
            page.wait_for_function(""navigator.serviceWorker.controller !== null"")
            context.set_offline(True)
            resp = page.goto(url + ""/insight_browser_quickstart.pdf"")
            assert resp and resp.ok, ""PDF not served offline""
            browser.close()
    except PlaywrightError as exc:
        pytest.skip(f""Playwright browser not installed: {exc}"")
    finally:
        server.shutdown()
        thread.join()",tests/test_pwa_offline.py,,1,1.725782769012759e-08,"The method 'test_quickstart_pdf_offline' is a test function that verifies the offline functionality of serving a PDF file using a local server and Playwright. It is a useful test to ensure that the application can serve resources offline, which is a critical feature for many web applications. Test functions like this are typically retained as they are essential for maintaining the quality and reliability of the software."
survived,"def reset_env(monkeypatch):
    monkeypatch.delenv(""SELF_IMPROVE_PROVIDER"", raising=False)
",tests/test_self_edit_prompting.py,,1,3.653482080241728e-08,"The method `reset_env` is a utility function that uses `monkeypatch.delenv` to delete an environment variable if it exists. This is a common practice in testing environments where you want to ensure that certain environment variables do not affect the test outcomes. The use of `monkeypatch` is typical in testing frameworks like `pytest`, and such utility functions are often necessary to maintain clean test environments. Therefore, the method is likely to be retained as it serves a specific purpose in testing scenarios."
survived,"def test_stake_weighted_acceptance() -> None:
    reg = StakeRegistry()
    reg.set_stake(""A"", 50)
    reg.set_stake(""B"", 30)
    reg.set_stake(""C"", 20)
    reg.vote(""p1"", ""A"", True)
    reg.vote(""p1"", ""B"", True)
    reg.vote(""p1"", ""C"", False)
    assert reg.accepted(""p1"")
    reg.vote(""p2"", ""A"", True)
    reg.vote(""p2"", ""B"", False)
    reg.vote(""p2"", ""C"", False)
    assert not reg.accepted(""p2"")",tests/test_stake_registry.py,,1,1.3440409770490404e-08,"The method `test_stake_weighted_acceptance` is a unit test for a `StakeRegistry` class, which appears to be testing the functionality of stake-weighted voting and acceptance. This is a common pattern in systems that require consensus or decision-making based on weighted votes, such as blockchain or governance systems. The test is well-structured, with clear assertions that verify the expected behavior of the `StakeRegistry` class. Since testing is a crucial part of software development to ensure code reliability and correctness, this method is likely to be retained as part of the test suite to validate the functionality of the `StakeRegistry` class."
survived,"    def accepted(self, proposal_id: str) -> bool:
        """"""Return ``True`` iff yes votes reach two-thirds of total stake.""""""
        total = self.total()
        if total == 0:
            return False
        votes = self.votes.get(proposal_id, {})
        yes = sum(self.stakes[a] for a, v in votes.items() if v)
        return yes / total >= 2 / 3",src/governance/stake_registry.py,StakeRegistry,1,9.736200303530205e-10,"The method 'accepted' is a crucial part of a voting system, determining if a proposal has been accepted based on the votes and stakes. It calculates the proportion of 'yes' votes relative to the total stake and checks if it meets the two-thirds threshold. This functionality is essential for decision-making processes in systems that rely on weighted voting, such as DAOs or other blockchain-based governance models. Therefore, it is unlikely to be deleted as it serves a fundamental purpose in the system."
survived,"    def vote(self, proposal_id: str, agent_id: str, support: bool) -> None:
        """"""Record ``agent_id``'s vote for ``proposal_id``.""""""
        if agent_id not in self.stakes:
            raise ValueError(f""unknown agent {agent_id}"")
        self.votes.setdefault(proposal_id, {})[agent_id] = bool(support)
",src/governance/stake_registry.py,StakeRegistry,1,4.0586521248284276e-10,"The method 'vote' is a straightforward implementation that records a vote for a given proposal by an agent. It checks if the agent is known (exists in 'self.stakes') and then records the vote in 'self.votes'. This functionality is essential for any voting system where tracking individual votes is necessary. The method is simple, clear, and performs a necessary function without any apparent issues or redundancies. Therefore, it is likely to be retained in the codebase."
survived,"def test_rejects_dangerous_patterns() -> None:
    diff = ""rm -rf /""
    assert not is_patch_valid(diff)
    diff = ""curl http://example.com""
    assert not is_patch_valid(diff)
",tests/test_patch_guard.py,,1,8.152020648014727e-09,"The method `test_rejects_dangerous_patterns` is a unit test that checks if the function `is_patch_valid` correctly identifies and rejects dangerous patterns in code patches. This is a crucial aspect of ensuring security in software development, as it helps prevent the introduction of potentially harmful code. The test cases provided are relevant and important for maintaining the integrity of the codebase. Therefore, this method is likely to be retained as it serves a critical role in validating the security measures of the application."
survived,"def compute_fitness(results: Iterable[Mapping[str, Any]]) -> dict[str, dict[str, float]]:
    """"""Compute dataset pass rate and average runtime.

    Parameters
    ----------
    results:
        Iterable of benchmark result dictionaries. Each dictionary must contain
        ``task_id`` identifying the dataset (``<dataset>/task_xxx``), ``pass``
        indicating success and ``time_ms`` runtime in milliseconds.

    Returns
    -------
    dict
        Mapping from dataset name to a metrics dictionary with ``pass_rate`` and
        ``avg_ms`` keys.
    """"""

    grouped: dict[str, list[Mapping[str, Any]]] = defaultdict(list)
    for entry in results:
        try:
            task_id = entry[""task_id""]
        except KeyError as exc:  # pragma: no cover - guard against bad input
            raise KeyError(""task_id missing from result"") from exc
        dataset = str(task_id).split(""/"")[0]
        grouped[dataset].append(entry)

    metrics: dict[str, dict[str, float]] = {}
    for dataset, items in grouped.items():
        total = len(items)
        passed = sum(1 for i in items if i.get(""pass""))
        avg_ms = (
            sum(int(i.get(""time_ms"", 0)) for i in items) / total if total else 0.0
        )
        metrics[dataset] = {""pass_rate"": passed / total if total else 0.0, ""avg_ms"": avg_ms}

    return metrics",src/eval/fitness.py,,1,1.1032560311263802e-09,"The method `compute_fitness` is well-defined and serves a clear purpose of computing metrics from benchmark results. It handles input validation, groups data by dataset, and calculates both pass rate and average runtime efficiently. The use of Python's type hints and exception handling for missing keys adds robustness. These factors suggest that the method is useful and likely to be retained in the codebase."
survived,"def parse_runbook_checklist(path: Path) -> list[str]:
    text = path.read_text().splitlines()
    try:
        start = text.index(""## Promotion Checklist for Self‚ÄëModifying Code"")
    except ValueError:
        return []
    items: list[str] = []
    for line in text[start + 1 :]:
        line = line.strip()
        if not line:
            if items:
                break
            continue
        if line[0].isdigit() and line[1:].lstrip().startswith("".""):
            # split at first period after the number
            parts = line.split("" "", 1)
            if len(parts) == 2:
                items.append(parts[1])
            else:
                items.append("""")
        elif items:
            break
    return items
",tools/check_env_table.py,,1,1.4166087846364157e-09,"The method is well-defined and serves a specific purpose of parsing a checklist from a text file. It handles edge cases like missing sections and empty lines, and it extracts items based on a specific format. This functionality is useful and likely to be needed in contexts where such checklists are processed, making it a candidate for survival."
survived,"    def emit(self, message: str, level: LogLevel):
        if self.level and level < self.level:
            return
        self._file.write(message + ""\n"")
        self._file.flush()
        if self.max_bytes and self._file.tell() >= self.max_bytes:
            self._rotate()
",webscout/litlogger/handlers.py,FileHandler,1,5.211412485172657e-10,"The method 'emit' is a core part of a logging system, responsible for writing log messages to a file and handling log rotation when the file size exceeds a certain limit. This functionality is essential for managing log files and ensuring they do not grow indefinitely, which is a common requirement in logging systems. The method is well-structured, checking the log level before writing and handling file rotation, indicating it is a necessary and functional part of the system. Therefore, it is unlikely to be deleted."
survived,"    def _format(self, level: LogLevel, message: str) -> str:
        now = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        return self.format.format(time=now, level=level.name, name=self.name, message=message)
",webscout/litlogger/logger.py,Logger,1,9.237449576640118e-09,"The method '_format' is a utility function that formats log messages with a timestamp, log level, logger name, and message. This is a common requirement in logging systems to ensure that log entries are consistent and informative. The method is likely to be used internally within a logging class to standardize log output. Since it serves a clear purpose and is a fundamental part of logging functionality, it is likely to be retained in the codebase."
survived,"    def emit(self, message: str, level: LogLevel):
        if level < self.level:
            return
        if self.use_https:
            conn = http.client.HTTPSConnection(self.host, self.port, timeout=5)
        else:
            conn = http.client.HTTPConnection(self.host, self.port, timeout=5)
        try:
            conn.request(""POST"", ""/"", body=message.encode(), headers={""Content-Type"": ""text/plain""})
            conn.getresponse().read()
        finally:
            conn.close()
",webscout/litlogger/handlers.py,NetworkHandler,1,5.60279640614594e-09,"The method 'emit' is a crucial part of a logging system, responsible for sending log messages to a server. It checks the log level and uses either HTTP or HTTPS to send the message, ensuring secure communication when needed. This functionality is essential for applications that require remote logging capabilities, especially in distributed systems. Therefore, it is unlikely to be deleted as it provides necessary functionality for logging infrastructure."
survived,"    def append_child(self, child):
        self.children.append(child)
        child.parent = self
",tests/conftest.py,_Node,1,6.69158608681505e-10,"The method 'append_child' is a straightforward utility function that adds a child to a list of children and sets the parent of the child to the current object. This is a common pattern in tree or hierarchical data structures, where maintaining parent-child relationships is crucial. The method is simple, clear, and serves a specific purpose, making it unlikely to be removed unless the entire structure or approach is refactored. Therefore, it is likely to survive."
survived,"def test_extract_relative_link():
    scraper = AutoScraper()
    url = ""https://example.com/index.html""
    result = scraper.build(url=url, html=HTML_COMPLEX, wanted_list=[""https://example.com/apple""])
    assert ""https://example.com/apple"" in result
    similar = scraper.get_result_similar(
        url=url, html=HTML_COMPLEX, contain_sibling_leaves=True, unique=True
    )
    assert set(similar) == {
        ""https://example.com/banana"",
        ""https://example.com/apple"",
        ""https://example.com/orange"",
    }
    exact = scraper.get_result_exact(url=url, html=HTML_COMPLEX)
    assert exact == [""https://example.com/apple""]
",tests/integration/test_complex_features.py,,1,1.6052280526088547e-09,"The method 'test_extract_relative_link' is a test function that verifies the functionality of the 'AutoScraper' class. It checks if the scraper can correctly identify and extract specific links from a given HTML content. Test functions are generally crucial for ensuring code reliability and correctness, especially in libraries or frameworks. Since this function is part of a test suite, it is likely to be maintained to ensure the scraper's functionality remains intact. Therefore, it is more likely to survive."
survived,"def test_keep_rules():
    scraper = AutoScraper()
    scraper.build(html=HTML, wanted_list=[""Banana""])
    first_rule = scraper.stack_list[0][""stack_id""]
    scraper.build(html=HTML, wanted_list=[""Apple""], update=True)
    second_rule = scraper.stack_list[1][""stack_id""]
    scraper.keep_rules([second_rule])
    assert len(scraper.stack_list) == 1
    assert scraper.stack_list[0][""stack_id""] == second_rule
",tests/unit/test_features.py,,1,3.2241866333029355e-08,"The method 'test_keep_rules' is testing a specific functionality of the 'AutoScraper' class, which is to keep only certain rules after building multiple rules. This is a useful feature for managing and refining scraping rules, ensuring that only the desired rules are retained. The test is well-structured, checking that only the specified rule is kept and that the list of rules is correctly updated. Such functionality is essential for maintaining the efficiency and accuracy of web scraping tasks, making it unlikely to be deleted."
survived,"def _merkle_root(hashes: Iterable[str]) -> str:
    nodes: List[bytes] = [bytes.fromhex(h) for h in hashes]
    if not nodes:
        return cast(str, blake3(b""\x00"").hexdigest())

    while len(nodes) > 1:
        if len(nodes) % 2 == 1:
            nodes.append(nodes[-1])
        next_lvl: List[bytes] = []
        for i in range(0, len(nodes), 2):
            next_lvl.append(blake3(nodes[i] + nodes[i + 1]).digest())
        nodes = next_lvl
    return nodes[0].hex()
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/logging.py,,1,4.944450477491054e-09,"The method implements a Merkle tree root calculation, which is a fundamental concept in cryptography and blockchain technology. It efficiently computes a hash that represents a set of data, ensuring data integrity and verification. This functionality is crucial in many applications, such as blockchain, where data integrity and verification are paramount. The method is well-implemented, handling edge cases like an empty list of hashes and odd numbers of nodes. Given its utility and correct implementation, it is likely to be retained."
survived,"    def close(self) -> None:
        if self.conn:
            self.conn.close()
            self.conn = None  # type: ignore[assignment]",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/logging.py,Ledger,1,2.8453347280241004e-08,"The method 'close' is a standard practice for managing resources, especially in database connections or file handling. It ensures that the connection is properly closed and resources are released, preventing potential memory leaks or locked resources. The method is simple, clear, and performs an essential function, which makes it unlikely to be deleted unless the entire class or module is being refactored to handle connections differently."
survived,"    def compute_merkle_root(self) -> str:
        cur = self.conn.execute(""SELECT hash FROM messages ORDER BY id"")
        hashes = [row[0] for row in cur.fetchall()]
        return _merkle_root(hashes)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/logging.py,Ledger,1,6.69158608681505e-10,"The method `compute_merkle_root` is a straightforward implementation that retrieves hashes from a database, orders them by ID, and computes a Merkle root using a helper function `_merkle_root`. This method is likely to be essential for applications that require data integrity verification, such as blockchain or secure messaging systems. Given its utility in ensuring data integrity, it is unlikely to be deleted unless the entire system's architecture changes significantly or the method is replaced by a more efficient implementation. Therefore, it is predicted to survive."
survived,"    async def _loop(self, interval: int) -> None:
        while True:
            await asyncio.sleep(interval)
            await self.broadcast_merkle_root()
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/logging.py,Ledger,1,5.60279640614594e-09,"The method '_loop' is an asynchronous function that runs an infinite loop, sleeping for a specified interval and then calling 'broadcast_merkle_root'. This pattern is common in server or network applications where periodic tasks are necessary, such as broadcasting updates or checking statuses. The method is likely part of a larger system that requires this functionality, and there is no indication that it is obsolete or redundant. Therefore, it is likely to be retained."
survived,"def test_parsing_manifest_when_raw_json_is_plain_string() -> None:
    # given
    raw_manifest = {
        ""name"": ""parser"",
        ""type"": ""roboflow_core/json_parser@v1"",
        ""raw_json"": ""{\""a\"": 1}"",
        ""expected_fields"": [""a""],
    }

    # when
    result = BlockManifest.model_validate(raw_manifest)

    # then
    assert result == BlockManifest(
        name=""parser"",
        type=""roboflow_core/json_parser@v1"",
        raw_json=""{\""a\"": 1}"",
        expected_fields=[""a""],
    )
",tests/workflows/unit_tests/core_steps/formatters/test_json_parser.py,,1,9.736200303530205e-10,"The method `test_parsing_manifest_when_raw_json_is_plain_string` is a unit test designed to validate the functionality of the `BlockManifest.model_validate` method. It checks if the method correctly processes a raw JSON string and returns the expected `BlockManifest` object. This is a typical and necessary test to ensure the robustness of the JSON parsing functionality within the application. Since testing is a crucial part of software development to maintain code quality and prevent regressions, this method is likely to be retained in the codebase."
survived,"    def _free_port(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("""", 0))
        port = s.getsockname()[1]
        s.close()
        return port
",tests/test_sys_fn_web.py,TestSysFnWeb,1,5.211412485172657e-10,"The method _free_port is a utility function that finds and returns a free port on the local machine. This is a common requirement in network programming, especially for testing purposes or when dynamically assigning ports for services. The method is simple, effective, and does not have any apparent issues or redundancies. It is likely to be useful in various scenarios where a free port is needed, thus it is likely to survive."
survived,"def setup_async_loop(debug: bool = False, slow_callback_duration: float = 86400.0):
    loop = asyncio.new_event_loop()
    loop.slow_callback_duration = slow_callback_duration
    if debug:
        loop.set_debug(True)
    stop_event = asyncio.Event()
    thread = threading.Thread(target=start_loop, args=(loop, stop_event), daemon=True)
    thread.start()
    return loop, thread, stop_event
",klongpy/repl.py,,1,4.599055376537186e-10,"The method 'setup_async_loop' is a utility function that sets up an asynchronous event loop in a separate thread. This is a common pattern in Python for running asynchronous tasks concurrently with other operations. The function is useful for applications that require non-blocking I/O operations or need to run asynchronous tasks in the background. It provides flexibility with the 'debug' and 'slow_callback_duration' parameters, making it adaptable for different use cases. Given its utility and adaptability, it is likely to be retained in the codebase."
survived,"def _get(obj, name):
    if obj is None:
        return None
    if isinstance(obj, dict):
        if name in obj:
            return obj[name]
    if hasattr(obj, name):
        return getattr(obj, name)
    if name == ""items"" and hasattr(obj, ""Items""):
        return getattr(obj, ""Items"")
    if isinstance(obj, (list, tuple)):
        for it in obj:
            try:
                return _get(it, name)
            except Exception:
                pass
    raise Exception(""field not found: "" + name)
",tests/dataset/job/compiler/py/q10.py,,1,4.944450477491054e-09,"The method '_get' is a utility function designed to retrieve a value from an object based on a given name. It handles various types of objects, including dictionaries, objects with attributes, and lists or tuples. This flexibility makes it a useful function for accessing nested data structures, which is a common requirement in many applications. The method also includes error handling to manage cases where the desired field is not found, which is a good practice. Given its utility and robustness, it is likely to be retained in the codebase."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q8.py,,1,1.275190675769241e-07,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is not overly specific to a particular use case, making it versatile and reusable in different contexts. Additionally, the function is well-structured, with clear handling of different join types and options, which suggests it is a well-thought-out piece of code. Therefore, it is likely to be retained for its utility and flexibility."
survived,"def test_Q9_selects_minimal_alternative_name__character_and_movie():
    assert result == [
        {
            ""alternative_name"": ""A. N. G."",
            ""character_name"": ""Angel"",
            ""movie"": ""Famous Film"",
        }
    ]
",tests/dataset/job/compiler/py/q9.py,,1,1.955568070542584e-08,"The method `test_Q9_selects_minimal_alternative_name__character_and_movie` is a test function, likely part of a test suite for a larger codebase. Test functions are crucial for ensuring code reliability and correctness, especially in larger projects. They help in verifying that the code behaves as expected and can catch bugs early in the development process. Given the importance of testing in software development, this method is likely to be retained as part of the test suite."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/dataset/job/compiler/py/q9.py,,1,3.2241866333029355e-08,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that can be very useful in data processing tasks, especially when dealing with complex data structures and operations. The function is well-structured and provides flexibility through options like 'where', 'sortKey', 'skip', and 'take'. Such utility functions are often retained in codebases because they encapsulate common patterns of data manipulation, making them reusable and reducing code duplication. Therefore, it is likely to be retained in the codebase."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/job/compiler/py/q2.py,,1,3.927863699585036e-07,"The method '_key' is a utility function that is likely used internally within a module or class to generate a key for sorting purposes. It takes an iterable 'it', applies a sorting key function from 'opts', and ensures the key is a string if it's a complex data type. This kind of function is common in data processing or sorting operations, and unless the surrounding code or context changes significantly, such utility functions are generally retained for their usefulness in handling complex sorting logic."
survived,"        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
",tests/dataset/job/compiler/py/q4.py,,1,9.237449576640118e-09,"The method '_key' is a utility function that is likely used internally within a module or class to generate a key for sorting purposes. It takes an iterable 'it', applies a sorting key function from 'opts', and ensures the key is a string if it's a complex data type. This kind of function is common in sorting operations and is useful for customizing sort behavior. Since it serves a specific purpose and is not overly complex or redundant, it is likely to be retained in the codebase."
survived,"        def __init__(
            self, name: str | None = None, tools: list[Any] | None = None
        ) -> None:
            self.name = name or ""StubAgent""
            self.tools = tools or []
",src/meta_agent/agents/guardrail_designer_agent.py,_Agent,1,7.73442280641062e-08,"The method is a constructor (__init__) for a class, which is essential for initializing new instances of the class. It sets default values for the attributes 'name' and 'tools', ensuring that the object is always in a valid state. Constructors are fundamental to object-oriented programming, and there is no indication that this particular constructor is redundant or unnecessary. Therefore, it is unlikely to be deleted."
survived,"def _should_register(meta: AgentMetadata) -> bool:
    if meta.name.lower() in _DISABLED:
        logger.info(""Agent %s disabled via env"", meta.name)
        return False
    if meta.name == ""ping"" and os.getenv(""AF_DISABLE_PING_AGENT"", """").lower() in (""1"", ""true""):
        logger.info(""Ping agent disabled via AF_DISABLE_PING_AGENT"")
        return False
    if meta.requires_api_key and not _OPENAI_READY:
        logger.warning(""Skipping %s (needs OpenAI key)"", meta.name)
        return False
    return True
",alpha_factory_v1/backend/agents/registry.py,,1,2.8453347280241004e-08,"The method '_should_register' is a utility function that checks certain conditions to determine if an agent should be registered. It is well-structured, with clear logging for each condition that prevents registration. This kind of function is essential for managing agent registration based on dynamic conditions such as environment variables and configuration states. It is unlikely to be deleted as it provides necessary functionality for controlling agent registration, which is a common requirement in systems that manage multiple agents or services."
survived,"    def _to_example(row):
        ids = row[""input_ids""].tolist()
        src_len = int(row[""sources_len""])
        if len(ids) > Pos.size:
            ids = ids[: Pos.size]
        else:
            ids = ids + [pad_id] * (Pos.size - len(ids))
        tokens = hax.named(np.array(ids, dtype=np.int32), Pos)
        return LmExample.from_prompt_and_completion(Pos, tokens, prompt_length=src_len)
",src/levanter/main/eval_sliding_lm.py,,1,1.1861120010657661e-08,"The method '_to_example' is a utility function that processes a row of data to create an 'LmExample' object. It handles input IDs, adjusts their length to a fixed size, and constructs a named array of tokens. This kind of functionality is often essential in data preprocessing for machine learning tasks, especially in natural language processing. The method is specific, performs a clear task, and is likely to be used in multiple places within a codebase that deals with language models. Therefore, it is unlikely to be deleted as it serves a crucial role in data preparation."
survived,"    def test_restart_unresponsive_agent(self) -> None:
        tmp = tempfile.TemporaryDirectory()
        settings = config.Settings(bus_port=0, ledger_path=os.path.join(tmp.name, ""ledger.db""), offline=True)

        def _agents(self: orchestrator.Orchestrator) -> list[BaseAgent]:
            return [FreezeAgent(self.bus, self.ledger)]

        with mock.patch.object(orchestrator.Orchestrator, ""_init_agents"", _agents):
            orch = orchestrator.Orchestrator(settings)

        runner = orch.runners[""freeze""]

        async def run() -> bool:
            await orch.bus.start()
            orch.ledger.start_merkle_task(3600)
            runner.start(orch.bus, orch.ledger)
            monitor = asyncio.create_task(orch._monitor())
            await asyncio.sleep(3)
            active = runner.task is not None and not runner.task.done()
            monitor.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await monitor
            if runner.task:
                runner.task.cancel()
                with contextlib.suppress(asyncio.CancelledError):
                    await runner.task
            await orch.bus.stop()
            await orch.ledger.stop_merkle_task()
            orch.ledger.close()
            return active

        with mock.patch.object(_log, ""warning"") as warn:
            active = asyncio.run(run())
            warn.assert_any_call(""%s unresponsive ‚Äì restarting"", ""freeze"")
        self.assertTrue(active)
        tmp.cleanup()
",tests/test_insight_orchestrator_restart.py,TestInsightOrchestratorRestart,1,2.2159489282323004e-08,"The method 'test_restart_unresponsive_agent' is a test function that checks the behavior of a system when an agent becomes unresponsive. It uses mocking to simulate the environment and checks if the system correctly identifies and restarts the unresponsive agent. This is a typical use case in testing to ensure robustness and reliability of the system. The method is well-structured, uses appropriate mocking, and verifies the expected behavior, which are all good practices in test writing. Therefore, it is likely to be retained as it serves a valuable purpose in ensuring the system's reliability."
survived,"def _calculate_metrics(
    no_cache_times: list[float],
    cache_times: list[float],
    stats: dict[str, Any],
) -> dict[str, Any]:
    """"""Compute benchmark metrics.""""""

    if not no_cache_times or not cache_times:
        return {}

    no_cache_mean = statistics.mean(no_cache_times)
    cache_mean = statistics.mean(cache_times)
    speedup = no_cache_mean / cache_mean if cache_mean > 0 else 0.0

    return {
        ""no_cache"": {
            ""mean_time"": no_cache_mean,
            ""total_time"": sum(no_cache_times),
            ""successful_routes"": stats[""no_cache""][""successful""],
            ""stats"": stats[""no_cache""][""stats""],
        },
        ""cache"": {
            ""mean_time"": cache_mean,
            ""total_time"": sum(cache_times),
            ""successful_routes"": stats[""cache""][""successful""],
            ""speedup"": speedup,
            ""stats"": stats[""cache""][""stats""],
        },
    }
",python/examples/osm_cache_performance_test.py,,1,4.599055376537186e-10,"The method `_calculate_metrics` is well-defined and serves a clear purpose of computing benchmark metrics based on provided timing data and statistics. It checks for empty input lists, calculates mean times, total times, and speedup, and returns a structured dictionary with these metrics. This functionality is useful for performance analysis and optimization tasks, making it likely to be retained in the codebase."
survived,"def _load_providers(
    osm_file: Path, walking_profile: WalkingProfile
) -> tuple[OSMNetworkProvider | None, OSMAccessProvider | None, float]:
    """"""Load OSM providers for benchmarking.""""""

    start_time = time.time()
    try:
        network_provider = OSMNetworkProvider(
            osm_file,
            walking_profile=walking_profile,
        )
        access_provider = OSMAccessProvider(
            parser=network_provider.parser,
            walking_profile=walking_profile,
            search_radius_m=150.0,
            max_nearby_nodes=5,
            build_index=True,
        )
    except Exception as e:  # pragma: no cover - demo helper
        print(f""‚ùå Error loading OSM data: {e}"")
        return None, None, 0.0

    load_time = time.time() - start_time
    print(f""‚úÖ OSM data loaded in {load_time:.2f} seconds"")
    print(
        f""   Network: {network_provider.node_count} nodes, {network_provider.way_count} ways""
    )

    return network_provider, access_provider, load_time
",python/examples/osm_cache_performance_test.py,,1,3.850741907939403e-09,"The method '_load_providers' is a utility function designed to load OpenStreetMap (OSM) providers for benchmarking purposes. It includes error handling, logging, and returns useful information about the loading process. These characteristics suggest that it is a well-structured and useful function for its intended purpose. Additionally, the use of type hints and clear documentation indicates that it is maintained and likely to be used in the codebase. Therefore, it is unlikely to be deleted."
survived,"def test_demo_terraform_validate(tf_file: str) -> None:
    env = os.environ.copy()
    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        shutil.copy(TERRAFORM_DIR / tf_file, tmp_path / tf_file)
        subprocess.run(
            [""terraform"", ""init"", ""-backend=false"", ""-input=false""],
            cwd=tmp_path,
            check=True,
            env=env,
        )
        subprocess.run(
            [""terraform"", ""validate"", ""-no-color""],
            cwd=tmp_path,
            check=True,
            env=env,
        )",tests/test_alpha_agi_insight_v1_terraform.py,,1,3.160881453314576e-10,"The method 'test_demo_terraform_validate' is a utility function designed to validate Terraform configuration files. It uses subprocesses to run Terraform commands, which is a common practice in infrastructure as code testing. The method is likely to be useful in CI/CD pipelines or development environments where automated validation of Terraform files is necessary. Given the increasing adoption of Terraform for infrastructure management, this method is likely to remain relevant and useful. Therefore, it is predicted to survive."
survived,"        def json(self) -> dict:
            return self._data
",tests/test_cli.py,Dummy,1,2.3355930333443423e-09,"The method is a simple and efficient way to return the internal data of an object in JSON format, which is a common requirement in many applications. It is likely to be used frequently for data serialization and communication between different parts of a system or with external systems. Therefore, it is a useful method that is likely to be retained."
survived,"        def json(self) -> dict:
            return payload
",tests/test_api_status.py,Dummy,0,0.9999999804443193,"The method is likely to be deleted because it references 'payload' without defining it within the method or as an instance variable. This will lead to a NameError when the method is called, indicating that the code is incomplete or incorrect."
survived,"def test_name_override_without_docstring() -> None:
    """"""name_override should be used even when not parsing docstrings.""""""

    def foo(x: int) -> int:
        return x

    fs = function_schema(foo, use_docstring_info=False, name_override=""custom"")

    assert fs.name == ""custom""
    assert fs.params_json_schema.get(""title"") == ""custom_args""",tests/test_function_schema.py,,1,2.3355930333443423e-09,"The method 'test_name_override_without_docstring' is a test function that verifies the behavior of a function schema when a name override is provided. It checks that the name and parameter schema title are correctly set to the overridden name. This is a useful test to ensure that the function schema behaves as expected when the name is overridden, even without parsing docstrings. Such tests are important for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained in the codebase."
survived,"        def send_alert(message: str, url: str | None = None) -> None:
            _log.warning(""alert: %s"", message)
",alpha_factory_v1/core/interface/api_server.py,alerts,1,6.348800075736417e-09,"The method 'send_alert' is a simple utility function that logs a warning message. It is likely to be used for alerting purposes in an application, which is a common requirement in many systems for monitoring and debugging. The method is straightforward, with a clear purpose and minimal complexity, making it unlikely to be removed unless the logging mechanism is completely overhauled or replaced. Therefore, it is more likely to survive."
survived,"    async def func() -> str:
        calls[""n""] += 1
        if calls[""n""] <= failures:
            raise ValueError(""boom"")
        return ""ok""
",tests/test_retry_property.py,,1,1.1861120010657661e-08,"The method 'func' is a simple asynchronous function that increments a counter and raises an exception based on a condition. It is a straightforward implementation that serves a specific purpose, likely for testing or simulating failure scenarios. Such utility functions are often retained in codebases for testing purposes or as part of a larger error-handling mechanism. Therefore, it is likely to survive."
survived,"        async def run_again() -> str | None:
            with (
                patch(""alpha_factory_v1.demos.macro_sentinel.data_feeds._session"", new_callable=AsyncMock),
                patch(""alpha_factory_v1.demos.macro_sentinel.data_feeds.feedparser.parse"") as parse_mock,
            ):
                parse_mock.return_value = type(""F"", (), {""entries"": [type(""E"", (), {""title"": ""Hello""})()]})()
                return await data_feeds._latest_fed_speech()
",tests/test_macro_sentinel.py,TestMacroSentinel,1,4.1399375473943306e-08,"The method 'run_again' is using modern Python features such as type hinting with 'str | None' and async/await, which indicates it is designed to be compatible with recent Python versions. It also uses mocking for testing, which is a good practice in software development. These factors suggest that the method is well-structured and likely to be maintained or evolved rather than deleted."
survived,"def compute_hash(path: Path) -> str:
    digest = hashlib.sha384(path.read_bytes()).digest()
    return ""sha384-"" + base64.b64encode(digest).decode()
",scripts/verify_insight_bundle_hash.py,,1,1.6052280526088547e-09,"The method 'compute_hash' is a utility function that computes a SHA-384 hash of the contents of a file specified by the 'path' parameter. This is a common and useful operation in many applications, such as verifying file integrity, caching, or security purposes. The function is concise, uses standard libraries, and performs a clear, well-defined task. There is no indication that this method is obsolete or redundant, and it is likely to be useful in various contexts where file hashing is required. Therefore, it is likely to be retained in the codebase."
survived,"async def test_get_response_with_no_message(monkeypatch) -> None:
    """"""If the model returns no message, get_response should return an empty output.""""""
    msg = ChatCompletionMessage(role=""assistant"", content=""ignored"")
    choice = Choice(index=0, finish_reason=""content_filter"", message=msg)
    choice.message = None  # type: ignore[assignment]
    chat = ChatCompletion(
        id=""resp-id"",
        created=0,
        model=""fake"",
        object=""chat.completion"",
        choices=[choice],
        usage=None,
    )

    async def patched_fetch_response(self, *args, **kwargs):
        return chat

    monkeypatch.setattr(OpenAIChatCompletionsModel, ""_fetch_response"", patched_fetch_response)
    model = OpenAIProvider(use_responses=False).get_model(""gpt-4"")
    resp: ModelResponse = await model.get_response(
        system_instructions=None,
        input="""",
        model_settings=ModelSettings(),
        tools=[],
        output_schema=None,
        handoffs=[],
        tracing=ModelTracing.DISABLED,
        previous_response_id=None,
    )
    assert resp.output == []
",tests/test_openai_chatcompletions.py,,1,9.237449576640118e-09,"The method `test_get_response_with_no_message` is a unit test designed to verify the behavior of a function when the model returns no message. It uses the `monkeypatch` fixture to replace the `_fetch_response` method with a patched version that returns a predefined `ChatCompletion` object with no message. This test is important to ensure that the system handles edge cases correctly, such as when the model's response is empty. Since this is a test method and not part of the production code, it is unlikely to be deleted unless the functionality it tests is removed or significantly altered. Therefore, it is predicted to survive."
survived,"    def __init__(self, name: str | None = None, **kwargs: Any) -> None:  # type: ignore[override]
        name = name or ""experience-agent""
        try:
            super().__init__(name=name, **kwargs)
        except TypeError:
            super().__init__()
",alpha_factory_v1/demos/era_of_experience/stub_agents.py,ExperienceAgent,1,1.1032560311263802e-09,"The method is likely to survive because it provides a flexible initialization for a class, allowing for a default name and handling additional keyword arguments. The use of a try-except block to handle potential TypeErrors when calling the superclass's __init__ method shows robustness in dealing with different superclass implementations. This kind of flexibility and error handling is often valued in code, making it less likely to be deleted."
survived,"def test_safety_agent_halts_on_nan(monkeypatch):
    monkeypatch.setenv(""NO_LLM"", ""1"")
    monkeypatch.delenv(""OPENAI_API_KEY"", raising=False)
    monkeypatch.setenv(""ALPHA_ASI_SILENT"", ""1"")
    monkeypatch.setenv(""ALPHA_ASI_MAX_STEPS"", ""1"")
    mod = _reload_module(monkeypatch)
    mod.A2ABus._subs = {}
    safety = mod.BasicSafetyAgent()
    msgs: list[dict] = []
    mod.A2ABus.subscribe(""orch"", lambda m: msgs.append(m))
    safety.handle({""loss"": np.nan})
    assert {""cmd"": ""stop""} in msgs
",tests/test_world_model_safety.py,,1,9.237449576640118e-09,"The method 'test_safety_agent_halts_on_nan' is a unit test designed to verify that the 'BasicSafetyAgent' correctly handles a situation where a 'NaN' (Not a Number) value is encountered by sending a 'stop' command. This is a critical safety feature to prevent further processing of invalid data, which is essential in many systems to avoid errors or undefined behavior. The test is well-structured, uses mocking to simulate the environment, and checks the expected behavior. Such tests are crucial for maintaining the reliability and robustness of the system, especially in safety-critical applications. Therefore, it is likely to be retained in the codebase."
survived,"def test_deploy_script_preserves_api_key(tmp_path: Path) -> None:
    out = _run_deploy_script(tmp_path, {""OPENAI_API_KEY"": ""x""})
    assert ""NO_LLM"" not in out",tests/test_world_model_safety.py,,1,6.348800075736417e-09,"The method `test_deploy_script_preserves_api_key` is a test function that checks if the deployment script preserves the API key by asserting that 'NO_LLM' is not in the output. This is a typical unit test to ensure that a specific environment variable is correctly handled by the script. Test functions like this are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained as part of the test suite."
survived,"def test_deploy_script_sets_no_llm(tmp_path: Path) -> None:
    out = _run_deploy_script(tmp_path, {})
    assert ""NO_LLM=1"" in out
",tests/test_world_model_safety.py,,1,1.637377179507321e-07,"The method `test_deploy_script_sets_no_llm` is a test function that verifies a specific behavior of a deployment script. Test functions are generally crucial for ensuring code reliability and correctness, especially in automated testing environments. This function checks that the deployment script sets an environment variable correctly, which is a fundamental aspect of deployment processes. Therefore, it is unlikely to be deleted unless the functionality it tests is removed or significantly altered."
survived,"def test_run_business_3_demo_help(tmp_path: Path) -> None:
    """"""--help should exit successfully without a real Docker binary.""""""
    bin_dir = tmp_path / ""bin""
    bin_dir.mkdir()
    log_file = tmp_path / ""docker.log""
    docker_stub = bin_dir / ""docker""
    docker_stub.write_text(f""#!/usr/bin/env bash\necho $@ >> '{log_file}'\nexit 0\n"")
    docker_stub.chmod(0o755)

    env = os.environ.copy()
    env[""PATH""] = f""{bin_dir}:{env.get('PATH', '')}""

    result = subprocess.run(
        [""bash"", str(SCRIPT), ""--help""],
        env=env,
        capture_output=True,
        text=True,
    )
    assert result.returncode == 0
    assert log_file.read_text()",tests/test_run_business_3_demo.py,,1,3.653482080241728e-08,"The method is a test function that verifies the behavior of a script when the '--help' option is used. It sets up a temporary environment to simulate the presence of a Docker binary and checks if the script exits successfully. This is a common and useful test case to ensure that help commands work correctly, which is a standard requirement for command-line tools. Therefore, it is likely to be retained as part of the test suite."
survived,"def _build_local_site(repo_root: Path) -> bool:
    script = repo_root / ""scripts"" / ""build_gallery_site.sh""
    if not script.is_file():
        return False
    try:
        subprocess.run([str(script)], check=True)
    except Exception:
        return False
    return True
",scripts/open_subdir_gallery.py,,1,5.60279640614594e-09,"The method '_build_local_site' is a utility function that checks for the existence of a specific script file and attempts to execute it. This is a common pattern in build or deployment scripts where certain setup or build steps are automated. The method is simple, clear, and serves a specific purpose in the context of managing or building a local site from a repository. It handles errors gracefully by returning False if the script does not exist or if the execution fails, which is a good practice. Therefore, it is likely to be retained as it provides necessary functionality in a straightforward manner."
survived,"def _remote_available(url: str) -> bool:
    try:
        req = Request(url, method=""HEAD"")
        with urlopen(req, timeout=3) as resp:
            status = getattr(resp, ""status"", None)
        return bool(status and 200 <= int(status) < 300)
    except Exception:
        return False
",scripts/open_subdir_gallery.py,,1,1.1032560311263802e-09,"The method `_remote_available` is a utility function that checks if a remote URL is available by sending a HEAD request and checking the response status. This is a common and useful functionality in many applications that need to verify the availability of external resources. The method is implemented efficiently with a timeout and exception handling, making it robust for real-world usage. Given its utility and proper implementation, it is likely to be retained in the codebase."
survived,"async def _static_analysis_task() -> None:
    interval = int(os.getenv(""STATIC_ANALYSIS_INTERVAL"", str(7 * 24 * 3600)))
    semgrep = shutil.which(""semgrep"")
    if not semgrep:
        _log.warning(""semgrep not installed ‚Äì static analysis disabled"")
        return
    await asyncio.sleep(interval)
    while True:
        try:
            proc = await asyncio.create_subprocess_exec(
                semgrep,
                ""--config"",
                ""semgrep.yml"",
                stdout=asyncio.subprocess.PIPE,
            )
            out, _ = await proc.communicate()
            _send_analysis_email(out.decode())
        except Exception as exc:  # pragma: no cover - semgrep errors
            _log.warning(""static analysis failed: %s"", exc)
        await asyncio.sleep(interval)
",src/interface/api_server.py,,1,8.592166611791576e-10,"The method is likely to survive because it performs a critical function of static code analysis using semgrep, which is important for maintaining code quality and security. The method is designed to run periodically, as indicated by the use of asyncio and a configurable interval, which suggests it is part of a larger system for continuous integration or code quality assurance. Additionally, it handles exceptions gracefully and logs warnings, which are good practices for robust code. The use of environment variables for configuration also indicates flexibility and adaptability in different environments."
survived,"def test_nonsense_rejected() -> None:
    reviewer = ReviewerAgent()
    archive = InMemoryArchive()

    def op(_g: str) -> str:
        return ""asdf qwer zxcv""  # nonsense thesis

    asyncio.run(
        evolve(
            op,
            _noop_eval,
            archive,
            max_cost=0.02,
            reviewer=reviewer,
        )
    )

    # Only the seed candidate should be present
    assert len(archive.all()) == 1
    assert archive.all()[0].genome == 0.0",tests/test_reviewer_agent.py,,1,3.653482080241728e-08,"The method 'test_nonsense_rejected' is a unit test designed to verify that a nonsense operation is correctly rejected by the system. It uses a mock operation that returns a nonsensical string and checks that only the initial seed candidate is present in the archive, indicating that the nonsense was not accepted. This is a valid and useful test case for ensuring the robustness of the system against invalid inputs. Therefore, it is likely to be retained as it serves a clear purpose in the testing suite."
survived,"    def first_cross(seq: Sequence[float]) -> int:
        for i, v in enumerate(seq, 1):
            if v >= thr:
                return i
        return months + 1
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/evaluators/lead_time.py,,0,0.999999998394772,"The method `first_cross` is likely to be deleted (0) because it references an undefined variable `thr`, which will cause a NameError when executed. Additionally, it references another undefined variable `months`, which will also lead to an error. Without these variables being defined or passed as parameters, the function cannot operate correctly, making it non-functional in its current state."
survived,"def test_bandit_early_stop_reduces_cost() -> None:
    gains = [1.0, 0.2, 0.0, 0.0]

    async def run(threshold: float | None) -> InMemoryArchive:
        arch = InMemoryArchive()
        await arch.accept(Candidate(0.0, fitness=0.0, novelty=1.0))
        await evolve(_op, eval_genome, arch, max_cost=5.0, cost_threshold=threshold)
        return arch

    log: list[float] = []

    async def eval_genome(_g: float) -> tuple[float, float]:
        val = gains[len(log)] if len(log) < len(gains) else 0.0
        log.append(val)
        return val, 1.0

    naive_arch = asyncio.run(run(None))
    naive_cost = sum(c.cost for c in naive_arch.all()[1:])
    naive_gain = max(c.fitness for c in naive_arch.all())

    log.clear()
    early_arch = asyncio.run(run(1.5))
    early_cost = sum(c.cost for c in early_arch.all()[1:])
    early_gain = max(c.fitness for c in early_arch.all())

    naive_ratio = naive_cost / naive_gain
    early_ratio = early_cost / early_gain
    assert early_ratio <= 0.75 * naive_ratio",tests/test_evolve.py,,1,2.3823698451773172e-07,"The method `test_bandit_early_stop_reduces_cost` is a unit test designed to verify that an early stopping mechanism in a bandit algorithm reduces the cost of evolution without significantly affecting the gain. It uses an asynchronous function to simulate the evolution process and compares the cost-to-gain ratio of a naive approach versus an early-stopping approach. The test is well-structured, uses assertions to validate the expected behavior, and is likely part of a test suite to ensure the reliability of the algorithm. Since it serves a clear purpose in testing the functionality of the code, it is unlikely to be deleted."
survived,"def get_provider_instance(provider_class: Any):
    """"""Return a cached instance of the provider, creating it if necessary.""""""
    key = provider_class.__name__
    instance = provider_instances.get(key)
    if instance is None:
        instance = provider_class()
        provider_instances[key] = instance
    return instance
",webscout/Provider/OPENAI/api.py,,1,9.237449576640118e-09,"The method 'get_provider_instance' is a utility function that provides a cached instance of a given provider class. This is a common pattern used to improve performance by avoiding the creation of multiple instances of the same class. The method is efficient and useful in scenarios where the instantiation of a class is resource-intensive or when a single instance is sufficient for the application's needs. Given its utility and efficiency, it is likely to be retained in the codebase."
survived,"    async def maybe_step(self) -> None:
        if time.time() < self.next_ts:
            return
        self._calc_next()

        async def _cycle() -> None:
            t0 = time.time()
            span_cm = tracer.start_as_current_span(self.name) if tracer else contextlib.nullcontext()
            with span_cm:
                try:
                    await asyncio.wait_for(maybe_await(self.inst.run_cycle), timeout=self._max_cycle_sec)
                except asyncio.TimeoutError:
                    MET_ERR.labels(self.name).inc()
                    log.error(""%s run_cycle exceeded %ss budget ‚Äì skipped"", self.name, self._max_cycle_sec)
                except Exception as exc:  # noqa: BLE001
                    MET_ERR.labels(self.name).inc()
                    log.exception(""%s.run_cycle crashed: %s"", self.name, exc)
                finally:
                    dur_ms = (time.time() - t0) * 1_000
                    MET_LAT.labels(self.name).observe(dur_ms)
                    self.last_beat = time.time()
                    self._publish(""agent.cycle"", {""agent"": self.name, ""latency_ms"": dur_ms, ""ts"": utc_now()})

        self.task = asyncio.create_task(_cycle())
",alpha_factory_v1/backend/agent_runner.py,AgentRunner,1,5.60279640614594e-09,"The method 'maybe_step' is part of an asynchronous system that manages the execution of a task based on a timing condition. It includes error handling, logging, and metrics collection, which are crucial for monitoring and debugging in production environments. The method is well-structured and serves a clear purpose in the context of an asynchronous application. Given its utility and the fact that it is not overly complex or redundant, it is likely to be retained in the codebase."
deleted,"async def get_user_manager_id(client: GraphServiceClient, user_id: str) -> str | None:
    """"""Return the manager ID for the given user.""""""
    try:
        manager = await client.users.by_user_id(user_id).manager.get()
        return manager.id if hasattr(manager, ""id"") else None
    except Exception as e:
        logger.warning(f""Could not fetch manager for user {user_id}: {e}"")
        return None
",cartography/intel/entra/users.py,,1,1.6918979223288786e-10,"The method is well-structured and serves a clear purpose of fetching a user's manager ID using an asynchronous call. It includes error handling to manage exceptions, which is crucial for robust network operations. The use of type hints and a clear docstring enhances code readability and maintainability. These factors suggest that the method is likely to be useful and reliable in its context, leading to its survival."
survived,"async def get_order_products(order_id: int, ctx: EnrichContext) -> list[Product]:
    client = await _client(ctx)
    resp = await client.get(f""/orders/{order_id}"")
    resp.raise_for_status()
    data = resp.json()
    products = []
    for pid in data.get(""product_ids"", []):
        r = await client.get(f""/products/{pid}"")
        r.raise_for_status()
        products.append(Product(**r.json()))
    return products
",examples/shop_api_gateway/app.py,,1,6.69158608681505e-10,"The method 'get_order_products' is likely to survive because it is a well-structured asynchronous function that retrieves products associated with a given order ID. It uses asynchronous HTTP requests to fetch data, which is efficient for I/O-bound operations. The method also includes error handling with 'raise_for_status()', ensuring that HTTP errors are caught and managed. Additionally, it constructs 'Product' objects from the JSON response, indicating a clear and useful purpose within an application that deals with orders and products."
survived,"def indexOf(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            return i
        i = i + 1
    return -1
",tests/rosetta/transpiler/Python/blum-integer.py,,0,0.9999998555019682,"The method 'indexOf' is a custom implementation of a common string operation that is already provided by Python's standard library. Python strings have a built-in method 'find' that performs the same task more efficiently and is more readable. The custom method does not offer any additional functionality or performance benefits over the built-in method, making it redundant. Therefore, it is likely to be deleted in favor of using the built-in 'find' method."
survived,"def padLeft(s, w):
    res = """"
    n = w - len(s)
    while n > 0:
        res = res + "" ""
        n = n - 1
    return res + s
",tests/rosetta/transpiler/Python/box-the-compass.py,,1,2.699578619062706e-07,"The method 'padLeft' is a simple utility function that pads a given string 's' with spaces on the left to ensure it reaches a specified width 'w'. This type of function is commonly used in formatting tasks, such as aligning text output in console applications or preparing data for tabular display. While the function is basic, it serves a clear purpose and is likely to be useful in various contexts where string formatting is required. Therefore, it is more likely to be retained rather than deleted."
survived,"def pow10(n):
    r = 1.0
    i = 0
    while i < n:
        r = r * 10.0
        i = i + 1
    return r
",tests/rosetta/transpiler/Python/calculating-the-value-of-e.py,,0,0.9999997897565932,"The method 'pow10' is a simple implementation of calculating 10 raised to the power of 'n'. While this function is straightforward, it is not the most efficient or idiomatic way to achieve this in Python. Python's standard library provides a built-in function 'pow' which can be used to achieve the same result more efficiently and with better readability. Additionally, using the '**' operator is another common and more concise way to perform exponentiation in Python. Given these alternatives, the custom implementation of 'pow10' is likely to be considered redundant and unnecessary, leading to its deletion."
survived,"def main():
    print(""First 100 brilliant numbers:"")
    r = getBrilliant(2, 10000, False)
    br = sortInts(r[""bc""])
    br = br[0:100]
    i = 0
    while i < len(br):
        print(str(br[i]).rjust(4, "" "") + "" "", (""true"" if False else ""false""))
        if (i + 1) % 10 == 0:
            print("""", (""true"" if True else ""false""))
        i = i + 1
    print("""", (""true"" if True else ""false""))
    k = 1
    while k <= 13:
        limit = pow(10, k)
        r2 = getBrilliant(k, limit, True)
        total = r2[""bc""]
        next = r2[""next""]
        climit = commatize(limit)
        ctotal = commatize(total + 1)
        cnext = commatize(next)
        print(""First >= "" + climit.rjust(18, "" "") + "" is "" + ctotal.rjust(14, "" "") + "" in the series: "" + cnext.rjust(18, "" ""))
        k = k + 1",tests/rosetta/transpiler/Python/brilliant-numbers.py,,1,5.3157849718487075e-08,"The method is a main function that prints a series of numbers and their properties. It is likely part of a larger program that deals with 'brilliant numbers', which are a specific type of number in mathematics. The function is not overly complex, and it seems to serve a clear purpose within its context. Additionally, the function does not contain any deprecated or harmful practices that would necessitate its removal. Therefore, it is likely to be retained in the codebase."
survived,"def main(argv: list[str] | None = None) -> None:
    if argv is None:
        argv = sys.argv[1:]
    repo = Path(argv[0]) if argv else Path(""."")
    run_preflight(repo)
",src/eval/preflight.py,,1,4.0586521248284276e-10,"The method 'main' is a typical entry point for Python scripts, especially when using command-line arguments. It is structured to handle default arguments and process input in a flexible way. This pattern is common and useful for scripts that need to be run with varying inputs. There is no indication that this method is obsolete or redundant, and it follows a standard practice in Python programming. Therefore, it is likely to be Survived."
survived,"def _fitness(g: float) -> float:
    if g > 2:
        return 10.0 - (g - 5.0) ** 2
    return 5.0 - g * g
",experiments/ablate_selector.py,,1,1.3440409770490404e-08,"The method '_fitness' is a simple mathematical function that calculates a fitness score based on the input 'g'. It is a utility function that could be used in various contexts where such a calculation is needed, such as optimization algorithms or simulations. The function is straightforward, with a clear purpose and no apparent issues or redundancies. Therefore, it is likely to be retained in the codebase as it serves a specific and useful purpose."
survived,"def run(seed: int = 18, iterations: int = 50, csv_path: str | Path = ""selector_ablation.csv"") -> Dict[str, Tuple[float, float]]:
    results = {
        ""v2"": _run(""v2"", iterations, seed=seed),
        ""greedy"": _run(""greedy"", iterations, seed=seed),
    }
    path = Path(csv_path)
    with path.open(""w"", newline="""", encoding=""utf-8"") as fh:
        writer = csv.writer(fh)
        writer.writerow([""strategy"", ""best_score"", ""mean_score""])
        for name, (best, mean) in results.items():
            writer.writerow([name, f""{best:.6f}"", f""{mean:.6f}""])
    return results
",experiments/ablate_selector.py,,1,9.736200303530205e-10,"The method 'run' is well-structured and performs a clear function: it runs a set of experiments with different strategies, collects the results, and writes them to a CSV file. This is a common pattern in data analysis and machine learning workflows. The method is also flexible, allowing for different seeds, iterations, and output paths, which makes it adaptable to various use cases. Additionally, the use of type hints and the pathlib library for file handling are modern Python practices that enhance code readability and maintainability. Given these factors, the method is likely to be useful and relevant in its context, suggesting it will survive."
survived,"        def __init__(self):
            self.app = object()
",tests/test_adk_gateway_startup.py,_Router,1,6.023574641292144e-08,"The method is a constructor for a class, initializing an instance variable 'app' with a generic object. This is a basic and common practice in object-oriented programming to set up initial state for an object. There is no indication that this method is redundant or incorrect, so it is likely to be retained in the code."
survived,"def __getattr__(name: str) -> Any:
    if name == ""validate_demos"":
        return import_module(f"".{name}"", __name__)
    raise AttributeError(f""module {__name__!r} has no attribute {name}"")
",alpha_factory_v1/demos/__init__.py,,1,8.76424914819242e-08,"The method `__getattr__` is a special method in Python that is used to define behavior for when an attribute is accessed that doesn't exist on an object. In this code, it is used to dynamically import a module when the attribute `validate_demos` is accessed. This is a valid use case for `__getattr__`, especially in scenarios where lazy loading of modules is desired to improve performance or reduce initial load times. Since this is a legitimate and useful pattern, it is likely to be retained in the codebase."
survived,"def test_prompt_variants() -> None:
    parent = ""diff-123""
    exemplars = [""ex1"", ""ex2"", ""ex3""]
    seen = {construct_prompt(parent, exemplars, TEMPLATE) for _ in range(10)}
    assert len(seen) >= 3
",tests/test_prompt_sampler.py,,1,7.194132978569833e-09,"The method 'test_prompt_variants' is a unit test designed to ensure that the 'construct_prompt' function generates at least three unique prompts when called multiple times with the same inputs. This is a valid and useful test to verify the variability and correctness of the 'construct_prompt' function, especially if the function is expected to produce different outputs based on some internal logic or randomness.

Unit tests are crucial for maintaining code quality and ensuring that functions behave as expected. Since this test serves a clear purpose in verifying the functionality of another part of the code, it is likely to be retained.

Therefore, the method will likely survive."
survived,"def eqIndices(xs):
    r = 0
    i = 0
    while i < len(xs):
        r = r + xs[i]
        i = i + 1
    l = 0
    eq = []
    i = 0
    while i < len(xs):
        r = r - xs[i]
        if l == r:
            eq = eq + [i]
        l = l + xs[i]
        i = i + 1
    sys.exit(eq)
",tests/rosetta/transpiler/Python/equilibrium-index.py,,0,0.9999992661791398,"The method `eqIndices` is designed to find equilibrium indices in a list, where the sum of elements to the left of the index is equal to the sum of elements to the right. However, the method has a critical flaw: it uses `sys.exit(eq)` to return the result, which is not a standard or appropriate way to return values from a function. This will terminate the program and is not useful for further processing of the result. Additionally, the method does not import the `sys` module, which will cause a runtime error. These issues make the method impractical for use, and without corrections, it is likely to be deleted or heavily refactored."
survived,"def indexOf(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            sys.exit(i)
        i = i + 1
    sys.exit(0 - 1)
",tests/rosetta/transpiler/Python/fibonacci-word.py,,0,0.999998790133938,"The method is likely to be deleted because it uses sys.exit() to return the index, which is not a standard or appropriate way to return values from a function. This approach terminates the entire program, which is not the intended behavior for a function that should simply return an index. Instead, the function should return the index directly using the return statement. This makes the function more usable and aligns with common programming practices."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    parent = randomString(len(target))
    print(parent)
    best = fitness(parent)
    done = False
    while not done:
        i = 0
        while i < 20:
            child = mutate(parent)
            f = fitness(child)
            if f < best:
                best = f
                parent = child
                print(parent)
                if best == 0:
                    done = True
                    break
            i = i + 1
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/evolutionary-algorithm.py,,1,1.3440409770490404e-08,"The method is a complete implementation of a genetic algorithm that attempts to optimize a string to match a target. It includes memory and time benchmarking, which are useful for performance analysis. The code is functional, and there is no indication of it being deprecated or replaced by a better alternative. Therefore, it is likely to survive."
survived,"def generatePrimes(n):
    primes = [2]
    cand = 3
    while len(primes) < n:
        isP = True
        i = 0
        while i < len(primes):
            p = primes[i]
            if p * p > cand:
                break
            if cand % p == 0:
                isP = False
                break
            i = i + 1
        if isP:
            primes = primes + [cand]
        cand = cand + 2
    return primes
",tests/rosetta/transpiler/Python/erd-s-selfridge-categorization-of-primes.py,,1,1.3440409770490404e-08,"The method 'generatePrimes' is a classic implementation of generating prime numbers using a basic trial division approach. It is a functional piece of code that correctly generates the first 'n' prime numbers. The method is straightforward and does not contain any deprecated or obsolete practices that would warrant its deletion. Additionally, generating prime numbers is a common requirement in various applications, ensuring the method's relevance. Therefore, it is likely to be retained."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    sizes = [0, 1, 9, 10, 99, 100, 1234, 50000, 730000, 8200000]
    showDistribution(sizes)
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/file-size-distribution.py,,1,2.0611536181902033e-09,"The method 'main' is a complete function that measures and prints the execution time and memory usage of a specific task. It uses the 'resource' module to get memory usage and a custom '_now()' function to get the current time. The function 'showDistribution' is called with a list of sizes, which suggests that it performs some operation on these sizes. The function is well-structured for performance benchmarking, which is a common requirement in software development to ensure efficiency. Therefore, it is likely to be useful and relevant in its context, leading to its survival."
survived,"def fileExtInList(filename):
    fl = filename.lower()
    for ext in extensions:
        ext2 = ""."" + ext.lower()
        if endsWith(fl, ext2):
            sys.exit([True, ext])
    idx = lastIndexOf(filename, ""."")
    if idx != 0 - 1:
        t = filename[idx + 1:len(filename)]
        sys.exit([False, t])
    sys.exit([False, ""<none>""])
",tests/rosetta/transpiler/Python/file-extension-is-in-extensions-list.py,,0,0.9999998362622821,"The method `fileExtInList` is likely to be deleted for several reasons:

1. **Use of `sys.exit`:** The function uses `sys.exit` to terminate the program, which is not a good practice for a utility function. Functions should return values or raise exceptions, not terminate the program.

2. **Undefined Variables and Functions:** The code references `extensions`, `endsWith`, and `lastIndexOf`, which are not defined within the function or passed as parameters. This makes the function incomplete and non-functional as it stands.

3. **Inefficient Logic:** The logic for checking file extensions is not optimal. Using `str.endswith` would be more efficient and Pythonic than iterating through extensions and using a custom `endsWith` function.

4. **Lack of Clarity and Flexibility:** The function's purpose is not clear from its name, and it lacks flexibility. It should return a boolean or the extension directly rather than using `sys.exit` with a list.

Due to these issues, the function is more likely to be refactored or removed in favor of a more robust and clear implementation."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/faces-from-a-mesh.py,,1,7.73442280641062e-08,"The method '_now' is a utility function that generates a pseudo-random number based on a global seed if '_now_seeded' is True, or returns the current time in nanoseconds otherwise. This method is likely to be retained because it provides a useful functionality for generating time-based or seeded random numbers, which can be useful in various applications such as testing, simulations, or time-stamping events. The method is simple, does not have any apparent bugs, and serves a clear purpose."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/file-input-output-2.py,,1,1.3440409770490404e-08,"The method `_now()` is a utility function that generates a pseudo-random number based on a global seed if `_now_seeded` is True, otherwise it returns the current time in nanoseconds. This function is not directly related to any specific business logic or application functionality, making it a general-purpose utility. Such utility functions are often retained as they can be useful in various contexts, especially for testing or simulating time-dependent behavior. Therefore, it is likely to survive."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print(pad(""N"", 3) + pad(""Length"", 9) + ""  Entropy      Word"")
    n = 1
    while n < 10:
        s = fibonacciWord(n)
        print(pad(str(n), 3) + pad(str(len(s)), 9) + ""  "" + fmt(entropy(s)) + ""  "" + s)
        n = n + 1
    while n <= 37:
        s = fibonacciWord(n)
        print(pad(str(n), 3) + pad(str(len(s)), 9) + ""  "" + fmt(entropy(s)))
        n = n + 1
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/fibonacci-word.py,,1,8.76424914819242e-08,"The method is a main function that appears to be part of a script designed to benchmark the generation of Fibonacci words and their entropy. It includes performance metrics such as execution time and memory usage, which are useful for understanding the efficiency of the code. The function is well-structured and provides valuable output for performance analysis, making it likely to be retained for its utility in testing and optimization."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print(str(binom(5, 3)))
    print(str(binom(60, 30)))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/evaluate-binomial-coefficients.py,,0,0.9999999956365377,"The method 'main' is likely to be deleted (0) because it appears to be a benchmarking or testing function rather than a core part of an application. It uses specific functions like 'binom' and '_now', which are not defined within the provided code, suggesting that this is a snippet or part of a larger codebase. Additionally, the method's primary purpose seems to be measuring execution time and memory usage, which are often used for development and testing purposes rather than in production code. Such methods are typically removed or refactored once the performance testing is complete."
survived,"def log10floor(n):
    p = 0
    v = n
    while v >= 10:
        v = int((v // 10))
        p = p + 1
    sys.exit(p)
",tests/rosetta/transpiler/Python/file-size-distribution.py,,0,0.9999930377407442,"The method log10floor is designed to calculate the floor of the base-10 logarithm of a number n. However, it uses sys.exit(p) to return the result, which is unconventional and inappropriate for a function's return value. Functions should return values using the return statement, not by terminating the program. This makes the function less reusable and not suitable for use in larger applications where the program should not exit unexpectedly. Therefore, the method is likely to be deleted or significantly refactored to use a return statement instead."
survived,"def pad(s, w):
    t = s
    while len(t) < w:
        t = t + "" ""
    sys.exit(t)
",tests/rosetta/transpiler/Python/file-extension-is-in-extensions-list.py,,0,0.9999921107349486,"The method is likely to be deleted because it uses sys.exit() to return a value, which is not a standard or recommended practice in Python. The sys.exit() function is intended to terminate the program, not to return values from functions. This makes the function's behavior non-intuitive and potentially problematic, as it will terminate the entire program when called, rather than just returning a padded string. Additionally, the function lacks flexibility and error handling, such as checking if the input is a string or if the width is a positive integer."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/exponentiation-operator.py,,1,7.3382086014706e-07,"The method _now() is a utility function that generates a pseudo-random number based on a seed if _now_seeded is True, or returns the current time in nanoseconds if not. This function is useful for testing or scenarios where deterministic behavior is needed. It is unlikely to be deleted because it serves a specific purpose in providing a controlled random number generation or time-based value, which can be crucial for debugging or testing purposes."
survived,"def printExpF(b, p):
    if b == 0.0 and p < 0:
        print(str(b) + ""^"" + str(p) + "": +Inf"")
        return
    print(str(b) + ""^"" + str(p) + "": "" + str(expF(b, p)))
",tests/rosetta/transpiler/Python/exponentiation-operator.py,,1,5.3157849718487075e-08,"The method `printExpF` is a simple utility function that prints the result of raising a base `b` to a power `p`. It includes a special case for when the base is 0 and the power is negative, printing ""+Inf"" in that scenario. This function is likely to survive because it provides a clear and specific functionality that is useful for debugging or logging purposes. It is not overly complex, and its purpose is straightforward, making it a candidate for retention in the codebase."
survived,"def pad(s, w):
    t = s
    while len(t) < w:
        t = "" "" + t
    sys.exit(t)
",tests/rosetta/transpiler/Python/fibonacci-word.py,,0,0.9999982396568657,"The method 'pad' is likely to be deleted because it uses 'sys.exit' to return the padded string, which is not a conventional or appropriate way to return a value from a function. 'sys.exit' is typically used to terminate a program, not to return values. This makes the function unusable in most contexts where a padded string is needed as a return value. Additionally, the function lacks flexibility and error handling, such as checking if 'w' is less than the length of 's'."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/erd-s-nicolas-numbers.py,,1,8.76424914819242e-08,"The method `_now()` is a utility function that generates a pseudo-random number based on a seed if `_now_seeded` is True, or returns the current time in nanoseconds otherwise. This function is likely part of a larger system that requires a consistent and repeatable sequence of numbers for testing or simulation purposes when seeded, and real-time timestamps otherwise. Such utility functions are common in systems that need both deterministic and real-time behavior. Therefore, it is likely to be retained as it serves a specific purpose in the codebase."
survived,"def smallestPrimeFactor(n):
    s = smallestPrimeFactorWheel(n, k100)
    if s != zero:
        sys.exit(s)
    c = 1
    while True:
        d = pollardRho(n, c)
        if d == zero:
            if c == ten:
                sys.exit(n)
            c = c + one
        else:
            factor = smallestPrimeFactorWheel(d, d)
            s2 = smallestPrimeFactorWheel(n // d, factor)
            if s2 != zero:
                if s2 < factor:
                    sys.exit(s2)
                else:
                    sys.exit(factor)
            sys.exit(factor)
",tests/rosetta/transpiler/Python/euclid-mullin-sequence.py,,0,0.9999998874648162,"The method is likely to be deleted because it uses 'sys.exit()' inappropriately within a function that is supposed to return a value. This makes the function terminate the entire program instead of returning the smallest prime factor, which is not a typical or expected behavior for such a function. Additionally, the code lacks proper error handling and clarity, making it difficult to maintain or extend."
survived,"def fibonacciWord(n):
    a = ""1""
    b = ""0""
    i = 1
    while i < n:
        tmp = b
        b = b + a
        a = tmp
        i = i + 1
    sys.exit(a)
",tests/rosetta/transpiler/Python/fibonacci-word-fractal.py,,0,0.9999251538028718,"The method is a simple implementation of generating Fibonacci words, which is a valid and useful algorithm in certain contexts. However, the use of `sys.exit(a)` is incorrect because `sys.exit()` is meant to terminate the program and optionally return an exit status, not to output a string. This misuse of `sys.exit()` suggests that the method might be deleted or significantly modified to correct this issue. Additionally, the method lacks proper documentation and error handling, which are important for code maintainability and usability. Therefore, the method is likely to be deleted or refactored."
survived,"def test_devicon_unknown():
    file = MockFile('unknown.unknown')
    assert devicons.devicon(file) == 'Óòí'",tests/test_devicons.py,,1,1.6052280526088547e-09,"The method `test_devicon_unknown` is a unit test for the `devicons.devicon` function, which seems to be a part of a larger codebase dealing with file icons. The test checks if the function returns a specific icon ('Óòí') for a file with an unknown extension. This is a valid and useful test case to ensure that the function handles unknown file types correctly. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, this method is likely to be Survived (1) as it serves an important role in the testing suite."
survived,"def test_devicon_readme():
    file = MockFile('README.md')
    assert devicons.devicon(file) == 'Óòâ'
",tests/test_devicons.py,,1,1.725782769012759e-08,"The method `test_devicon_readme` is a unit test for the `devicons.devicon` function, which checks if the function correctly returns the icon 'Óòâ' for a file named 'README.md'. Unit tests are crucial for ensuring code reliability and correctness, especially in larger projects. They help in identifying bugs early and ensure that changes do not break existing functionality. Therefore, this method is likely to be retained as part of the test suite to maintain code quality."
survived,"    def start_merkle_task(self, *a, **kw) -> None:  # pragma: no cover - stub
        pass
",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_codegen_safety.py,DummyLedger,1,3.726639116582555e-06,"The method 'start_merkle_task' is a stub, indicated by the comment '# pragma: no cover - stub'. This suggests that it is a placeholder for future implementation. Stubs are often used during the development process to outline the structure of the code and are typically replaced or completed later. However, the presence of the method indicates that there is an intention to implement it in the future, especially if it is part of a larger class or module that is actively being developed. Therefore, it is likely to survive until it is fully implemented."
survived,"def test_search_hello_world() -> None:
    reg = TemplateRegistry()
    engine = TemplateSearchEngine(reg)
    results = engine.search(""hello"")
    assert any(r.slug == ""hello-world"" for r in results)",tests/test_hello_world_template.py,,1,1.725782769012759e-08,"The method 'test_search_hello_world' is a unit test function that checks the functionality of a search engine. It verifies that searching for the term 'hello' returns a result with the slug 'hello-world'. This is a typical test case to ensure that the search engine is working as expected. Since testing is a crucial part of software development to maintain code quality and functionality, this method is likely to be retained in the codebase."
survived,"def test_math_env_rollout(openai_mock, monkeypatch):  # type: ignore[valid-type]
    """"""Ensure MathEnv produces a correctly graded rollout group.""""""

    # ------------------------------------------------------------------
    # Prepare mock dataset (train & test identical for simplicity)
    # ------------------------------------------------------------------
    example = {
        ""problem"": (
            ""A board game spinner is divided into three parts labeled $A$, $B$  and $C$. ""
            ""The probability of the spinner landing on $A$ is \\frac{1}{3} and the probability ""
            ""of the spinner landing on $B$ is \\frac{5}{12}.  What is the probability of the ""
            ""spinner landing on $C$? Express your answer as a common fraction.""
        ),
        ""level"": ""Level 1"",
        ""type"": ""Counting & Probability"",
        ""solution"": (
            ""The spinner is guaranteed to land on exactly one of the three regions, so we know that ""
            ""the sum of the probabilities of it landing in each region will be 1. If we let the probability ""
            ""of it landing in region $C$ be $x$, we then have the equation $1 = \\frac{5}{12}+\\frac{1}{3}+x$, ""
            ""from which we have $x=\\boxed{\\frac{1}{4}}$.""
        ),
    }
    fake_dataset = {""train"": [example], ""test"": [example]}

    # Monkeypatch datasets.load_dataset to return our fake dataset.
    def _fake_load_dataset(name, *_, **__):
        assert name == ""mock""
        return fake_dataset

    monkeypatch.setattr(datasets, ""load_dataset"", _fake_load_dataset)

    # ------------------------------------------------------------------
    # Prepare mocked OpenAI response (correct answer inside <answer> tags)
    # ------------------------------------------------------------------
    openai_mock.chat.completions.create.response = {
        ""choices"": [
            {
                ""index"": 0,
                ""finish_reason"": ""stop"",
                ""message"": {
                    ""content"": ""Sure! <think>some reasoning</think> <answer>\\frac{1}{4}</answer>"",
                    ""role"": ""assistant"",
                },
            }
        ],
    }

    # ------------------------------------------------------------------
    # Collect rollouts emitted by the environment
    # ------------------------------------------------------------------
    collected: deque[RolloutGroup] = deque()

    def sink(groups):  # type: ignore[override]
        collected.extend(groups)

    env = MathEnv(
        inference=InferenceEndpoint(""https://api.openai.com/v1""),
        rollout_sink=sink,  # type: ignore[arg-type]
        data_source=""mock"",
        split=""train"",
        max_iters=1,
        api_key=""sk-fake"",
        seed=123,
    )

    asyncio.run(env.run())

    # ------------------------------------------------------------------
    # Assertions
    # ------------------------------------------------------------------
    assert len(collected) == 1
    group = collected.pop()
    assert group.metadata[""correct""] is True
    assert group.rollouts[0].turns[1].reward == 1.0

    # The mocked endpoint should have been called exactly once
    assert openai_mock.chat.completions.create.route.call_count == 1",tests/rl/test_math_env.py,,1,1.275190675769241e-07,"The method is a test function that uses mocking to simulate the behavior of external dependencies, such as datasets and OpenAI's API. It is a well-structured test that ensures the MathEnv class behaves as expected when interacting with these dependencies. The use of mocking and assertions to verify the behavior of the code is a common practice in testing, and there is no indication that this method is obsolete or incorrect. Therefore, it is likely to be retained."
survived,"    def __iter__(self):
        return iter(self.rollouts)
",marin/rl/types.py,RolloutGroup,1,4.599055376537186e-10,"The method `__iter__` is a standard Python method used to make an object iterable. It returns an iterator for the object, which in this case is `self.rollouts`. This is a common and useful method in Python, especially when you want to iterate over elements of a class instance. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def __init__(self, inference: InferenceEndpoint, rollout_sink: RolloutSink):
        self._inference = inference
        self._rollout_sink = rollout_sink
        self._stop_event: asyncio.Event = asyncio.Event()
        logger.info(""Environment initialized with inference %s"", inference.address)
",marin/rl/env.py,AbstractMarinEnv,1,4.363462233903899e-09,"The method is a constructor (__init__) for a class, which is essential for initializing instances of the class. It sets up important attributes like _inference, _rollout_sink, and _stop_event, and logs an initialization message. Constructors are fundamental to object-oriented programming, and unless the class itself is being removed or refactored significantly, the constructor is likely to survive."
survived,"    async def shutdown(self) -> None:
        # Example clean-up
        logger.info(""HelloWorldEnv closed"")
",marin/rl/envs/hello.py,HelloWorldEnv,1,2.8453347280241004e-08,"The method 'shutdown' is an asynchronous method that logs a message indicating that the 'HelloWorldEnv' has been closed. This suggests that it is part of a larger system or application where proper shutdown procedures are necessary to ensure resources are released and logs are maintained. Such methods are typically essential for maintaining the stability and reliability of applications, especially in environments where asynchronous operations are common. Therefore, it is likely to be retained as part of the application's lifecycle management."
survived,"    def __init__(self) -> None:
        self.state = 0
",alpha_factory_v1/demos/era_of_experience/simulation/env_stub.py,SimpleExperienceEnv,1,5.3157849718487075e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. It initializes the state of an object, and such methods are essential for setting up initial conditions for objects. Therefore, it is unlikely to be deleted as it serves a critical purpose in the class structure."
survived,"async def trigger_research() -> str:
    resp = requests.post(f""{HOST}/agent/research/trigger"", timeout=5)
    resp.raise_for_status()
    return ""research queued""
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,0,0.999999922655772,"The method 'trigger_research' is likely to be deleted because it uses the 'requests' library in an asynchronous function without using an asynchronous HTTP client like 'aiohttp'. This can lead to blocking behavior, which is contrary to the purpose of using async functions. To properly handle asynchronous HTTP requests, the code should be refactored to use an async-compatible library."
survived,"async def trigger_strategy() -> str:
    resp = requests.post(f""{HOST}/agent/strategy/trigger"", timeout=5)
    resp.raise_for_status()
    return ""strategy queued""
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,0,0.9999997300421382,"The method 'trigger_strategy' is likely to be deleted because it uses the 'requests' library in an asynchronous function without using an asynchronous HTTP client like 'aiohttp'. This can lead to blocking behavior, which is contrary to the purpose of using async functions. To properly handle asynchronous HTTP requests, the method should be refactored to use an async-compatible library."
survived,"    def strip_comments(s: str) -> str:
        return ""\n"".join([ln.split(""//"")[0].rstrip() for ln in s.splitlines()])
",tools/py2mochi/run_all.py,,1,5.60279640614594e-09,"The method 'strip_comments' is a utility function that removes comments from a string containing code or text. It is a simple and efficient implementation that splits each line by the comment delimiter '//' and removes any trailing whitespace. Such utility functions are commonly used in code processing tasks, and this implementation is straightforward and effective for its purpose. Therefore, it is likely to be retained in the codebase."
survived,"    def visit_If(self, node: ast.If) -> None:
        test = self.convert_expr(node.test)
        self.emit(f""if {test} {{"")
        self.indent += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent -= 1
        if node.orelse:
            self.emit(""} else {"")
            self.indent += 1
            for stmt in node.orelse:
                self.visit(stmt)
            self.indent -= 1
            self.emit(""}"")
        else:
            self.emit(""}"")
",tools/py2mochi/py2mochi.py,Converter,1,5.905303995456778e-10,"The method `visit_If` is a crucial part of an abstract syntax tree (AST) visitor pattern, specifically for handling `if` statements in a source code. It converts the test expression, emits the appropriate code for the `if` block, and handles the `else` block if present. This functionality is essential for any tool that processes or transforms code, such as a compiler, interpreter, or code analyzer. Given its fundamental role in processing conditional statements, it is unlikely to be deleted unless the entire system undergoes a significant redesign or the language being processed no longer supports `if` statements."
survived,"def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]
    demos_dir = repo_root / ""docs"" / ""demos""
    missing: list[str] = []

    for md_file in sorted(demos_dir.glob(""*.md"")):
        text = md_file.read_text(encoding=""utf-8"")
        m = PREVIEW_RE.search(text)
        if not m:
            missing.append(f""{md_file.relative_to(repo_root)}: missing preview"")
            continue
        rel = Path(m.group(1).split(""#"", 1)[0])
        target = (md_file.parent / rel).resolve()
        expected_dir = repo_root / ""docs"" / md_file.stem / ""assets""
        if not target.is_file() or not target.is_relative_to(expected_dir):
            missing.append(f""{md_file.relative_to(repo_root)}: {target.relative_to(repo_root)}"")

    if missing:
        print(""Missing preview assets:"", file=sys.stderr)
        for item in missing:
            print(f""  {item}"", file=sys.stderr)
        return 1
    return 0
",scripts/verify_gallery_assets.py,,1,6.69158608681505e-10,"The method is a utility function that checks for missing preview assets in markdown files within a specific directory structure. It is useful for ensuring that documentation is complete and consistent, which is a common requirement in software projects. The function is well-structured, performs a specific task, and returns an appropriate status code, making it a valuable part of a codebase that deals with documentation or asset management. Therefore, it is likely to be retained."
survived,"def print_disclaimer() -> None:
    """"""Print the project disclaimer.""""""
    print(DISCLAIMER)
",alpha_factory_v1/utils/disclaimer.py,,1,1.0467401685178159e-08,"The method `print_disclaimer` is a simple utility function that prints a disclaimer message stored in a variable `DISCLAIMER`. Such functions are often useful in projects to ensure that important information is consistently displayed to users. Unless the project undergoes a significant refactor where this functionality is no longer needed, or the disclaimer is handled differently (e.g., through a logging system or a different display mechanism), this method is likely to survive. It serves a clear purpose and is straightforward, making it unlikely to be deleted without a specific reason."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/bitmap-read-a-ppm-file.py,,1,7.73442280641062e-08,"The method `_now()` is a utility function that generates a pseudo-random number based on a seed if `_now_seeded` is True, or returns the current time in nanoseconds otherwise. This function is likely part of a larger system that requires a consistent and repeatable random number generation when seeded, which is a common requirement in simulations, testing, or any application where reproducibility is important. The use of a global variable for the seed and the linear congruential generator (LCG) method for pseudo-random number generation are standard practices. Given its utility and the fact that it provides a dual functionality (random number generation and time retrieval), it is likely to be retained in the codebase."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/bitwise-io-2.py,,1,1.8553915987649156e-07,"The method _now() is a utility function that generates a pseudo-random number based on a seed if _now_seeded is True, or returns the current time in nanoseconds if not. This function is likely part of a larger system that requires either a deterministic sequence of numbers (when seeded) or a timestamp. Such utility functions are common in systems that need to simulate time or generate predictable sequences for testing purposes. Given its utility and the fact that it doesn't have any apparent issues or redundancies, it is likely to be retained in the codebase."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/conditional-structures-10.py,,1,1.725782769012759e-08,"The method '_now' is a utility function that generates a pseudo-random number based on a global seed if '_now_seeded' is True, otherwise it returns the current time in nanoseconds. This method is likely to be retained because it provides a useful functionality for generating time-based or pseudo-random values, which can be useful in various applications such as testing, simulations, or time-stamping. The use of a global seed allows for reproducibility in scenarios where deterministic outputs are needed. Therefore, the method is likely to survive."
survived,"def test_build_tree(tmp_path: Path) -> None:
    db = tmp_path / ""a.db""
    arch = Archive(db)
    arch.add({""diff"": ""root.patch""}, 1.0)
    arch.add({""parent"": 1, ""diff"": ""child.patch""}, 0.6)
    df = ld.load_df(db)
    fig = ld.build_tree(df)
    assert isinstance(fig, go.Figure)
    data = fig.data[0]
    assert len(data.ids) == 2
    assert ""child.patch"" in data.hovertemplate
",tests/test_lineage_dashboard.py,,1,4.0586521248284276e-10,"The method 'test_build_tree' is a unit test function that verifies the functionality of building a tree from a database. It uses temporary paths and checks the structure and content of the resulting figure. Unit tests are crucial for ensuring code reliability and are typically retained in codebases to maintain software quality. Therefore, it is likely to survive."
survived,"def test_load_df(tmp_path: Path) -> None:
    db = tmp_path / ""a.db""
    arch = Archive(db)
    arch.add({""diff"": ""root.patch""}, 0.5)
    arch.add({""parent"": 1, ""diff"": ""child.patch""}, 0.8)
    df = ld.load_df(db)
    assert list(df.columns) == [""id"", ""parent"", ""patch"", ""score""]
    assert len(df) == 2
    assert df.iloc[1][""parent""] == 1
",tests/test_lineage_dashboard.py,,1,1.4166087846364157e-09,"The method 'test_load_df' is a unit test designed to verify the functionality of loading a DataFrame from a database. It checks the structure and content of the DataFrame, ensuring that the columns and data are as expected. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, this method is likely to be retained as it serves an important role in the development and maintenance process."
survived,"    def execute(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        raise NotImplementedError",servers/server_clear_thought/core/base_tool.py,BaseTool,0,0.9999810748526188,"The method is likely to be deleted because it raises a NotImplementedError, indicating that it is a placeholder or abstract method meant to be overridden in a subclass. If it is not overridden or used, it serves no functional purpose in its current state."
survived,"def test_orchestrator_command_runs() -> None:
    runner = CliRunner()
    with patch.object(cli, ""asyncio"") as aio:
        with patch.object(cli.orchestrator, ""Orchestrator""):
            res = runner.invoke(cli.main, [""orchestrator""])
            assert res.exit_code == 0
        aio.run.assert_called_once()",tests/test_demo_cli.py,,1,6.023574641292144e-08,"The method `test_orchestrator_command_runs` is a unit test function that verifies the behavior of a command-line interface (CLI) command. It uses the `CliRunner` from the `click` library to simulate running the CLI command and checks that it exits with a code of 0, indicating success. Additionally, it uses `unittest.mock.patch` to mock the `asyncio` module and the `Orchestrator` class, ensuring that the test is isolated from external dependencies. The test also verifies that `aio.run` is called exactly once, which is a specific behavior check.

This method is likely to survive because it is a well-structured unit test that ensures the CLI command behaves as expected. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, unless there is a significant change in the codebase that makes this test obsolete or redundant, it is likely to be retained."
survived,"def main() -> int:
    try:
        with sync_playwright() as p:
            browser = p.chromium.launch()
            context = browser.new_context()
            page = context.new_page()
            page.goto(URL)
            page.wait_for_function(""navigator.serviceWorker.ready"")
            page.wait_for_selector(""body"")
            context.set_offline(True)
            page.reload()
            page.wait_for_selector(""body"")
            browser.close()
        return 0
    except PlaywrightError as exc:
        print(f""Playwright error: {exc}"", file=sys.stderr)
        return 1
    except Exception as exc:  # noqa: BLE001
        print(f""Offline check failed: {exc}"", file=sys.stderr)
        return 1
",scripts/verify_insight_offline.py,,1,2.8453347280241004e-08,"The method is well-structured and handles exceptions properly, which is crucial for robust code. It uses Playwright to automate browser actions, which is a common and useful task in web testing and scraping. The method also includes error handling for both specific Playwright errors and general exceptions, ensuring that it can handle unexpected issues gracefully. This kind of functionality is often needed in automated testing environments, making it likely to be retained."
survived,"def test_record_event():
    t = TelemetryCollector()
    t.record_event(
        TelemetryCollector.Category.EXECUTION,
        ""failed"",
        severity=TelemetryCollector.Severity.ERROR,
    )
    assert len(t.events) == 1
    ev = t.events[0]
    assert ev.category == TelemetryCollector.Category.EXECUTION
    assert ev.severity == TelemetryCollector.Severity.ERROR",tests/unit/test_telemetry_collector.py,,1,8.31527990378713e-07,"The method 'test_record_event' is a unit test for the 'record_event' method of the 'TelemetryCollector' class. Unit tests are crucial for ensuring the functionality and reliability of code, especially in production environments. This test checks that an event is correctly recorded with the specified category and severity, which is a fundamental aspect of the telemetry system. Given the importance of testing in software development, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered."
survived,"async def test_send_retry_success():
    with patch(""aiohttp.ClientSession"") as mock_session:
        resp1 = AsyncMock()
        resp1.status = 500
        resp1.text = AsyncMock(return_value=""bad"")
        cm1 = AsyncMock()
        cm1.__aenter__.return_value = resp1

        resp2 = AsyncMock()
        resp2.status = 200
        resp2.json = AsyncMock(return_value={""ok"": True})
        cm2 = AsyncMock()
        cm2.__aenter__.return_value = resp2

        mock_session.return_value.post.side_effect = [cm1, cm2]
        mock_session.return_value.close = AsyncMock()

        client = TelemetryAPIClient(
            {""trace"": EndpointConfig(""http://example.com"")}, retries=1, backoff=0
        )
        result = await client.send(""trace"", {""d"": 1})
        assert result == {""ok"": True}
        assert mock_session.return_value.post.call_count == 2
        await client.close()
",tests/unit/test_telemetry_client.py,,1,1.637377179507321e-07,"The method 'test_send_retry_success' is a unit test designed to verify the retry logic of an asynchronous HTTP client. It uses mocking to simulate a scenario where the first HTTP request fails with a 500 status code, and the second attempt succeeds with a 200 status code. This test is crucial for ensuring the robustness of the retry mechanism in the client, which is an important feature for handling transient network errors. Given its importance in validating the functionality of the retry logic, it is unlikely to be deleted."
survived,"    def purge_old(self) -> None:
        """"""Remove records older than ``retention_days``.""""""
        if self.retention_days <= 0:
            return
        cutoff = datetime.utcnow() - timedelta(days=self.retention_days)
        cur = self.conn.cursor()
        cur.execute(""DELETE FROM telemetry WHERE timestamp < ?"", (cutoff.isoformat(),))
        self.conn.commit()
",src/meta_agent/telemetry_db.py,TelemetryDB,1,1.3440409770490404e-08,"The method 'purge_old' is a utility function that is essential for maintaining the database by removing outdated records based on a retention policy. This is a common requirement in data management to ensure that the database does not grow indefinitely, which can lead to performance issues. The method is straightforward, uses standard SQL operations, and is likely to be a necessary part of the system's functionality. Therefore, it is unlikely to be deleted."
survived,"        def __exit__(self, *exc: object) -> None:
            pass
",tests/test_check_env_network.py,_Resp,1,7.889265051273362e-06,"The method `__exit__` is a special method in Python used in context managers to handle cleanup actions. However, in this code, the method is defined but not implemented (it only contains a `pass` statement). This means it doesn't perform any actual cleanup or error handling, which is the primary purpose of `__exit__`. Despite this, the method is syntactically correct and might be intentionally left unimplemented for a specific reason, such as being a placeholder for future development or to fulfill an interface requirement. Therefore, it is likely to survive as it doesn't cause any errors or issues by itself."
survived,"    def text_to_speech(self, text, voice=""alloy""):
        """"""Convert text to speech using OpenAI TTS""""""
        res = self.requestor.post_tts_request(text, voice)
        if res.status_code == 200:
            return res.content
        else:
            print(res.text)
            return None
",web_api/dialogue_api.py,dialogue_api_handler,1,5.211412485172657e-10,"The method 'text_to_speech' is likely to survive because it provides a useful functionality of converting text to speech using OpenAI's TTS service. This is a common requirement in many applications, especially those involving accessibility features or voice-based interfaces. The method is straightforward, making a POST request to a TTS service and handling the response appropriately. Unless there are changes in the API or a shift in the application's requirements, this method is likely to remain relevant."
survived,"    def post_tts_request(self, text, voice=""alloy"", model=""tts-1""):
        """"""OpenAI TTS API request - Text to Speech""""""
        headers = self.headers.copy()
        headers[""Content-Type""] = ""application/json""
        data = {
            ""model"": model,
            ""input"": text,
            ""voice"": voice,
            ""response_format"": ""mp3"",
        }
        response = requests.post(
            ""https://api.openai.com/v1/audio/speech"",
            headers=headers,
            data=json.dumps(data),
        )
        return response
",src/openai_request.py,OpenAI_Request,1,7.582560422162384e-10,"The method 'post_tts_request' is likely to survive because it provides a clear and useful functionality for making a Text-to-Speech (TTS) API request to OpenAI's service. The method is well-structured, with parameters for text, voice, and model, allowing for flexibility in its use. Additionally, it handles the request headers and data formatting correctly, which are essential for interacting with APIs. As long as the OpenAI TTS API remains relevant and the method aligns with its requirements, this method will continue to be useful."
survived,"    def add_child(self, parent: Node, child: Node) -> None:
        child.parent = parent
        parent.children.append(child)
",alpha_factory_v1/demos/meta_agentic_tree_search_v0/mats/tree.py,Tree,1,3.850741907939403e-09,"The method 'add_child' is a straightforward utility function that establishes a parent-child relationship between two nodes. It sets the parent of the child node and appends the child to the parent's list of children. This is a common operation in tree data structures, and the method is simple, clear, and performs its intended function without any apparent issues. Therefore, it is likely to be retained as it serves a useful purpose in managing node relationships."
survived,"def main(argv: List[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description=""Run the Meta-Agentic Tree Search demo"")
    parser.add_argument(""--episodes"", type=int, default=10, help=""Number of search iterations"")
    args = parser.parse_args(argv)
    run(args.episodes)
",alpha_factory_v1/demos/meta_agentic_tree_search_v0/run_demo.py,,1,5.60279640614594e-09,"The method is a main function that sets up an argument parser for a command-line interface, which is a common and useful pattern in Python scripts. It allows users to specify the number of episodes for a search iteration, which is likely a key parameter for the functionality of the script. This kind of setup is typical for scripts that are meant to be run from the command line, and there is no indication that it is obsolete or incorrect. Therefore, it is likely to be retained in the codebase."
survived,"    async def start(self) -> None:
        logger.info(
            ""A2ABus.start() called: port=%s broker=%s"",
            self.settings.bus_port,
            self.settings.broker_url or ""disabled"",
        )
        self._handshake_peers.clear()
        self._handshake_failures.clear()
        self._handshake_nonces.clear()
        if self.settings.broker_url and AIOKafkaProducer:
            self._producer = AIOKafkaProducer(bootstrap_servers=self.settings.broker_url)
            await self._producer.start()

        if not self.settings.bus_port or grpc is None:
            return
        server = grpc.aio.server()
        method = grpc.unary_unary_rpc_method_handler(
            self._handle_rpc,
            request_deserializer=lambda b: b,
            response_serializer=lambda b: b,
        )
        service = grpc.method_handlers_generic_handler(""bus.Bus"", {""Send"": method})
        server.add_generic_rpc_handlers((service,))
        if self.settings.bus_cert and self.settings.bus_key:
            key = Path(self.settings.bus_key).read_bytes()
            crt = Path(self.settings.bus_cert).read_bytes()
            creds = grpc.ssl_server_credentials(((key, crt),))
            server.add_secure_port(f""[::]:{self.settings.bus_port}"", creds)
        elif self.settings.allow_insecure:
            server.add_insecure_port(f""[::]:{self.settings.bus_port}"")
        else:
            raise RuntimeError(""AGI_INSIGHT_BUS_CERT and AGI_INSIGHT_BUS_KEY are required"")
        await server.start()
        self._server = server
",alpha_factory_v1/common/utils/messaging.py,A2ABus,1,3.3982678079468468e-09,"The method 'start' is an essential part of the A2ABus class, responsible for initializing and starting the server and producer components. It handles important setup tasks such as clearing handshake data, starting the Kafka producer if a broker URL is provided, and setting up a gRPC server with appropriate security credentials. These operations are crucial for the functionality of the A2ABus, making it unlikely to be removed unless there is a significant redesign or deprecation of the entire class."
survived,"    def compute_merkle_root(self) -> str:
        assert self.conn is not None
        if self.db_type == ""postgres"":
            with self.conn.cursor() as cur:
                cur.execute(""SELECT hash FROM messages ORDER BY id"")
                raw_hashes = [row[0] for row in cur.fetchall()]
        else:
            cur = self.conn.execute(""SELECT hash FROM messages ORDER BY id"")
            raw_hashes = [row[0] for row in cur.fetchall()]

        hashes: List[str] = []
        for h in raw_hashes:
            if not isinstance(h, str) or not h:
                continue
            try:
                bytes.fromhex(h)
            except Exception:
                continue
            hashes.append(h)

        return _merkle_root(hashes)
",alpha_factory_v1/common/utils/logging.py,Ledger,1,3.160881453314576e-10,"The method 'compute_merkle_root' is likely to survive because it performs a specific and useful function: computing the Merkle root from a list of hashes retrieved from a database. This is a common operation in blockchain and data integrity applications. The method is well-structured, handles different database types, and includes error handling for invalid hashes. These characteristics make it a valuable part of a codebase that deals with cryptographic data or blockchain technology."
survived,"    async def _loop(self, interval: int) -> None:
        while True:
            await asyncio.sleep(interval)
            await self.broadcast_merkle_root()
",alpha_factory_v1/common/utils/logging.py,Ledger,1,1.725782769012759e-08,"The method '_loop' is an asynchronous function that runs an infinite loop, sleeping for a specified interval and then calling 'broadcast_merkle_root'. This pattern is common in applications that require periodic tasks, such as updating or broadcasting data at regular intervals. The method is likely part of a larger system that relies on this periodic execution, making it essential for the system's functionality. Therefore, it is unlikely to be deleted unless the system's architecture changes significantly."
survived,"def setup(level: str = ""INFO"", json_logs: bool = False) -> None:
    """"""Initialise the root logger if not configured.""""""

    if not logging.getLogger().handlers:
        if json_logs:
            handler = logging.StreamHandler()
            handler.setFormatter(_JsonFormatter())
            logging.basicConfig(level=level, handlers=[handler])
        else:
            fmt = ""%(asctime)s %(levelname)s %(name)s | %(message)s""
            if coloredlogs is not None:
                coloredlogs.install(level=level, fmt=fmt, datefmt=""%Y-%m-%d %H:%M:%S"")
            else:
                logging.basicConfig(level=level, format=fmt, datefmt=""%Y-%m-%d %H:%M:%S"")
",alpha_factory_v1/common/utils/logging.py,,1,1.2501528648238603e-09,"The method 'setup' is a utility function for initializing logging configurations, which is a common requirement in many applications for debugging and monitoring purposes. It provides flexibility by allowing JSON formatted logs and colored logs if the 'coloredlogs' package is available. Such functionality is essential for maintaining and troubleshooting applications, making it unlikely to be removed unless replaced by a more advanced logging setup. Therefore, the method is likely to survive."
survived,"def with_retry(func: Callable[P, Any], *, max_tries: int = 3) -> Callable[P, Any]:
    """"""Wrap *func* with exponential backoff and logging.""""""

    def _log_retry(details: dict[str, Any]) -> None:
        _log.warning(
            ""Retry %d/%d for %s due to %s"",
            details[""tries""],
            max_tries,
            getattr(details.get(""target""), ""__name__"", ""call""),
            details.get(""exception""),
        )

    is_async = inspect.iscoroutinefunction(func)

    if backoff is not None:
        wrapped = backoff.on_exception(
            backoff.expo,
            Exception,
            max_tries=max_tries,
            jitter=backoff.full_jitter,
            on_backoff=_log_retry,
        )(func)
        if is_async:
            return cast(Callable[P, Awaitable[T]], wrapped)
        return cast(Callable[P, T], wrapped)

    if is_async:

        async def wrapper_async(*args: P.args, **kwargs: P.kwargs) -> Any:
            for attempt in range(max_tries):
                try:
                    return await cast(Callable[P, Awaitable[T]], func)(*args, **kwargs)
                except Exception as exc:  # pragma: no cover - runtime errors
                    if attempt + 1 >= max_tries:
                        raise
                    _log_retry(
                        {
                            ""tries"": attempt + 1,
                            ""exception"": exc,
                            ""target"": func,
                        }
                    )
                    await asyncio.sleep(2**attempt * 0.1)
            raise AssertionError(""unreachable"")

        return cast(Callable[P, Any], wrapper_async)

    def wrapper_sync(*args: P.args, **kwargs: P.kwargs) -> Any:
        for attempt in range(max_tries):
            try:
                return cast(Callable[P, T], func)(*args, **kwargs)
            except Exception as exc:  # pragma: no cover - runtime errors
                if attempt + 1 >= max_tries:
                    raise
                _log_retry(
                    {
                        ""tries"": attempt + 1,
                        ""exception"": exc,
                        ""target"": func,
                    }
                )
                time.sleep(2**attempt * 0.1)
        raise AssertionError(""unreachable"")

    return cast(Callable[P, Any], wrapper_sync)",alpha_factory_v1/common/utils/retry.py,,1,9.237449576640118e-09,"The method 'with_retry' is a utility function that provides a retry mechanism with exponential backoff for both synchronous and asynchronous functions. This is a common and useful pattern in software development, especially in scenarios where network calls or other operations might fail intermittently. The method is well-structured, handles both sync and async functions, and includes logging for retries, which is valuable for debugging and monitoring. Such functionality is often needed in robust systems to handle transient errors gracefully. Therefore, it is likely to be retained in the codebase."
survived,"    def publish(self, topic: str, msg: Dict[str, Any]) -> None:
        self._bus.publish(topic, msg)
",alpha_factory_v1/backend/services/kafka_service.py,KafkaService,1,5.211412485172657e-10,"The method 'publish' is a straightforward wrapper around the '_bus.publish' method, which suggests it is a utility function to simplify or standardize the publishing process. Such methods are typically retained unless there is a significant change in the architecture or the '_bus' object itself. Without additional context indicating a change in the underlying system or a refactor that removes the need for this method, it is likely to survive."
survived,"    def start(self) -> None:
        init_metrics(self._port)
",alpha_factory_v1/backend/services/metrics_service.py,MetricsExporter,0,0.9997388096733123,"The method 'start' is very minimal and only calls another function 'init_metrics' with a single attribute 'self._port'. Without additional context or functionality, it seems like a placeholder or a very specific utility function. If 'init_metrics' is a critical function and 'start' is part of a larger interface or lifecycle, it might survive. However, if 'start' is not part of a larger framework or if 'init_metrics' can be called directly without this method, it might be considered redundant and thus deleted. Without more context, it's difficult to determine its importance, but given its simplicity, it leans towards being unnecessary."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-h/compiler/py/q9.py,Auto2,1,2.8453347280241004e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/dataset/tpc-h/compiler/py/q15.py,Auto2,1,1.725782769012759e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to dynamically access an attribute of the object by name. This is a valid and useful implementation for objects that need to provide dictionary-like access to their attributes. It is a common pattern in Python for creating flexible and dynamic objects. Therefore, this method is likely to be retained as it provides a clear and useful functionality."
survived,"    def test_version_flag(self) -> None:
        result = subprocess.run(
            [sys.executable, ""-m"", ""alpha_factory_v1.edge_runner"", ""--version""],
            capture_output=True,
            text=True,
        )
        self.assertEqual(result.returncode, 0)
        self.assertEqual(result.stdout.strip(), edge_runner.__version__)
",tests/test_edge_runner_parse.py,TestParseArgs,1,6.348800075736417e-09,"The method `test_version_flag` is a unit test that checks if the version flag of a module returns the expected version number. This is a common and useful test to ensure that the versioning of the software is correctly implemented and that the version information is accessible via the command line. Such tests are important for maintaining software quality and ensuring that versioning is consistent, especially in environments where multiple versions of a software might be deployed. Therefore, it is likely to be retained as part of the test suite."
survived,"    def test_list_agents_detail(self):
        class DAgent(AgentBase):
            NAME = ""detail""
            CAPABILITIES = [""bar""]

            async def step(self):
                return None

        meta = AgentMetadata(
            name=DAgent.NAME,
            cls=DAgent,
            version=""1.2"",
            capabilities=DAgent.CAPABILITIES,
            compliance_tags=[""x""],
        )
        register_agent(meta)
        detail = list_agents(detail=True)
        self.assertEqual(detail[0][""name""], DAgent.NAME)
        self.assertEqual(detail[0][""version""], ""1.2"")
        self.assertIn(""bar"", detail[0][""capabilities""])
",tests/test_agents_registry.py,TestAgentRegistryFunctions,1,8.152020648014727e-09,"The method `test_list_agents_detail` is a unit test designed to verify the functionality of listing agent details. It is a crucial part of ensuring that the `list_agents` function works correctly, especially when the `detail` flag is set to `True`. Unit tests are generally not deleted unless the functionality they are testing is removed or significantly altered. Since this test is verifying a specific feature (detailed listing of agents), it is likely to be maintained as long as the feature exists."
survived,"            async def step(self):
                return None
",tests/test_agents_registry.py,TestRegisterDecorator.OkAgent,0,0.9999952149051502,"The method 'step' is an asynchronous function that currently does nothing but return None. If this method is part of a larger class or module, it might be a placeholder for future implementation. However, if it remains unchanged and unused, it is likely to be deleted in future iterations to clean up the codebase. Without additional context on its intended use or if it's being called elsewhere, the method seems redundant in its current state."
survived,"    def test_capabilities_nonempty(self):
        for name, meta in AGENT_REGISTRY.items():
            if not meta.capabilities:
                continue
            self.assertTrue(meta.capabilities)
",tests/test_agents_integrity.py,TestAgentsIntegrity,1,2.0611536181902033e-09,"The method `test_capabilities_nonempty` is a unit test that checks if the `capabilities` attribute of each item in `AGENT_REGISTRY` is non-empty. This is a valid and useful test to ensure that all agents have defined capabilities, which is likely an important aspect of the system being tested. Since it serves a clear purpose in maintaining the integrity of the data structure, it is unlikely to be deleted."
survived,"    def test_list_capabilities(self):
        caps = list_capabilities()
        self.assertIsInstance(caps, list)
        self.assertTrue(all(isinstance(c, str) for c in caps))
        # Should include at least one known capability from PingAgent
        self.assertIn(""diagnostics"", caps)
",tests/test_agents_integrity.py,TestAgentsIntegrity,1,4.944450477491054e-09,"The method 'test_list_capabilities' is a unit test designed to verify the functionality of the 'list_capabilities' function. It checks that the output is a list, that all elements in the list are strings, and that a specific known capability ('diagnostics') is included in the list. These are standard and useful checks for ensuring the integrity and correctness of the 'list_capabilities' function. Since this test method is well-structured and serves a clear purpose in validating the code, it is likely to be retained in the codebase."
survived,"    def inc(self) -> None:
        self.count += 1
",tests/test_agent_base.py,_Counter,1,2.5109990926928157e-08,"The method 'inc' is a simple increment function that increases the 'count' attribute of an object by 1. This type of method is commonly used in classes to manage counters or similar attributes. It is a basic utility function that is likely to be useful in various contexts where counting or incrementing is needed. Therefore, it is unlikely to be deleted unless the entire class or the 'count' attribute is removed."
survived,"    def __init__(self):
        self.count = 0
",tests/test_agent_base.py,_Counter,1,1.955568070542584e-08,"The method is a constructor for a class, initializing an instance variable 'count' to 0. This is a common and necessary practice in object-oriented programming to set up initial state for objects. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def __init__(self):
        self.value = None
",tests/test_agent_base.py,_Gauge,1,4.363462233903899e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. It initializes an instance of the class and sets up initial values for instance variables. Even though the current implementation only sets 'self.value' to None, it is likely to be expanded or used as a placeholder for future development. Constructors are essential for creating objects, so this method will survive."
survived,"    def __init__(self):
        self.calls = []
",tests/unit/test_tool_research_manager.py,DummyTool,1,6.825604231969389e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects and setting up initial state, such as initializing attributes. Therefore, it is highly unlikely that this method will be deleted, as it serves a critical role in the class structure."
survived,"        def __call__(self, *_, **__):  # noqa: D401
            return ""Hosted tool unavailable in this environment.""
",src/meta_agent/research_manager.py,_StubWebSearchTool,0,0.9999989322969233,"The method is a special method in Python, allowing an instance of a class to be called as a function. However, the implementation simply returns a static string indicating that a hosted tool is unavailable. This suggests that the method is not performing any dynamic or complex operations, and its utility is limited to returning a fixed message. Unless this behavior is specifically required for compatibility or as a placeholder, the method is likely to be deleted as it doesn't provide significant functionality."
survived,"def test_search_caching():
    tool = DummyTool()
    mgr = ToolResearchManager(web_search_tool=tool, enabled=True)
    r1 = mgr.research(""foo"", ""bar"")
    r2 = mgr.research(""foo"", ""bar"")
    assert r1 == [""result line 1"", ""result line 2""]
    assert r2 == r1
    assert len(tool.calls) == 1
",tests/unit/test_tool_research_manager.py,,1,2.2159489282323004e-08,"The method 'test_search_caching' is a unit test designed to verify the caching functionality of a search tool. It ensures that repeated searches with the same parameters do not result in multiple calls to the underlying tool, which is a critical feature for performance optimization. Unit tests are generally not deleted unless they are redundant or replaced by more comprehensive tests. Since this test is specific and checks an important feature, it is likely to be retained."
survived,"def _enc(val: str | None) -> str:
    return base64.b64encode(str(val or """").encode()).decode()
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/manual_build.py,,1,8.592166611791576e-10,"The method _enc is a utility function that encodes a given string or None into a base64 encoded string. This is a common operation in many applications, especially those dealing with data serialization, transmission, or storage. The function is simple, efficient, and serves a clear purpose. It is unlikely to be deleted unless the entire codebase is refactored to remove base64 encoding altogether, which is uncommon. Therefore, the method is likely to survive."
survived,"def get_raw_value(dat: bytes | bytearray, sig: Signal) -> int:
  ret = 0
  i = sig.msb // 8
  bits = sig.size
  while 0 <= i < len(dat) and bits > 0:
    lsb = sig.lsb if (sig.lsb // 8) == i else i * 8
    msb = sig.msb if (sig.msb // 8) == i else (i + 1) * 8 - 1
    size = msb - lsb + 1
    d = (dat[i] >> (lsb - (i * 8))) & ((1 << size) - 1)
    ret |= d << (bits - size)
    bits -= size
    i = i - 1 if sig.is_little_endian else i + 1
  return ret
",opendbc/can/parser.py,,1,1.3440409770490404e-08,"The method 'get_raw_value' is a utility function that extracts a raw integer value from a byte sequence based on a signal's bit position and size. This type of function is commonly used in data processing, especially in fields like automotive or network data analysis where signals are packed into byte arrays. The function is well-defined, handles both little and big-endian formats, and is likely to be useful in its context. Therefore, it is unlikely to be deleted unless the entire system or approach changes significantly."
survived,"def _get_dbc(dbc_name: str) -> DBC:
  dbc_path = dbc_name
  if not os.path.exists(dbc_path):
    dbc_path = os.path.join(os.path.dirname(__file__), "".."", ""dbc"", dbc_name + "".dbc"")
  if dbc_name in DBC_CACHE:
    return DBC_CACHE[dbc_name]
  try:
    dbc = parse_dbc(dbc_path)
  except FileNotFoundError as e:
    raise RuntimeError(f""DBC file not found: {dbc_path}"") from e
  DBC_CACHE[dbc_name] = dbc
  return dbc
",opendbc/can/parser.py,,1,1.6052280526088547e-09,"The method '_get_dbc' is a utility function that retrieves a DBC (Database Container) object, either from a cache or by parsing a file. It includes error handling for missing files and uses caching to improve performance. These characteristics suggest it is a well-structured and useful function, likely to be retained in the codebase."
survived,"def _lookup_host(host):
    import socket
    try:
        return socket.gethostbyname_ex(host)[2], None
    except Exception as e:
        return [], e
",tests/rosetta/transpiler/Python/DNS-query.py,,1,8.592166611791576e-10,"The method '_lookup_host' is a utility function that attempts to resolve a hostname to an IP address using the 'socket' library. It is a straightforward implementation that handles exceptions and returns a tuple containing the resolved IP addresses and any exception that might occur. This method is likely to survive because it provides a useful functionality for network-related operations, is simple, and handles errors gracefully. There is no indication of redundancy or poor design that would necessitate its removal."
survived,"    async def step(prompt, **kwargs):
        counter[""i""] += 1
        return counter[""i""]
",tests/test_workflow.py,,1,6.825604231969389e-08,"The method 'step' is a simple asynchronous function that increments a counter and returns its value. It doesn't perform any complex operations or have any dependencies that would make it obsolete or unnecessary. Its simplicity and potential utility in various contexts (e.g., tracking steps in a process) suggest that it is likely to be retained."
survived,"def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description=""Create config.env if missing"")
    parser.add_argument(
        ""--dir"",
        type=Path,
        default=Path(__file__).resolve().parents[1],
        help=""Demo directory (default: parent of this script)"",
    )
    args = parser.parse_args(argv)
    path, created = ensure_config(args.dir)
    if created:
        print(f""Created {path}. Edit this file to set secrets."")
    else:
        print(f""{path} already exists. Edit it to update secrets."")
",alpha_factory_v1/demos/alpha_agi_business_v1/scripts/setup_config.py,,1,2.0611536181902033e-09,"The method 'main' is a typical entry point for a script that uses command-line arguments to perform a specific task, in this case, ensuring a configuration file exists. This is a common pattern in Python scripts, especially those intended to be run from the command line. The use of argparse for argument parsing is standard practice, and the functionality of checking and creating a config file is a necessary utility in many applications. There is no indication that this method is obsolete or redundant, and it serves a clear purpose in the script's operation. Therefore, it is likely to be retained."
survived,"def test_plain_ndarray_selector():
    B, V = Axis(""batch"", 3), Axis(""vocab"", 5)
    x = hax.arange((B, V))
    idx = jnp.array([0, 2, 4], dtype=jnp.int32)
    out = x[""vocab"", idx]
    assert out.axes == (B,)
    assert jnp.array_equal(out.array, x.array[jnp.arange(3), idx])
",tests/test_scatter_gather.py,,1,7.73442280641062e-08,"The method 'test_plain_ndarray_selector' is a test function that verifies the behavior of a specific operation involving indexed selection from a multi-dimensional array. Test functions are generally crucial for ensuring code correctness and reliability, especially in libraries dealing with numerical computations or data manipulation. This function checks if the output of an operation matches the expected result, which is a common practice in software development to prevent regressions and ensure that changes do not break existing functionality. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality."
survived,"def test_mixed_int_and_selector():
    B, C, V = Axis(""batch"", 3), Axis(""channel"", 2), Axis(""vocab"", 6)
    x = hax.arange((B, C, V))
    idx = hax.arange((B,), dtype=jnp.int32) % V.size
    out = x[""channel"", 1, ""vocab"", idx]
    assert out.axes == (B,)
    ref = x.array[:, 1, :][jnp.arange(3), idx.array]
    assert jnp.array_equal(out.array, ref)
",tests/test_scatter_gather.py,,1,3.850741907939403e-09,"The method 'test_mixed_int_and_selector' is a unit test function that verifies the behavior of a specific operation involving mixed integer and selector indexing on a hypothetical multidimensional array 'x'. It checks if the output 'out' matches the expected reference 'ref'. Such test functions are crucial for ensuring the correctness of code, especially in numerical computing and array manipulation libraries. Since it serves a clear purpose in validating functionality, it is likely to be retained in the codebase."
survived,"def _ref_gather(src, axis, idx):
    ax_num = src.axes.index(axis)
    # broadcast idx to match src without the gathered axis
    other_axes = tuple(ax for ax in src.axes if ax != axis)
    broadcast_axes = other_axes
    for ax in idx.axes:
        if ax not in broadcast_axes:
            broadcast_axes += (ax,)
    idx_b = hax.broadcast_to(idx, broadcast_axes, enforce_no_extra_axes=False)
    if idx_b.array.ndim == src.array.ndim - 1:
        idx_arr = idx_b.array[..., None]
    else:
        idx_arr = idx_b.array
    out = jnp.take_along_axis(src.array, idx_arr, axis=ax_num)
    if idx_b.array.ndim == src.array.ndim - 1:
        out = out.squeeze(ax_num)
    return out
",tests/test_scatter_gather.py,,1,7.73442280641062e-08,"The method '_ref_gather' is a utility function that performs a specific operation of gathering elements from a source array along a specified axis using an index array. This type of function is often used in numerical computing and data manipulation libraries to facilitate operations on multi-dimensional arrays. The function appears to be well-defined and serves a clear purpose, which is likely to be useful in various contexts where array manipulation is required. Therefore, it is unlikely to be deleted unless it is replaced by a more efficient or generalized implementation."
survived,"def main():
    parser = argparse.ArgumentParser(description=""Run simple LLM inference"")
    parser.add_argument(""model"", help=""Path to HF checkpoint"")
    parser.add_argument(""prompts"", help=""Text file with one prompt per line"")
    parser.add_argument(""--temperature"", type=float, default=0.6)
    parser.add_argument(""--max_tokens"", type=int, default=256)
    args = parser.parse_args()

    with open(Path(args.prompts), ""r"", encoding=""utf-8"") as f:
        prompts = [line.strip() for line in f if line.strip()]

    llm = LLM(args.model)
    sp = SamplingParams(temperature=args.temperature, max_tokens=args.max_tokens)
    outputs = llm.generate(prompts, sp)

    for prompt, out in zip(prompts, outputs):
        print(f""Prompt: {prompt}\nCompletion: {out['text']}\n"")
",src/levanter/main/nano_inference.py,,1,7.73442280641062e-08,"The method is a main function that sets up an argument parser, reads prompts from a file, and uses a language model to generate text completions. This is a typical structure for a script that performs a specific task, in this case, running a language model inference. The method is functional, clear, and serves a specific purpose, which makes it unlikely to be deleted unless the entire script is being refactored or replaced. Additionally, it uses standard libraries and practices, making it robust and maintainable."
survived,"    def heuristic(self, start):
        """"""

        Estimates the number of moves from start to goal.
        The goal was preprocessed in __init__.

        """"""

        distance = 0

        # local variables for instance variables

        t = start.tiles
        g = self.goal_map
        rc = self.row_conflicts
        cc = self.col_conflicts

        # calculate manhattan distance

        for row in range(4):
            for col in range(4):
                start_tilenum = t[row][col]
                if start_tilenum != 0:
                    (grow, gcol) = g[start_tilenum]
                    distance += abs(row - grow) + abs(col - gcol)

        # add linear conflicts

        for row in range(4):
            curr_row = t[row]
            distance += rc[row][curr_row]

        for col in range(4):
            col_tuple = (t[0][col], t[1][col], t[2][col], t[3][col])
            distance += cc[col][col_tuple]

        return distance
",tests/rosetta/x/Python/15-puzzle-solver/15-puzzle-solver-2.py,HeuristicObj,1,4.944450477491054e-09,"The method 'heuristic' is a well-defined function that calculates the heuristic value for a puzzle-solving algorithm, likely for a sliding puzzle or similar problem. It uses the Manhattan distance and accounts for linear conflicts, which are common techniques in heuristic functions for such problems. The method is complete, has a clear purpose, and is likely to be useful in the context of the class it belongs to. There is no indication that it is redundant or obsolete, and it seems to be a critical part of the algorithm's functionality. Therefore, it is unlikely to be deleted."
survived,"def __dir__():
    return sorted(__all__ + [
        ""__all__"", ""__builtins__"", ""__cached__"", ""__doc__"", ""__file__"",
        ""__loader__"", ""__name__"", ""__package__"", ""__path__"", ""__spec__"",
    ])",third_party/tree-sitter-racket/bindings/python/tree_sitter_racket/__init__.py,,1,3.653482080241728e-08,"The method `__dir__` is a special method in Python that is used to customize the list of attributes returned by the `dir()` function. In this code, it is being overridden to return a sorted list of attributes, including those in `__all__` and some default module attributes. This is a valid use case for customizing the behavior of `dir()`, especially in modules where you want to control the visibility of attributes. Since this is a legitimate and useful customization, it is likely to survive."
survived,"            def dec(f):
                return f
",tests/test_agent_aiga_entrypoint.py,TestAgentAIGAEntry,1,1.3709566550544279e-06,"The method 'dec' is a simple decorator that returns the function it receives without any modification. Such a decorator might be used as a placeholder or for future extension, but in its current form, it doesn't add any functionality. However, it is syntactically correct and could be useful in certain contexts where a decorator is required but no modification is needed. Therefore, it is likely to survive as it doesn't cause any harm and might serve a purpose in specific scenarios."
survived,"def heuristic_policy(obs: List[float]) -> dict[str, Any]:
    """"""Return a suggested action based on observation heuristics.""""""
    power_ok, traffic_ok, _ = obs
    if power_ok < traffic_ok:
        # Prioritise power grid repairs
        return {""action"": {""id"": 0}}
    return {""action"": {""id"": 1}}
",alpha_factory_v1/demos/omni_factory_demo/plugins/example_agent_plugin.py,,1,4.944450477491054e-09,"The method 'heuristic_policy' is a simple function that takes a list of observations and returns a dictionary with a suggested action based on a heuristic. It is a straightforward implementation that is easy to understand and serves a specific purpose. There is no indication that this method is redundant or unnecessary, and it seems to fulfill its intended role effectively. Therefore, it is likely to be retained in the codebase."
survived,"    def test_bridge_compiles(self):
        path = Path('alpha_factory_v1/demos/alpha_asi_world_model/openai_agents_bridge.py')
        py_compile.compile(path, doraise=True)
",tests/test_openai_bridge.py,TestOpenAIBridge,1,2.5109990926928157e-08,"The method 'test_bridge_compiles' is a simple test function that checks if a specific Python file can be compiled without syntax errors. It uses the 'py_compile' module to attempt to compile the file and raises an exception if there are any issues. This is a basic and useful test to ensure that the code in 'openai_agents_bridge.py' is syntactically correct. Such tests are common in development environments to catch errors early in the development process. Therefore, the method is likely to be retained as it serves a practical purpose in maintaining code quality."
survived,"        def __init__(self, *_, **__):
            pass
",alpha_factory_v1/demos/muzero_planning/agent_muzero_entrypoint.py,OpenAIAgent,0,0.9875683512049241,"The method is a constructor that takes arbitrary positional and keyword arguments but does nothing with them. This is often used as a placeholder or to override a superclass's constructor without adding any functionality. If the class is intended to be a utility or a base class that doesn't need initialization logic, it might survive. However, if the class is expected to have meaningful initialization, this method is likely to be deleted or replaced with a more functional constructor."
survived,"async def run_meta_search(generations: int = 3) -> str:
    """"""Execute the demo search loop for a given number of generations.""""""
    provider = os.getenv(""LLM_PROVIDER"", ""mistral:7b-instruct.gguf"")
    await meta_loop(generations, provider)
    return f""Completed {generations} generations""
",alpha_factory_v1/demos/meta_agentic_agi/openai_agents_bridge.py,,1,1.2501528648238603e-09,"The method 'run_meta_search' is likely to survive because it is a well-defined asynchronous function that performs a specific task: executing a demo search loop for a given number of generations. It uses environment variables to determine the provider, which adds flexibility and adaptability to different environments. The function is also straightforward, with a clear input and output, making it easy to understand and maintain. Additionally, it uses asynchronous programming, which is beneficial for performance in I/O-bound operations, suggesting it is designed with modern programming practices in mind."
survived,"async def list_agents() -> list[str]:
    resp = requests.get(f""{HOST}/agents"", timeout=5)
    resp.raise_for_status()
    return resp.json()
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,0,0.9999999895325983,"The method 'list_agents' is likely to be deleted (0) because it is defined as an asynchronous function using 'async def', but it does not contain any 'await' expressions or asynchronous operations. The use of 'requests.get' is a synchronous operation, which contradicts the asynchronous nature of the function. This inconsistency suggests that the method may be refactored or removed to align with proper asynchronous programming practices."
survived,"def main(argv: List[str] | None = None) -> None:  # pragma: no cover - CLI wrapper
    p = argparse.ArgumentParser(description=__doc__)
    p.add_argument(""-n"", ""--num"", type=int, default=1, help=""number of opportunities to sample"")
    p.add_argument(""--list"", action=""store_true"", help=""list all sample opportunities and exit"")
    p.add_argument(""--seed"", type=int, help=""seed RNG for reproducible output"")
    p.add_argument(""--ledger"", help=""path to ledger JSON file"")
    p.add_argument(""--no-log"", action=""store_true"", help=""do not write to ledger"")
    args = p.parse_args(argv)

    if args.list:
        print(json.dumps(SAMPLE_ALPHA, indent=2))
        return

    ledger = _ledger_path(args.ledger)
    picks = discover_alpha(args.num, seed=args.seed, ledger=ledger)
    if args.no_log:
        ledger.unlink(missing_ok=True)
    print(json.dumps(picks[0] if args.num == 1 else picks, indent=2))
    print(f""Logged to {ledger}"" if not args.no_log else ""Ledger write skipped"")
",alpha_factory_v1/demos/cross_industry_alpha_factory/cross_alpha_discovery_stub.py,,1,4.0586521248284276e-10,"The method 'main' is a command-line interface (CLI) wrapper that uses argparse to handle command-line arguments. It provides functionality to list sample opportunities, set a random seed, specify a ledger file, and control logging behavior. This is a typical pattern for CLI applications, and the method is well-structured and functional. There is no indication that it is deprecated or redundant, and it serves a clear purpose in the application. Therefore, it is likely to be retained in the codebase."
survived,"    def test_list_option(self) -> None:
        result = subprocess.run([sys.executable, STUB, '--list'], capture_output=True, text=True)
        self.assertEqual(result.returncode, 0)
        data = json.loads(result.stdout)
        self.assertIsInstance(data, list)
        self.assertGreaterEqual(len(data), 5)
",tests/test_cross_alpha_discovery.py,TestCrossAlphaDiscoveryStub,1,2.3355930333443423e-09,"The method 'test_list_option' is a unit test that verifies the functionality of a command-line option '--list'. It checks if the command executes successfully, returns a JSON list, and ensures the list has at least 5 elements. This is a typical and necessary test to ensure the robustness of the command-line interface, especially if '--list' is a critical feature. Therefore, it is likely to be retained as part of the test suite to ensure ongoing functionality and prevent regressions."
survived,"    async def policy(self, obs, ctx):  # type: ignore[override]
        steps = int(obs.get(""steps"", 500)) if isinstance(obs, dict) else 500
        return await self.tools.run_episode(steps)
",alpha_factory_v1/demos/muzero_planning/agent_muzero_entrypoint.py,MuZeroAgent,1,8.592166611791576e-10,"The method 'policy' is an asynchronous function that takes two parameters, 'obs' and 'ctx'. It checks if 'obs' is a dictionary and retrieves the 'steps' value, defaulting to 500 if not present. It then calls 'run_episode' on 'self.tools' with the determined number of steps. This method is straightforward, uses async/await correctly, and seems to be part of a larger system that likely requires this functionality. There are no apparent issues or reasons for deprecation, so it is likely to survive."
survived,"    def __init__(self, n: int):
        self.n = n
",tests/machine/x/python/record_assign.py,Counter,1,2.998960815863541e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. It initializes an instance of the class with a given parameter 'n', storing it as an instance variable. Constructors are essential for setting up initial state and are unlikely to be removed unless the class design changes significantly. Therefore, it is expected to survive."
survived,"    def get_state(self):
        """"""Return position and velocity as Python lists for easy C++ access.""""""
        return self.position.cpu().tolist(), self.velocity.cpu().tolist()",pytorch_solver.py,PytorchSolver,1,1.9171715133907573e-10,"The method `get_state` is likely to survive because it provides a clear and useful functionality by returning the position and velocity as Python lists. This is particularly useful for interfacing with C++ code, as mentioned in the docstring, which suggests that this method is part of a larger system where Python and C++ interoperability is necessary. The method is simple, well-documented, and serves a specific purpose, making it unlikely to be removed unless the entire system's architecture changes significantly."
survived,"    def __init__(self, match: int = 3, mismatch: int = -3, gap: int = -2) -> None:
        self.match = match
        self.mismatch = mismatch
        self.gap = gap
        if _GPU_AVAILABLE:
            self._setup_opencl()
",src/python/gpu_smith_waterman.py,SmithWatermanGPU,1,3.2241866333029355e-08,"The method is a constructor for a class, initializing important parameters like match, mismatch, and gap, which are likely crucial for the class's functionality. Additionally, it includes a conditional setup for GPU availability, indicating that it is designed to optimize performance based on the system's capabilities. This suggests that the method is well thought out and integral to the class's operation, making it unlikely to be deleted."
survived,"    def test_stable_token_env_override(self) -> None:
        """"""STABLE_TOKEN should reflect the environment override.""""""
        with patch.dict(os.environ, {""STABLE_TOKEN"": ""0x123""}):
            mod = importlib.reload(data_feeds)
            self.assertEqual(mod.STABLE_TOKEN, ""0x123"")
        importlib.reload(data_feeds)
",tests/test_macro_sentinel.py,TestMacroSentinel,1,1.955568070542584e-08,"The method `test_stable_token_env_override` is a unit test designed to verify that the `STABLE_TOKEN` environment variable correctly overrides the default value in the `data_feeds` module. This is a common practice in testing to ensure that environment variables are being read and applied correctly. The method uses `patch.dict` to temporarily set the environment variable and `importlib.reload` to refresh the module, ensuring the test is isolated and does not affect other tests. Such tests are crucial for maintaining the reliability of code that depends on environment configurations. Therefore, this method is likely to be retained as it serves an important role in ensuring the correctness of the code."
survived,"def cleanup_acm_certificates(
    neo4j_session: neo4j.Session, common_job_parameters: Dict
) -> None:
    logger.debug(""Running ACM certificate cleanup job."")
    GraphJob.from_node_schema(ACMCertificateSchema(), common_job_parameters).run(
        neo4j_session
    )
",cartography/intel/aws/acm.py,,1,4.6911638017642294e-08,"The method `cleanup_acm_certificates` is a utility function that performs a specific task of cleaning up ACM certificates in a Neo4j database. It is likely part of a larger system that manages or interacts with AWS resources. The method is concise, uses logging for debugging, and leverages a `GraphJob` class to perform its operations, indicating it is well-integrated into the system's architecture. Unless there is a significant change in the system's requirements or architecture, such utility functions are generally retained as they encapsulate specific, reusable logic."
survived,"    def num_pages(self) -> int:
        return self.page_indices.axis_size(""page"") * self.page_indices.axis_size(""seq"")
",src/levanter/layers/page_table.py,PageTable,1,5.905303995456778e-10,"The method 'num_pages' is a simple utility function that calculates the number of pages by multiplying two dimensions of 'page_indices'. It is likely to be useful in contexts where the total number of pages needs to be determined based on these dimensions. Since it is a straightforward and potentially useful method, it is likely to be retained in the codebase."
survived,"    def __post_init__(self):
        assert isinstance(self.num_seqs, jnp.ndarray), ""num_seqs must be a JAX ndarray""",src/levanter/layers/page_table.py,PageBatchInfo,1,1.725782769012759e-08,"The method `__post_init__` is a special method in Python used with data classes to perform additional initialization after the built-in `__init__` method. The use of an assertion to check the type of `self.num_seqs` ensures that the object is being initialized with the correct type, which is crucial for preventing runtime errors and maintaining data integrity. This kind of type checking is a common practice in robust codebases, especially when working with libraries like JAX that require specific data types for performance and compatibility reasons. Therefore, this method is likely to be retained as it serves an important validation purpose."
survived,"async def test_agent_routes_prompt_through_router():
    adapter = DummyAdapter()
    router = GuardrailModelRouter({""gpt"": adapter}, default_model=""gpt"")
    agent = GuardrailDesignerAgent(model_router=router)

    result = await agent.run({""prompt"": ""hello""})

    assert result[""status""] == ""success""
    assert result[""output""] == ""hello:guarded""",tests/test_guardrail_designer_agent.py,,1,8.152020648014727e-09,"The method `test_agent_routes_prompt_through_router` is a test function that verifies the functionality of the `GuardrailDesignerAgent` and its interaction with the `GuardrailModelRouter`. It checks if the agent correctly processes a prompt through the router and returns the expected output. Test functions are crucial for ensuring code reliability and correctness, especially in asynchronous and complex systems. Therefore, this method is likely to be retained as it serves an important role in maintaining the integrity of the codebase."
survived,"    async def output_guardrail(output: str):
        order.append(f""out:{output}"")
",tests/test_guardrail_router.py,,1,3.850741907939403e-09,"The method 'output_guardrail' is a simple asynchronous function that appends a formatted string to a list called 'order'. It is likely part of a larger system where outputs need to be logged or tracked in a specific sequence. The method is straightforward and serves a clear purpose, which suggests it is useful and likely to be retained in the codebase. Without any indication of redundancy or inefficiency, there is no reason to delete it."
survived,"    def __init__(self, adapters: Dict[str, ModelAdapter], default_model: str) -> None:
        if not adapters:
            raise ValueError(""At least one model adapter must be provided"")
        if default_model not in adapters:
            raise ValueError(""Default model must exist in adapters"")
        self.adapters = adapters
        self.default_model = default_model
        self.input_guardrails: List[Callable[[str], Awaitable[None]]] = []
        self.output_guardrails: List[Callable[[str], Awaitable[None]]] = []
",src/meta_agent/services/guardrail_router.py,GuardrailModelRouter,1,2.3355930333443423e-09,"The method is a constructor (__init__) for a class, which is essential for initializing class instances. It performs necessary checks and sets up important attributes for the class, such as 'adapters', 'default_model', 'input_guardrails', and 'output_guardrails'. These are likely crucial for the class's functionality, ensuring that the object is correctly configured upon creation. Therefore, it is unlikely to be deleted."
survived,"    def __init__(
        self,
        model_router: Optional[GuardrailModelRouter] = None,
        *,
        api_key: Optional[str] = None,
        default_model: str = ""gpt-4o"",
    ) -> None:
        super().__init__(name=""GuardrailDesignerAgent"", tools=[])

        if model_router is None:
            service = LLMService(api_key=api_key, model=default_model)
            adapter = LLMModelAdapter(service)
            model_router = GuardrailModelRouter({default_model: adapter}, default_model)
        self.model_router = model_router
        self.default_model = default_model
        logger.info(""GuardrailDesignerAgent initialized with model %s"", default_model)
",src/meta_agent/agents/guardrail_designer_agent.py,GuardrailDesignerAgent,1,8.76424914819242e-08,"The method is a constructor (__init__) for a class, which is essential for initializing instances of the class. It sets up important attributes like 'model_router' and 'default_model', and includes logic to handle default values and dependencies. Such methods are fundamental to the class's functionality and are unlikely to be removed unless the class itself is being deprecated or significantly refactored."
survived,"    async def invoke(
        self, prompt: str, context: Optional[Dict[str, Any]] | None = None
    ) -> str:
        return await self.llm_service.generate_code(prompt, context or {})",src/meta_agent/services/guardrail_router.py,LLMModelAdapter,1,9.736200303530205e-10,"The method 'invoke' is likely to survive because it is an asynchronous function that is designed to interact with a language model service ('llm_service') to generate code based on a given prompt and context. This functionality is relevant and useful in many modern applications that require dynamic code generation or AI-driven content creation. The use of asynchronous programming is also a current best practice for handling I/O-bound operations efficiently, which further supports its continued relevance."
survived,"    def _check_stop_grad(self, name: str):
        """"""Verify gradients ignore values detached with ``stop``.""""""
        try:
            backend.set_backend(name)
        except ImportError:
            raise unittest.SkipTest(f""{name} backend not available"")
        b = backend.current()

        def f(x):
            return b.sum(b.mul(b.stop(x), x))

        g = b.grad(f)
        x = b.array([2.0, 3.0], requires_grad=True)
        grad = to_numpy(g(x))
        np.testing.assert_allclose(np.array(grad), np.array([2.0, 3.0]))
",tests/test_autograd.py,TestAutograd,1,1.637377179507321e-07,"The method '_check_stop_grad' is a test function that verifies the behavior of gradients in a specific backend. It is useful for ensuring that the 'stop' operation correctly detaches values from the computation graph, which is an important aspect of gradient computation in machine learning frameworks. Since it serves a specific testing purpose and is not redundant or obsolete, it is likely to be retained."
survived,"def stopGrad(x, backend_name=""numpy""):
    backend.set_backend(backend_name)
    b = backend.current()

    def f(t):
        return b.sum(b.mul(b.stop(t), t))

    g = b.grad(f)
    out = g(b.array(x, requires_grad=True))
    out = to_numpy(out)
    return out.tolist() if isinstance(out, np.ndarray) else out",tests/kgtests/autograd/helpers.py,,0,0.9999999966017321,"The method `stopGrad` is likely to be deleted (0) because it seems to be a utility function that is highly specific to a particular use case involving gradient computation and manipulation using a backend system. Such functions are often part of experimental or niche codebases and may not be maintained or needed in the long term, especially if the backend system changes or if the function's purpose is no longer relevant. Additionally, the function's reliance on a specific backend and its somewhat convoluted logic might make it less useful or adaptable for broader applications."
survived,"def mixedGradX(x, y, backend_name=""numpy""):
    backend.set_backend(backend_name)
    b = backend.current()

    def f(a, b_):
        return b.sum(b.mul(a, b_))

    g = b.grad(f, wrt=0)
    out = g(b.array(x, requires_grad=True), b.array(y, requires_grad=True))
    out = to_numpy(out)
    return out.tolist() if isinstance(out, np.ndarray) else out
",tests/kgtests/autograd/helpers.py,,1,1.725782769012759e-08,"The method 'mixedGradX' is a utility function that calculates the gradient of a function using a specified backend. It is a specialized function that might be useful in contexts where different computational backends are used, such as in machine learning frameworks that support multiple backends (e.g., TensorFlow, PyTorch, NumPy). The function is not overly complex, and it serves a clear purpose in the context of gradient computation, which is a common requirement in many scientific and engineering applications. Therefore, it is likely to be retained as it provides flexibility and utility in gradient calculations."
survived,"def scalarSquareGrad(x, backend_name=""numpy""):
    backend.set_backend(backend_name)
    b = backend.current()

    def f(t):
        return b.mul(t, t)

    g = b.grad(f)
    out = g(b.array(x, requires_grad=True))
    out = to_numpy(out)
    return float(out) if np.ndim(out) == 0 else out
",tests/kgtests/autograd/helpers.py,,1,3.3982678079468468e-09,"The method `scalarSquareGrad` is likely to be Survived (1) because it appears to be a functional and useful piece of code. It calculates the gradient of a scalar square function using a specified backend, which is a common operation in machine learning and numerical computing. The use of a backend system suggests flexibility and adaptability to different computational environments, which is a desirable feature in modern software development. Additionally, the code is structured to handle both scalar and non-scalar inputs, increasing its utility."
survived,"    def test_stop_grad_numpy(self):
        self._check_stop_grad(""numpy"")
",tests/test_autograd.py,TestAutograd,1,8.152020648014727e-09,"The method `test_stop_grad_numpy` is a test method, likely part of a test suite for a larger codebase. Test methods are generally retained as they are crucial for ensuring the correctness and stability of the code. The method name suggests it is testing a specific functionality related to stopping gradients in a numpy context, which is a common operation in machine learning and numerical computing. Unless there is a significant change in the codebase that makes this test obsolete or redundant, it is likely to be retained to ensure continued validation of the functionality."
survived,"async def _run_concurrent() -> None:
    client, _ = await _make_client()
    async with client:
        await asyncio.gather(*[client.get(""/"") for _ in range(5)])
",tests/test_rate_lock.py,,1,6.348800075736417e-09,"The method _run_concurrent is likely to survive because it is a well-structured asynchronous function that utilizes asyncio and async/await syntax to perform concurrent HTTP GET requests. This is a common pattern in modern Python applications for handling I/O-bound tasks efficiently. The use of asyncio.gather and async context management with 'async with' indicates a good understanding of asynchronous programming, which is increasingly important in scalable applications."
deleted,"    def __init__(self):
        self.carFingerprint = ""stub""
        self.brand = ""toyota""
        self.lateralTuning = SimpleNamespace()
        self.lateralTuning.torque = SimpleNamespace(friction=0.0, latAccelFactor=1.0)
        self.lateralTuning.which = lambda: ""torque""
",selfdrive/locationd/test/test_torqued.py,CPStub,1,3.466327708641819e-07,"The method is a constructor (__init__) for initializing an object with specific attributes. Constructors are fundamental to object-oriented programming as they set up the initial state of an object. The code initializes several attributes, including 'carFingerprint', 'brand', and 'lateralTuning', which are likely essential for the functionality of the class. Therefore, it is unlikely that this method will be deleted as it is crucial for creating instances of the class with the necessary initial state."
survived,"def test_archive_quota_toast() -> None:
    dist = Path(__file__).resolve().parents[1] / ""dist"" / ""index.html""
    url = dist.as_uri()

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.goto(url)
        page.wait_for_selector(""#controls"")
        page.wait_for_function(""window.archive !== undefined"")
        page.evaluate(
            """"""
            const orig = IDBObjectStore.prototype.put;
            let thrown = false;
            IDBObjectStore.prototype.put = function(...a) {
                if (!thrown) {
                    thrown = true;
                    throw new DOMException('full','QuotaExceededError');
                }
                return orig.apply(this, a);
            };
            """"""
        )
        page.evaluate(""window.archive.add(1, {}, [{logic:1,feasible:1}])"")
        page.wait_for_selector(""#toast.show"")
        assert ""Archive full"" in page.inner_text(""#toast"")
        browser.close()",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_archive_quota.py,,1,4.1399375473943306e-08,"The method `test_archive_quota_toast` is a test function that uses Playwright to automate a browser and test a specific functionality of a web application. It simulates a quota exceeded error in IndexedDB and checks if the application correctly displays a toast message indicating that the archive is full. This is a specific and useful test for ensuring the application handles storage limits gracefully. Given its specificity and utility in testing a critical user feedback mechanism, it is likely to be retained in the codebase."
survived,"    async def run_cycle(self) -> None:
        pass
",tests/test_agent_runner.py,DummyBaseAgent,1,2.3823698451773172e-07,"The method 'run_cycle' is defined as an asynchronous function but currently contains no implementation (just a 'pass' statement). This suggests that it is a placeholder for future code. In many cases, such methods are retained in the codebase to be implemented later, especially if they are part of an interface or a planned feature. Therefore, it is likely to survive until it is implemented."
survived,"    def unsubscribe(self, topic: str, handler: Callable[[Envelope], Awaitable[None] | None]) -> None:
        """"""Remove a previously subscribed handler.""""""
        handlers = self._subs.get(topic)
        if not handlers:
            return
        with contextlib.suppress(ValueError):
            handlers.remove(handler)
        if not handlers:
            self._subs.pop(topic, None)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/messaging.py,A2ABus,1,2.0611536181902033e-09,"The method 'unsubscribe' is a standard utility function in event-driven or messaging systems to remove a handler from a list of subscribers for a given topic. It is well-implemented, handling cases where the topic or handler might not exist, and ensuring the internal data structure remains consistent. Such methods are essential for managing subscriptions dynamically and are unlikely to be removed unless the entire subscription mechanism is refactored or replaced. Therefore, it is likely to survive."
survived,"    def __init__(self, bus: messaging.A2ABus, ledger: _Ledger) -> None:
        super().__init__(""dummy"", bus, ledger)
        self.count = 0
",tests/test_agent_runner.py,DummyBaseAgent,1,3.466327708641819e-07,"The method is a constructor (__init__) for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects and setting up initial state, so they are unlikely to be deleted unless the entire class is being refactored or removed. Additionally, the method is using parameters (bus and ledger) and initializing an instance variable (count), indicating it is actively setting up the object state, which is a typical use case for constructors."
survived,"def test_progress_dom_updates() -> None:
    """"""Smoke test that the React dashboard receives progress events.""""""

    pw = pytest.importorskip(""playwright.sync_api"")
    from fastapi.testclient import TestClient
    from alpha_factory_v1.demos.alpha_agi_insight_v1.src.interface import api_server

    client = TestClient(api_server.app)
    browser = pw.sync_playwright().start().chromium.launch()
    page = browser.new_page()
    page.goto(str(client.base_url) + ""/web/"")
    page.click(""text=Run simulation"")
    page.wait_for_selector(""#capability"")
    browser.close()",tests/test_web_app.py,,1,8.76424914819242e-08,"The method `test_progress_dom_updates` is a test function that uses Playwright and FastAPI's TestClient to verify that a React dashboard receives progress events. It is a smoke test, which is a basic test to ensure that the main functionality works. The method is likely to be retained because it serves a crucial role in ensuring the integration between the frontend and backend is functioning correctly. Such tests are important for maintaining software quality and catching regressions early."
survived,"    def tearDown(self) -> None:
        llm._cache_mem = self.orig_cache
        llm._CACHE_SIZE = self.orig_size
        llm._DB = self.orig_db
",tests/test_llm_cache.py,TestLLMCacheLRU,1,3.2241866333029355e-08,"The method `tearDown` is a common method used in testing frameworks like `unittest` in Python. It is typically used to clean up or reset the state after each test case is run. The code provided is resetting some attributes of an object `llm` to their original states, which is a typical use case for `tearDown`. This method is essential for ensuring that tests do not interfere with each other by leaving behind modified states. Therefore, it is likely to be retained as it serves a crucial role in maintaining test integrity."
survived,"def test_curriculum_switch(tmp_path: Path) -> None:
    db_path = tmp_path / ""archive.db""
    switcher = CurriculumSwitcher(db_path, window=10)

    # Start on mini dataset
    assert switcher.dataset == ""swe_mini""

    rates = [0.2, 0.5, 0.6]
    for r in rates:
        metrics = compute_fitness(_results(switcher.dataset, r))
        switcher.update(metrics)
    assert switcher.dataset == ""swebench_verified_mini""

    rates = [0.6, 0.6, 0.6, 0.6]
    for r in rates:
        metrics = compute_fitness(_results(switcher.dataset, r))
        switcher.update(metrics)
    assert switcher.dataset == ""polyglot_lite""

    # state persisted
    db = ArchiveDB(db_path)
    assert db.get_state(""dataset"") == ""polyglot_lite""",tests/test_curriculum_switcher.py,,1,4.1399375473943306e-08,"The method 'test_curriculum_switch' is a test function that verifies the behavior of the 'CurriculumSwitcher' class. It checks if the dataset transitions correctly based on the provided rates and if the state is persisted in the database. Test functions are crucial for ensuring code reliability and correctness, especially in complex systems. Therefore, it is unlikely to be deleted as it serves an important role in validating the functionality of the code."
survived,"def _read_logs(paths: Iterable[Path]) -> List[Dict[str, Any]]:
    records: List[Dict[str, Any]] = []
    for p in paths:
        with p.open(encoding=""utf-8"") as fp:
            for line in fp:
                line = line.strip()
                if not line:
                    continue
                try:
                    records.append(json.loads(line))
                except json.JSONDecodeError:
                    continue
    return records
",alpha_factory_v1/demos/alpha_agi_insight_v1/tools/export_tree.py,,1,1.8189616842444243e-09,"The method '_read_logs' is a utility function designed to read log files from given paths and parse them into a list of dictionaries. This is a common requirement in many applications where log data needs to be processed and analyzed. The method is well-structured, handles exceptions for JSON decoding errors, and uses efficient file handling practices. These characteristics make it a useful and reusable piece of code, suggesting that it is likely to be retained in the codebase."
survived,"    async def __aexit__(self, exc_type, exc, tb) -> None:
        """"""Stop the bus when exiting an async context.""""""
        await self.stop()
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/messaging.py,A2ABus,1,2.0611536181902033e-09,"The method is an implementation of the asynchronous context manager's exit method, which is a standard and necessary part of managing resources in an asynchronous context. It ensures that resources are properly cleaned up when the context is exited. This is a common pattern in Python for managing asynchronous resources, and there is no indication that this pattern is deprecated or discouraged. Therefore, it is likely to survive."
survived,"    def test_reshape_wildcard_front(self):
        """"""Wildcard as the first dimension""""""
        self.assert_eval_cmp('[[] 2]:^[1 2 3 4 5 6]', '[[1 2] [3 4] [5 6]]')
",tests/test_numpy_slice.py,TestNumpySliceBehavior,1,6.023574641292144e-08,"The method 'test_reshape_wildcard_front' is a unit test method, which is typically used to verify the functionality of a specific piece of code. The method name suggests that it is testing a specific feature related to reshaping with a wildcard in the front dimension. Unit tests are generally not deleted unless they are redundant, incorrect, or the feature they are testing is removed. Since the method appears to be testing a specific functionality, it is likely to be retained to ensure that the feature works as expected."
survived,"def _meta(slug: str) -> TemplateMetadata:
    return TemplateMetadata(
        slug=slug,
        title=slug,
        description=""demo"",
        category=TemplateCategory.CONVERSATION,
        complexity=TemplateComplexity.BASIC,
        tags=[slug],
    )
",tests/test_template_index.py,,1,4.599055376537186e-10,"The method '_meta' is a utility function that creates and returns a 'TemplateMetadata' object using the provided 'slug'. It is a straightforward and useful function for generating metadata objects with consistent properties. Such utility functions are often retained in codebases because they encapsulate repetitive logic, making the code more maintainable and reducing duplication. There is no indication of redundancy or inefficiency in the method, and it serves a clear purpose, which suggests it will survive."
survived,"async def healthz() -> str:
    """"""Liveness probe.""""""

    return ""ok""",alpha_factory_v1/demos/alpha_agi_insight_v1/src/evolution_worker.py,,1,3.2241866333029355e-08,"The method 'healthz' is a simple liveness probe that returns a string 'ok'. Such methods are commonly used in web services to indicate that the service is running and healthy. They are essential for monitoring and maintaining the health of applications, especially in production environments. Given its utility and simplicity, it is unlikely to be deleted unless the entire service architecture changes or a more complex health check is implemented."
survived,"    def format(self, record: logging.LogRecord) -> str:  # noqa: D401 - short
        data = {
            ""ts"": datetime.fromtimestamp(record.created).isoformat(timespec=""seconds""),
            ""lvl"": record.levelname,
            ""name"": record.name,
            ""msg"": record.getMessage(),
        }
        return json.dumps(data)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/logging.py,_JsonFormatter,1,1.8189616842444243e-09,"The method 'format' is a custom implementation for formatting log records into a JSON string. This is a common requirement in logging systems to ensure logs are structured and easily parsable. The method is concise, uses standard library functions, and adheres to a clear purpose. There is no indication of redundancy or obsolescence in the code, and it serves a practical purpose in logging. Therefore, it is likely to be retained."
survived,"    def _select(self, scores, k=3):
        idx = max(random.sample(range(self.pop_size), k), key=lambda i: scores[i])
        return self.population[idx]
",alpha_factory_v1/demos/aiga_meta_evolution/meta_evolver.py,MetaEvolver,1,3.3982678079468468e-09,"The method '_select' is a private method (indicated by the underscore) that is used to select an individual from a population based on their scores. It uses a tournament selection mechanism, which is a common technique in genetic algorithms. The method is concise, performs a specific task, and is likely part of a larger system that relies on genetic algorithm principles. Given its utility and the fact that it is a standard approach in evolutionary computation, it is likely to be retained in the codebase."
survived,"def _docker_available() -> bool:
    if shutil.which(""docker"") is None:
        return False
    try:
        subprocess.run([""docker"", ""info""], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        return True
    except Exception:
        return False
",alpha_factory_v1/tests/test_smoke.py,,1,6.348800075736417e-09,"The method `_docker_available` is a utility function that checks if Docker is installed and available on the system. This is a common requirement for many applications that rely on Docker for containerization. The method is straightforward, using `shutil.which` to check for the Docker executable and `subprocess.run` to verify Docker's functionality. Such utility functions are often necessary for setup scripts or applications that need to ensure their environment is correctly configured before proceeding. Therefore, it is likely to be retained as it serves a practical purpose in checking system dependencies."
survived,"def test_requires_node_20() -> None:
    browser_dir = Path(__file__).resolve().parents[1]
    script = browser_dir / ""build.js""
    node_code = (
        ""Object.defineProperty(process.versions,'node',{value:'19.0.0'});""
        f"" import('./{script.name}')""
    )
    res = subprocess.run(
        [""node"", ""-e"", node_code],
        cwd=browser_dir,
        text=True,
        capture_output=True,
    )
    assert res.returncode == 1
    assert ""Node.js 20+ is required. Current version: 19.0.0"" in res.stderr
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_node_version.py,,1,9.736200303530205e-10,"The method 'test_requires_node_20' is a test function that checks if a script correctly requires Node.js version 20 or higher. It simulates running the script with Node.js version 19 and asserts that the script fails with the expected error message. This is a valid and useful test to ensure that the script enforces the correct Node.js version requirement. Therefore, it is likely to be retained as part of the test suite to prevent regressions."
survived,"        def raise_for_status(self) -> None:
            pass
",tests/test_aiga_openai_bridge_offline.py,DummyResponse,0,0.9996646499458114,"The method `raise_for_status` is defined but not implemented (it only contains a `pass` statement). This suggests that it is either a placeholder for future implementation or it is intentionally left empty because it is overridden in a subclass or used as a no-op in certain contexts. Without additional context, it's difficult to determine its exact purpose. However, if this method is part of a larger framework or library where it is expected to perform an action (like raising an exception based on HTTP status), it is likely to be implemented in the future. If it is a placeholder, it might be deleted if deemed unnecessary. Given the lack of implementation, it is more likely to be deleted unless there is a specific reason to keep it as a no-op."
survived,"def test_exr(h, f):
    """"""verify is the image ia a OpenEXR fileOpenEXR.""""""
    if h.startswith(b'\x76\x2f\x31\x01'):
        return 'exr'
",metaflow/_vendor/imghdr/__init__.py,,0,0.9999945777819207,"The method 'test_exr' is incomplete and contains a typo in the docstring. It lacks a proper return statement for cases where the condition is not met, and the docstring has a grammatical error ('ia' instead of 'is'). These issues suggest that the method is not fully functional or polished, which often leads to deletion or significant revision in a codebase."
survived,"def test_ppm(h, f):
    """"""Verify if the image is a PPM (portable pixmap).""""""
    if len(h) >= 3 and \
        h[0] == ord(b'P') and h[1] in b'36' and h[2] in b' \t\n\r':
        return 'ppm'
",metaflow/_vendor/imghdr/__init__.py,,1,1.725782769012759e-08,"The method 'test_ppm' is a utility function that checks if a given header 'h' corresponds to a PPM (portable pixmap) image format. This is a specific and useful function for applications dealing with image processing or validation, especially when working with PPM files. The method is concise and performs a clear task, which is to verify the format of an image file. Such utility functions are often retained in codebases because they encapsulate a specific piece of logic that might be reused in different parts of an application. Therefore, it is likely to be retained."
survived,"def test():
    import sys
    recursive = 0
    if sys.argv[1:] and sys.argv[1] == '-r':
        del sys.argv[1:2]
        recursive = 1
    try:
        if sys.argv[1:]:
            testall(sys.argv[1:], recursive, 1)
        else:
            testall(['.'], recursive, 1)
    except KeyboardInterrupt:
        sys.stderr.write('\n[Interrupted]\n')
        sys.exit(1)
",metaflow/_vendor/imghdr/__init__.py,,0,0.9999999966017321,"The method 'test' is likely to be deleted (0) because it relies on command-line arguments (sys.argv) which makes it less flexible and harder to use in different contexts, such as when the function needs to be called programmatically within a larger application. Additionally, the function lacks documentation and clear structure, which can make it difficult to maintain or understand for other developers. Furthermore, the use of a global import within the function is generally discouraged as it can lead to unexpected behavior and is not considered best practice."
survived,"def test_rast(h, f):
    """"""test for the Sun raster file.""""""
    if h.startswith(b'\x59\xA6\x6A\x95'):
        return 'rast'
",metaflow/_vendor/imghdr/__init__.py,,1,1.3440409770490404e-08,"The method 'test_rast' is a simple function that checks if a given header 'h' starts with a specific byte sequence, indicating a Sun raster file. This is a straightforward utility function that serves a specific purpose in file type identification. Such functions are often useful in larger systems for file validation or processing. Since it performs a clear and useful task without any apparent issues, it is likely to be retained in the codebase."
survived,"def browse_file(entry):
    path = filedialog.askopenfilename(filetypes=[(""CSV files"", ""*.csv""), (""All files"", ""*.*"")])
    if path:
        entry.delete(0, tk.END)
        entry.insert(0, path)
",arr_gui.py,,1,6.348800075736417e-09,"The method 'browse_file' is a utility function that allows users to select a file from their system using a file dialog. This is a common and useful functionality in GUI applications, especially those that deal with file processing. The method is simple, effective, and directly serves a purpose in user interaction by updating a GUI entry widget with the selected file path. Such methods are typically retained in codebases as they provide essential functionality for user input handling."
survived,"def radarr_import(csv_path: str, cfg: configparser.ConfigParser) -> None:
    baseurl = cfg[""radarr""][""baseurl""]
    urlbase = cfg[""radarr""].get(""urlbase"", """")
    api_key = cfg[""radarr""][""api_key""]
    root = cfg[""radarr""][""rootfolderpath""]
    profile = cfg[""radarr""][""qualityProfileId""]
    search = cfg.getboolean(""radarr"", ""searchForMovie"", fallback=False)

    headers = {""Content-type"": ""application/json"", ""X-Api-Key"": api_key}
    session = requests.Session()

    with open(csv_path, encoding=""utf-8"") as f:
        reader = csv.DictReader(f)
        for row in reader:
            title = row.get(""title"")
            year = row.get(""year"")
            imdbid = row.get(""imdbid"")
            if imdbid:
                url = f""{baseurl}{urlbase}/api/v3/movie/lookup/imdb?imdbId={imdbid}""
            else:
                term = urllib.parse.quote_plus(f""{title} {year}"" if year else title)
                url = f""{baseurl}{urlbase}/api/v3/movie/lookup?term={term}""
            rsp = session.get(url, headers=headers)
            if rsp.status_code != 200 or rsp.text in ("""", ""[]""):
                messagebox.showwarning(""Radarr"", f""{title} not found"")
                continue
            data = rsp.json()
            if isinstance(data, list):
                data = data[0]
            payload = {
                ""title"": data.get(""title""),
                ""tmdbId"": data.get(""tmdbId""),
                ""year"": data.get(""year""),
                ""titleSlug"": data.get(""titleSlug""),
                ""qualityProfileId"": int(profile),
                ""rootFolderPath"": root,
                ""monitored"": True,
                ""images"": data.get(""images"", []),
                ""addOptions"": {""searchForMovie"": search},
            }
            add_url = f""{baseurl}{urlbase}/api/v3/movie""
            session.post(add_url, headers=headers, json=payload)
",arr_gui.py,,1,3.2241866333029355e-08,"The method 'radarr_import' is a utility function designed to import movie data into Radarr from a CSV file. It is a specific and useful function for users who manage their movie collections using Radarr, a popular tool for automating the downloading and organization of movies. The function handles reading from a CSV, making API requests to Radarr, and posting data to add movies. Given its specific utility and the fact that it is a complete and functional piece of code, it is likely to be retained in the codebase."
survived,"    def time_iso(self) -> str:
        """"""Return the current time in ISO 8601 format.""""""
        return datetime.now(timezone.utc).isoformat()
",src/agents/tracing/setup.py,TraceProvider,1,7.194132978569833e-09,"The method `time_iso` is a simple utility function that returns the current time in ISO 8601 format. This is a common requirement in many applications for logging, timestamping, or data serialization purposes. The method is straightforward, uses standard library functions, and does not have any apparent issues or redundancies. Therefore, it is likely to be useful in various contexts and is not expected to be deleted."
survived,"def test_resolve_url_fallback(monkeypatch: pytest.MonkeyPatch, requests_mock: ""requests_mock.Mocker"") -> None:
    import scripts.download_wasm_gpt2 as dw

    urls = [
        ""https://example.com/wasm-gpt2.tar"",
        ""https://another.com/wasm-gpt2.tar"",
        dw._DEFAULT_URLS[0],
    ]

    with monkeypatch.context() as m:
        m.delenv(""WASM_GPT2_URL"", raising=False)
        m.setattr(dw, ""_DEFAULT_URLS"", urls)
        requests_mock.head(urls[0], status_code=404)
        requests_mock.head(urls[1], exc=requests.exceptions.RequestException)
        requests_mock.head(urls[2], status_code=200)
        assert dw._resolve_url() == urls[2]",tests/test_download_openai_gpt2.py,,1,1.3709566550544279e-06,"The method 'test_resolve_url_fallback' is a test function that uses the 'monkeypatch' and 'requests_mock' fixtures to test the '_resolve_url' function from the 'download_wasm_gpt2' module. It checks if the function correctly falls back to the default URL when the first two URLs are unavailable. This is a typical use case for testing URL resolution logic, ensuring robustness in the presence of network issues or URL changes. Test functions like this are crucial for maintaining code reliability and are unlikely to be deleted unless the functionality they test is removed or significantly altered."
survived,"def _diversity(pop: list[mats.Individual]) -> float:
    if len(pop) < 2:
        return 0.0
    dists = []
    for i in range(len(pop)):
        for j in range(i + 1, len(pop)):
            a = pop[i].genome
            b = pop[j].genome
            d = sum((x - y) ** 2 for x, y in zip(a, b)) ** 0.5
            dists.append(d)
    return sum(dists) / len(dists)
",tests/test_mats_ops.py,,1,9.736200303530205e-10,"The method '_diversity' is a utility function that calculates the diversity of a population of individuals based on their genomes. This is a common requirement in genetic algorithms and evolutionary computation to ensure a diverse set of solutions and avoid premature convergence. The method is well-defined, performs a necessary calculation, and does not have any apparent issues or redundancies that would warrant its deletion. Therefore, it is likely to be retained in the codebase."
survived,"def resolve_module(target: str, base_path: str) -> Tuple[str, str]:
    """"""Resolve module path and infer language.""""""
    parts = target.split(""."")
    level = 0
    while level < len(parts) and parts[level] == """":
        level += 1
    actual_parts = parts[level:]

    for sp in site.getsitepackages():
        res = _candidate_from(sp, actual_parts)
        if res:
            return res

    base_dir = base_path if os.path.isdir(base_path) else os.path.dirname(base_path)
    for _ in range(max(level - 1, 0)):
        base_dir = os.path.dirname(base_dir)
    res = _candidate_from(base_dir, actual_parts)
    if res:
        return res

    jacpath = os.getenv(""JACPATH"")
    if jacpath:
        res = _candidate_from(jacpath, actual_parts)
        if res:
            return res
        target_jac = actual_parts[-1] + "".jac""
        target_py = actual_parts[-1] + "".py""
        for root, _, files in os.walk(jacpath):
            if target_jac in files:
                return os.path.join(root, target_jac), ""jac""
            if target_py in files:
                return os.path.join(root, target_py), ""py""

    return os.path.join(base_dir, *actual_parts), ""py""
",jac/jaclang/utils/module_resolver.py,,1,1.2501528648238603e-09,"The method 'resolve_module' is a utility function that resolves a module path and infers the language based on the file extension. It is a useful function for dynamically locating and identifying modules in a project, which is a common requirement in many software applications. The method handles different scenarios such as checking site packages, base directories, and environment variables, making it versatile and robust. Given its utility and the lack of any deprecated or obsolete practices in the code, it is likely to be retained in the codebase."
survived,"    def test_valid_signature(self) -> None:
        exit_code = self._run_main(self.wheel_path)
        self.assertEqual(exit_code, 0)
",tests/test_verify_wheel_sig.py,VerifyWheelSigTests,1,8.592166611791576e-10,"The method 'test_valid_signature' is a unit test that checks if a certain operation (likely related to a wheel file) exits with a code of 0, indicating success. Unit tests are crucial for ensuring code reliability and are typically retained unless they are redundant or replaced by more comprehensive tests. Since this test seems to serve a specific purpose of validating a signature, it is likely to be useful and therefore will survive."
survived,"    async def handler(env: messaging.Envelope) -> None:
        events.append(env)
",tests/test_message_bus.py,,1,5.60279640614594e-09,"The method 'handler' is an asynchronous function that appends an 'Envelope' object to a list called 'events'. This is a basic and common pattern in event-driven programming where events are collected for further processing. The method is simple, clear, and serves a specific purpose without any apparent issues or redundancies. Therefore, it is likely to be retained in the codebase unless there is a significant change in the design or requirements that makes this pattern obsolete."
survived,"def verify_environment() -> None:
    """"""Best-effort runtime dependency check.""""""
    try:
        import check_env  # type: ignore

        check_env.main([])
    except (ImportError, ModuleNotFoundError) as exc:  # pragma: no cover
        print(f""Environment verification failed: {exc}"")
    except Exception as exc:
        print(f""Unexpected error during environment verification: {exc}"")
        raise
",alpha_factory_v1/demos/alpha_agi_insight_v0/insight_demo.py,,1,2.5109990926928157e-08,"The method 'verify_environment' is a utility function designed to perform a runtime dependency check. It uses a try-except block to handle potential import errors and other exceptions, providing feedback on the environment's status. This kind of function is useful for ensuring that the necessary dependencies are available before proceeding with further operations, which is a common requirement in many applications. The use of 'check_env.main([])' suggests that it relies on an external module to perform the actual checks, which is a typical pattern for modular and maintainable code. Given its utility in verifying runtime conditions and handling exceptions gracefully, it is likely to be retained in the codebase."
survived,"def load_config(path: Path) -> dict:
    """"""Load a YAML configuration with a fallback parser.""""""
    if not path.exists():
        return {}
    text = path.read_text(encoding=""utf-8"")
    try:
        import yaml  # type: ignore

        return yaml.safe_load(text) or {}
    except Exception:
        cfg: dict[str, object] = {}
        for line in text.splitlines():
            if "":"" in line:
                key, val = line.split("":"", 1)
                val = val.strip()
                if val.replace(""."", """", 1).isdigit():
                    cfg[key.strip()] = float(val) if ""."" in val else int(val)
                else:
                    cfg[key.strip()] = val
        return cfg
",alpha_factory_v1/demos/alpha_agi_insight_v0/insight_demo.py,,1,4.944450477491054e-09,"The method 'load_config' is a utility function designed to load configuration data from a YAML file, with a fallback mechanism to parse the file manually if the YAML library fails. This is a useful and robust approach to ensure that configuration data can still be loaded even if the preferred method (using the YAML library) encounters an error. The method is well-structured, handles exceptions gracefully, and provides a fallback that can handle simple key-value pairs. Such utility functions are common in software projects for configuration management, and the presence of a fallback parser increases its reliability. Therefore, it is likely to be retained in the codebase."
survived,"def cytomat_rack_29mm_16(name: str):
  return _cytomat_rack(name=name, site_height=29, num_sites=16, model=""cytomat_rack_29mm_16"")
",pylabrobot/storage/cytomat/racks.py,,1,1.8189616842444243e-09,"The method `cytomat_rack_29mm_16` is a simple wrapper function that calls another function `_cytomat_rack` with specific parameters. This kind of function is often used to simplify the interface for users by providing a more descriptive or specific function name that sets certain parameters by default. Such functions are generally useful for code readability and maintainability, especially if the underlying function `_cytomat_rack` is used in multiple contexts with different parameters. Therefore, it is likely that this method will be Survived (1) as it serves a clear purpose in the codebase."
survived,"  async def set_temperature(self, temperature: float):
    print(f""Setting temperature to {temperature}"")
",pylabrobot/storage/chatterbox.py,IncubatorChatterboxBackend,0,0.9971990727096725,"The method 'set_temperature' is a simple asynchronous function that prints a message indicating the temperature being set. It doesn't perform any actual temperature setting operation, which might be expected from a method with this name. However, it could be a placeholder or a logging step in a larger system. Without additional context, it's difficult to determine its utility, but given its simplicity and lack of functionality, it might be considered for deletion unless it's part of a larger, necessary logging or debugging process."
survived,"  async def wait_for_transfer_station(self, occupied: bool = False):
    """"""Wait for the transfer station to be occupied, or unoccupied.""""""
    while (await self.get_overview_register()).transfer_station_occupied != occupied:
      await asyncio.sleep(1)
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,1.8189616842444243e-09,"The method 'wait_for_transfer_station' is a utility function that waits for a condition to be met (the transfer station being occupied or unoccupied). This is a common pattern in asynchronous programming where tasks need to wait for certain conditions before proceeding. The method is simple, clear, and serves a specific purpose, making it unlikely to be deleted unless the functionality it supports is no longer needed or is replaced by a more efficient mechanism. However, given the current context, it seems useful and well-implemented."
survived,"  async def stop_shaking(self):
    pass",pylabrobot/storage/backend.py,IncubatorBackend,1,0.0007096703410211238,"The method `stop_shaking` is defined but not implemented, as indicated by the `pass` statement. If this method is part of a larger class or module where it is expected to have functionality, it might be retained for future implementation. However, if it remains unimplemented and unused, it could be considered for deletion to clean up the codebase. Without additional context, it's more likely to be retained for potential future use."
survived,"  async def get_temperature(self) -> float:
    return (await self.get_incubation_query(""it"")).actual_value
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,1.6052280526088547e-09,"The method 'get_temperature' is an asynchronous function that retrieves a temperature value by calling another method 'get_incubation_query' with a parameter 'it'. The method seems to be well-defined and serves a specific purpose of fetching a temperature value, which is a common requirement in many applications, especially those dealing with environmental data, scientific experiments, or IoT devices. There is no indication that this method is redundant, obsolete, or poorly implemented. Therefore, it is likely to be retained in the codebase."
survived,"  async def setup(self):
    await self.wait_for_task_completion()
",pylabrobot/storage/cytomat/cytomat.py,CytomatChatterbox,1,7.582560422162384e-10,"The method 'setup' is an asynchronous function that calls another asynchronous method 'wait_for_task_completion'. This suggests that it is part of a larger asynchronous workflow, likely used to initialize or prepare some state before proceeding with other operations. Asynchronous programming is increasingly common in modern software development, especially in environments where non-blocking operations are crucial, such as web servers or applications with heavy I/O operations. Therefore, this method is likely to be useful and relevant in its context, suggesting it will survive."
survived,"  async def get_o2(self) -> CytomatIncupationResponse:
    return await self.get_incubation_query(""io"")
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,4.1399375473943306e-08,"The method `get_o2` is an asynchronous function that calls another method `get_incubation_query` with a specific parameter ""io"". The method seems to be part of a larger system dealing with incubation processes, possibly in a laboratory or industrial setting. The method name `get_o2` suggests it might be related to oxygen levels or similar measurements, which could be crucial in such environments. Without further context, it appears to be a specific utility function that serves a purpose in the system. Unless the system undergoes significant changes or the method is replaced by a more efficient or comprehensive solution, it is likely to survive."
survived,"  async def take_in_plate(self, plate: Plate, site: PlateHolder):
    await self.action_transfer_to_storage(site)
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,1.8189616842444243e-09,"The method 'take_in_plate' is an asynchronous function that takes a 'Plate' and a 'PlateHolder' as arguments and performs an action to transfer the plate to storage. This method seems to be part of a larger system that manages plates and their storage, likely in a laboratory or industrial setting. The method is specific and likely serves a necessary function within its context, suggesting it is not redundant or obsolete. Therefore, it is likely to be retained in the codebase."
survived,"  async def get_warning_register(self) -> WarningRegister:
    hex_value = await self.send_command(""ch"", ""bw"", """")
    for member in WarningRegister:
      if hex_value == member.value:
        return member

    await self.reset_error_register()
    raise Exception(f""Unknown warning register value: {hex_value}"")
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,4.599055376537186e-10,"The method 'get_warning_register' is well-structured and serves a clear purpose in the code. It asynchronously sends a command to retrieve a warning register value, checks it against known values, and handles unknown values by resetting the error register and raising an exception. This functionality is essential for error handling and system diagnostics, making it unlikely to be removed unless the entire warning register system is refactored or replaced. Therefore, the method is likely to survive."
survived,"  async def fetch_plate_to_loading_tray(self, plate_name: str) -> Plate:
    """"""Fetch a plate from the incubator and put it on the loading tray.""""""

    site = self.get_site_by_plate_name(plate_name)
    plate = site.resource
    assert plate is not None
    await self.backend.fetch_plate_to_loading_tray(plate)
    plate.unassign()
    self.loading_tray.assign_child_resource(plate)
    return plate
",pylabrobot/storage/incubator.py,Incubator,1,5.905303995456778e-10,"The method 'fetch_plate_to_loading_tray' is likely to survive because it performs a specific and necessary function within a larger system. It fetches a plate from an incubator and places it on a loading tray, which is a common operation in automated laboratory systems. The method is well-defined, uses asynchronous operations which are suitable for I/O-bound tasks, and includes assertions to ensure the presence of the plate. These characteristics suggest that the method is functional, relevant, and likely to be retained in the codebase."
survived,"  def __init__(self, port: str):
    super().__init__()
    self.io = Serial(
      port=port,
      baudrate=self.default_baud,
      bytesize=serial.EIGHTBITS,
      parity=serial.PARITY_EVEN,
      stopbits=serial.STOPBITS_ONE,
      write_timeout=1,
      timeout=1,
      rtscts=True,
    )
",pylabrobot/storage/cytomat/heraeus_cytomat_backend.py,HeraeusCytomatBackend,1,4.363462233903899e-09,"The method is a constructor for initializing an object with a serial connection. It uses a library (likely 'pyserial') to set up the serial communication parameters. This is a common and necessary setup for classes dealing with serial port communication, and there is no indication of redundancy or obsolescence in the code. Therefore, it is likely to be retained."
survived,"  async def get_error_register(self) -> ErrorRegister:
    hex_value = await self.send_command(""ch"", ""be"", """")
    for member in ErrorRegister:
      if hex_value == member.value:
        return member

    await self.reset_error_register()
    raise Exception(f""Unknown error register value: {hex_value}"")
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,3.581747929000289e-10,"The method 'get_error_register' is well-structured and serves a clear purpose: to retrieve an error register value and match it against known values. If the value is unknown, it resets the error register and raises an exception. This is a common pattern in error handling and device communication, ensuring robustness and clarity in the code. There is no indication of redundancy or inefficiency that would warrant deletion. Therefore, the method is likely to be retained."
survived,"  async def set_racks(self, racks: List[PlateCarrier]):
    await super().set_racks(racks)
    warnings.warn(""Cytomat racks need to be configured manually on each setup"")
",pylabrobot/storage/cytomat/heraeus_cytomat_backend.py,HeraeusCytomatBackend,1,3.653482080241728e-08,"The method 'set_racks' is an override of a superclass method, which suggests it is part of a larger class hierarchy and likely serves a specific purpose in the context of the application. The method includes a warning to inform users about a manual configuration requirement, indicating that it provides important information for the correct use of the system. This suggests that the method is still relevant and necessary for the application's functionality, even if it requires manual intervention. Therefore, it is likely to be retained."
survived,"  async def start_shaking(self, frequency: float):
    """"""Start shaking the incubator at the given frequency in Hz.""""""
    pass
",pylabrobot/storage/backend.py,IncubatorBackend,0,0.9999982396568657,"The method `start_shaking` is an asynchronous function that is designed to start shaking an incubator at a specified frequency. However, the method currently only contains a `pass` statement, meaning it has no implementation. Without any functionality, it doesn't serve any purpose in its current state. Unless there is a plan to implement this method in the future, it is likely to be deleted as it does not contribute to the codebase."
survived,"  def summary(self) -> str:
    def create_pretty_table(header, *columns) -> str:
      col_widths = [
        max(len(str(item)) for item in [header[i]] + list(columns[i])) for i in range(len(header))
      ]

      def format_row(row, border=""|"") -> str:
        return (
          f""{border} ""
          + "" | "".join(f""{str(row[i]).ljust(col_widths[i])}"" for i in range(len(row)))
          + f"" {border}""
        )

      def separator_line(cross: str = ""+"", line: str = ""-"") -> str:
        return cross + cross.join(line * (width + 2) for width in col_widths) + cross

      table = []
      table.append(separator_line())  # Top border
      table.append(format_row(header))
      table.append(separator_line())  # Header separator
      for row in zip(*columns):
        table.append(format_row(row))
      table.append(separator_line())  # Bottom border
      return ""\n"".join(table)

    header = [f""Rack {i}"" for i in range(len(self._racks))]
    sites = [
      [site.resource.name if site.resource else ""<empty>"" for site in reversed(rack.sites.values())]
      for rack in self._racks
    ]
    return create_pretty_table(header, *sites)
",pylabrobot/storage/incubator.py,Incubator,1,3.2241866333029355e-08,"The method 'summary' is a utility function that generates a formatted string representation of a table. It is useful for displaying data in a structured and readable format, which is a common requirement in many applications. The method is well-structured, with clear separation of concerns between formatting the table and generating the data to be displayed. It is likely to be retained as it provides a valuable functionality that can be reused in different contexts where data needs to be presented in a tabular format."
survived,"  async def send_command(self, command_type, command, params):
    print(
      ""cytomat"", self._assemble_command(command_type=command_type, command=command, params=params)
    )
    if command_type == ""ch"":
      return ""0""
    return ""0"" * 8
",pylabrobot/storage/cytomat/cytomat.py,CytomatChatterbox,1,1.2501528648238603e-09,"The method 'send_command' is a simple function that prints a command and returns a string based on the command type. It doesn't seem to have any issues or redundancies that would warrant its deletion. It serves a clear purpose of assembling and sending a command, which is likely part of a larger system. Without additional context indicating it's unused or replaced, it is likely to survive."
survived,"  async def get_temperature(self) -> float:
    raise NotImplementedError(""Temperature query not implemented yet"")
",pylabrobot/storage/cytomat/heraeus_cytomat_backend.py,HeraeusCytomatBackend,0,0.9999991684720096,"The method `get_temperature` is currently not implemented and raises a `NotImplementedError`. This suggests that the method is intended to be implemented in the future, but as it stands, it does not provide any functionality. If the method remains in this state without any implementation, it is likely to be deleted in the future to clean up the codebase. However, if there is a plan to implement it, it might survive. Without additional context on future plans, the method is more likely to be deleted."
survived,"  async def fetch_plate_to_loading_tray(self, plate: Plate, site=PlateHolder):
    """"""Fetch a plate from storage onto the transfer station, with gate open/close.""""""
    site = plate.parent
    assert isinstance(site, PlateHolder), ""Plate not in storage""
    m, n = self._site_to_m_n(site)
    await self._send_command(f""WR DM0 {m}"")  # carousel pos
    await self._send_command(f""WR DM5 {n}"")  # handler level
    await self._send_command(""ST 1905"")  # plate to transfer station
    await self._wait_ready()
    await self._send_command(""ST 1903"")  # terminate access
",pylabrobot/storage/cytomat/heraeus_cytomat_backend.py,HeraeusCytomatBackend,1,7.582560422162384e-10,"The method 'fetch_plate_to_loading_tray' is likely to survive because it appears to be a well-defined asynchronous function that performs a specific task of moving a plate from storage to a transfer station. It includes necessary assertions, command sending, and waiting for readiness, which are typical in robotic or automated systems. The method is likely part of a larger system and seems to be functioning as intended without any apparent issues or redundancies."
survived,"  async def get_swap_register(self) -> SwapStationState:
    value = await self.send_command(""ch"", ""sw"", """")
    return SwapStationState(
      position=SwapStationPosition(int(value[0])),
      load_status_front_of_gate=LoadStatusFrontOfGate(int(value[1])),
      load_status_at_processor=LoadStatusAtProcessor(int(value[2])),
    )
",pylabrobot/storage/cytomat/cytomat.py,CytomatBackend,1,1.1032560311263802e-09,"The method 'get_swap_register' is an asynchronous function that sends a command and processes the response to return a structured object of type 'SwapStationState'. This method is likely part of a larger system dealing with swap stations, possibly in a robotics or automation context. The method is well-defined, uses asynchronous programming which is modern and efficient, and returns a clear, structured result. There is no indication of redundancy or obsolescence in the method's functionality. Therefore, it is likely to be retained in the codebase."
survived,"  async def wait_for_transfer_station(self, occupied: bool = False):
    # send the command, but don't wait when we are in chatting mode.
    _ = await self.get_overview_register()
",pylabrobot/storage/cytomat/cytomat.py,CytomatChatterbox,1,6.023574641292144e-08,"The method `wait_for_transfer_station` is an asynchronous function that seems to be part of a larger system, likely involving some kind of automated process or robotics. The method sends a command and retrieves an overview register, which suggests it is performing a necessary operation in a sequence of tasks. The presence of the `occupied` parameter indicates that the method might be used to handle different states or conditions, which adds flexibility to its use. Since the method is performing a specific task and is part of an asynchronous workflow, it is likely to be useful in its context. Therefore, it is more likely to be retained in the codebase."
survived,"  def from_resp(self, resp) -> ""OverviewRegisterState"":
    binary_value = hex_to_binary(resp)
    return OverviewRegisterState(
      **{member.name.lower(): binary_value[member.value] == ""1"" for member in OverviewRegister}
    )
",pylabrobot/storage/cytomat/schemas.py,OverviewRegisterState,1,2.0611536181902033e-09,"The method 'from_resp' is likely to be Survived (1) because it appears to be a utility function that converts a response into an instance of 'OverviewRegisterState'. This kind of method is typically essential for parsing and transforming data, which is a common requirement in software applications. Additionally, the method uses a clear and concise approach to map binary values to the state, indicating it is well-implemented and serves a specific purpose in the codebase."
survived,"def test_template_validator_missing_variable() -> None:
    validator = TemplateValidator()
    case = TemplateTestCase(context={""name"": ""Alice""})
    result = validator.validate(""Hello {{ name }} from {{ city }}"", [case])
    assert not result.success
    assert any(""missing variables"" in e for e in result.errors)
",tests/test_template_validator.py,,1,1.955568070542584e-08,"The method 'test_template_validator_missing_variable' is a unit test designed to check the functionality of a template validator. It ensures that the validator correctly identifies missing variables in a template string. This is a crucial part of testing the robustness and reliability of the template validation process. Since testing for missing variables is a common and necessary feature in template validation, this method is likely to be retained as part of the test suite to ensure the validator works as expected."
survived,"    def showcase(self, limit: int = 5) -> List[Tuple[str, float]]:
        """"""Return top rated templates as ``[(slug, average)]``.""""""
        ratings = self._load_ratings()
        avgs = [(slug, sum(vals) / len(vals)) for slug, vals in ratings.items() if vals]
        avgs.sort(key=lambda t: t[1], reverse=True)
        return avgs[:limit]
",src/meta_agent/template_sharing.py,TemplateSharingManager,1,1.9171715133907573e-10,"The method 'showcase' is likely to survive because it provides a useful functionality by returning the top-rated templates based on their average ratings. This kind of method is often essential in applications where showcasing top items is necessary, such as in recommendation systems or content management systems. The method is also well-defined, with a clear purpose and efficient implementation, making it a valuable part of the codebase."
survived,"def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]
    req_txt = repo_root / ""alpha_factory_v1"" / ""backend"" / ""requirements.txt""
    lock_file = repo_root / ""alpha_factory_v1"" / ""backend"" / ""requirements-lock.txt""

    with tempfile.TemporaryDirectory() as tmpdir:
        out_path = Path(tmpdir) / ""requirements.lock""
        pip_compile = shutil.which(""pip-compile"")
        if pip_compile:
            cmd = [pip_compile]
        else:
            cmd = [sys.executable, ""-m"", ""piptools"", ""compile""]
        cmd += [""--quiet"", ""--generate-hashes"", str(req_txt), ""-o"", str(out_path)]
        result = subprocess.run(cmd, capture_output=True, text=True)
        sys.stdout.write(result.stdout)
        sys.stderr.write(result.stderr)
        if result.returncode != 0:
            return result.returncode
        if out_path.read_bytes() != lock_file.read_bytes():
            sys.stderr.write(
                ""alpha_factory_v1/backend/requirements-lock.txt is outdated. Run 'pip-compile --quiet --generate-hashes alpha_factory_v1/backend/requirements.txt'\n""
            )
            return 1
    return 0
",scripts/verify_backend_requirements_lock.py,,1,3.850741907939403e-09,"The method 'main' is a utility function that automates the process of checking and updating a requirements lock file for a Python project. This is a common task in software development to ensure that dependencies are up-to-date and consistent across environments. The function uses standard libraries and tools like 'pip-compile' and 'subprocess', which are widely used in Python projects. The method is well-structured, handles errors, and provides useful output to the user. Given its utility and the fact that it addresses a common need in Python project management, it is likely to be retained in the codebase."
survived,"    async def verify_token(
        credentials: HTTPAuthorizationCredentials = Depends(security),
    ) -> None:
        if credentials.credentials != API_TOKEN:
            raise HTTPException(status_code=403, detail=""Invalid token"")
",src/interface/api_server.py,,1,9.237449576640118e-09,"The method 'verify_token' is a crucial part of an authentication process, ensuring that only requests with a valid token are processed. This is a common and necessary security measure in web applications to prevent unauthorized access. Given its importance in maintaining the security of the application, it is unlikely to be deleted unless replaced by a more secure or efficient method."
survived,"        def __init__(self, app: FastAPI, limit: int = 60, window: int = 60) -> None:
            super().__init__(app)
            self.limit = int(os.getenv(""API_RATE_LIMIT"", str(limit)))
            self.window = window
            self.counters: dict[str, tuple[int, float]] = {}
            self.lock = asyncio.Lock()
",src/interface/api_server.py,SimpleRateLimiter,1,1.275190675769241e-07,"The method is a constructor for a class that initializes important attributes for rate limiting in a FastAPI application. It sets up a default rate limit and window, and allows for these to be overridden by environment variables. The use of asyncio.Lock suggests that the method is designed to be thread-safe, which is important for web applications. These functionalities are essential for managing API rate limits effectively, making it unlikely that this method would be deleted."
survived,"        async def run(self, prompt: str) -> str:  # pragma: no cover - async stub
            return ""done""
",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_agents.py,Ctx,0,0.999860177965895,"The method is a simple asynchronous function that takes a string input and returns a fixed string ""done"". It is marked with a pragma to exclude it from coverage analysis, indicating it might be a placeholder or a stub for future implementation. However, as it stands, it doesn't perform any meaningful operation related to the input parameter, which might lead to its deletion unless it is expanded to fulfill a specific purpose."
survived,"    def click(self, *a, **k):
        pass
",tests/test_selfheal_import_stubs.py,DummyButton,1,3.1201906230699086e-05,"The method 'click' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it is a placeholder for future functionality or is meant to be overridden in a subclass. If the method is part of a base class or interface that is intended to be extended, it is likely to survive. However, if it is not used or extended anywhere in the codebase, it might be deleted during code cleanup. Without additional context, it's more likely to survive as a placeholder or interface method."
survived,"def test_rate_limit_exceeded() -> None:
    port = _free_port()
    env = os.environ.copy()
    env[""API_RATE_LIMIT""] = ""3""
    proc = _start_server(port, env)
    url = f""http://127.0.0.1:{port}""
    headers = {""Authorization"": ""Bearer test-token""}
    try:
        _wait_running(url, headers)
        assert httpx.get(f""{url}/runs"", headers=headers).status_code == 200
        assert httpx.get(f""{url}/runs"", headers=headers).status_code == 200
        r = httpx.get(f""{url}/runs"", headers=headers)
        assert r.status_code == 429
    finally:
        proc.terminate()
        proc.wait(timeout=5)",tests/test_api_server_subprocess.py,,1,4.599055376537186e-10,"The method `test_rate_limit_exceeded` is a unit test designed to verify that the rate limiting feature of an API is functioning correctly. It sets up an environment with a specific rate limit, makes requests to the server, and checks if the server responds with a 429 status code after the limit is exceeded. This is a crucial test for ensuring the reliability and correctness of the rate limiting feature, which is important for preventing abuse and ensuring fair usage of the API. Therefore, this method is likely to be retained as part of the test suite."
survived,"def format_values(node, values):
    return '{}({})'.format(node.__class__.__name__, ',\n    '.join(values))
",test/integration/expected_out/issue192.py,,1,1.8189616842444243e-09,"The method 'format_values' is a utility function that formats a string representation of a node and its values. It is a simple and clear implementation that uses Python's string formatting capabilities to achieve its purpose. Such utility functions are often useful in various contexts, such as logging, debugging, or displaying structured data. Unless there is a specific reason to remove it, such as redundancy or a change in requirements, this method is likely to survive because it serves a clear purpose and is implemented efficiently."
survived,"def test_offline_placeholders() -> None:
    """"""_ensure_offline should write placeholders and generator uses them.""""""
    with tempfile.TemporaryDirectory() as tmpdir:
        with (
            patch.dict(os.environ, {""OFFLINE_DATA_DIR"": tmpdir}),
            patch(""urllib.request.urlopen"", side_effect=Exception),
        ):
            mod = importlib.reload(data_feeds)
            # files should contain single placeholder row
            for name, row in mod._DEFAULT_ROWS.items():
                with open(Path(tmpdir) / name, newline="""") as f:
                    rows = list(csv.DictReader(f))
                assert rows == [row]

            async def get_one() -> dict[str, float | str]:
                it = mod.stream_macro_events(live=False)
                return await anext(it)

            evt = asyncio.run(get_one())
            assert evt[""fed_speech""] == ""No speech""
            assert evt[""yield_10y""] == 4.4
            assert evt[""yield_3m""] == 4.5
            assert evt[""stable_flow""] == 25.0
            assert evt[""es_settle""] == 5000.0

        importlib.reload(data_feeds)",tests/test_offline_data_feeds.py,,1,2.3823698451773172e-07,"The method 'test_offline_placeholders' is a test function that verifies the behavior of a module when offline placeholders are used. It is a part of the test suite, which is crucial for ensuring code reliability and correctness. Test functions are generally not deleted unless they are redundant or replaced by more comprehensive tests. This function appears to be well-defined and serves a specific purpose in testing the offline functionality of the 'data_feeds' module, making it unlikely to be deleted."
survived,"def test_update_after_sampling():
    sched = JitScheduler.init(max_tokens=8, max_seqs=1, key=jax.random.PRNGKey(0))
    toks = hax.named(jnp.array([5], dtype=jnp.int32), ""position"")
    seqs = hax.named(jnp.array([0], dtype=jnp.int32), ""position"")

    sched = sched.update_after_sampling(toks, seqs, 1)
    assert jnp.array_equal(sched.generated_tokens[""position"", hax.ds(0, 1)].array, jnp.array([5], dtype=jnp.int32))
    assert sched.num_generated_tokens == 1
    assert sched.num_queued_tokens == 1",tests/test_jit_scheduler.py,,1,1.2098660619383578e-06,"The method `test_update_after_sampling` is a unit test for the `update_after_sampling` function of the `JitScheduler` class. Unit tests are generally crucial for ensuring the correctness of code, especially in complex systems like schedulers. This test checks if the `update_after_sampling` method correctly updates the scheduler's state after sampling, which is a critical operation in many applications. The presence of assertions to verify the expected behavior indicates that this test is valuable for maintaining code reliability. Therefore, it is likely to be retained."
survived,"def _lambda11():
    draw.get(100)()
    draw.get(800)()
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,0,0.9984988179739497,"The method _lambda11() is a private method indicated by the underscore prefix, suggesting it is intended for internal use within a module or class. The method calls two functions retrieved from a 'draw' object using the 'get' method with specific keys (100 and 800). Without additional context on what 'draw' is or what these functions do, it's difficult to determine the utility or necessity of this method. However, the method itself is very simple and lacks any error handling or documentation, which might suggest it is either a placeholder or a very specific utility function. If the 'draw' object and its methods are crucial to the application, this method might survive. However, if this method is not used elsewhere or if the 'draw' object is deprecated, it might be deleted. Given the lack of context and the simplicity of the method, it is more likely to be deleted unless it serves a specific, necessary purpose."
survived,"def _lambda13():
    draw.get(1000)()
    draw.get(6000)()
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,1,6.605216531020474e-05,"The method _lambda13() is a private method indicated by the underscore prefix, suggesting it is intended for internal use within a module or class. The method calls two functions, draw.get(1000)() and draw.get(6000)(), which implies it relies on the 'draw' object having a 'get' method that returns callable objects. Without additional context on the 'draw' object and its 'get' method, it's difficult to determine the utility or correctness of this method. However, the method itself is very simple and doesn't perform any complex operations or have any apparent issues. If the 'draw' object and its methods are correctly implemented and used elsewhere in the code, this method is likely to survive. However, if the 'draw' object is deprecated or the method is unused, it might be deleted. Without more context, the method seems functional and could be retained for its intended purpose."
survived,"def _lambda4():
    draw.get(10)()
    draw.get(40)()
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,0,0.9999251538028718,"The method _lambda4() is a private method (indicated by the underscore) and seems to be part of a larger codebase where 'draw' is likely a dictionary or similar structure with callable objects. However, without context on what 'draw' is or what the callable objects do, it's difficult to determine the utility of this method. If 'draw' is properly defined and used elsewhere in the code, this method might be useful. However, if 'draw' is undefined or this method is not used anywhere, it might be considered for deletion. Given the lack of context, it's more likely to be deleted unless proven otherwise."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    srcLines = [""package main"", """", ""import ("", ""    \""fmt\"""", ""    \""go/ast\"""", ""    \""go/parser\"""", ""    \""go/token\"""", ""    \""io/ioutil\"""", ""    \""os\"""", ""    \""sort\"""", "")"", """", ""func main() {"", ""    if len(os.Args) != 2 {"", ""        fmt.Println(\""usage ff <go source filename>\"")"", ""        return"", ""    }"", ""    src, err := ioutil.ReadFile(os.Args[1])"", ""    if err != nil {"", ""        fmt.Println(err)"", ""        return"", ""    }"", ""    fs := token.NewFileSet()"", ""    a, err := parser.ParseFile(fs, os.Args[1], src, 0)"", ""    if err != nil {"", ""        fmt.Println(err)"", ""        return"", ""    }"", ""    f := fs.File(a.Pos())"", ""    m := make(map[string]int)"", ""    ast.Inspect(a, func(n ast.Node) bool {"", ""        if ce, ok := n.(*ast.CallExpr); ok {"", ""            start := f.Offset(ce.Pos())"", ""            end := f.Offset(ce.Lparen)"", ""            m[string(src[start:end])]++"", ""        }"", ""        return true"", ""    })"", ""    cs := make(calls, 0, len(m))"", ""    for k, v := range m {"", ""        cs = append(cs, &call{k, v})"", ""    }"", ""    sort.Sort(cs)"", ""    for i, c := range cs {"", ""        fmt.Printf(\""%-20s %4d\\n\"", c.expr, c.count)"", ""        if i == 9 {"", ""            break"", ""        }"", ""    }"", ""}"", """", ""type call struct {"", ""    expr  string"", ""    count int"", ""}"", ""type calls []*call"", """", ""func (c calls) Len() int           { return len(c) }"", ""func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }"", ""func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }""]
    src = join(srcLines, ""\n"")
    freq = {}
    i = 0
    order = []
    while i < len(src):
        ch = src[i:i + 1]
        if (ch >= ""A"" and ch <= ""Z"") or (ch >= ""a"" and ch <= ""z"") or ch == ""_"":
            j = i + 1
            while j < len(src) and isAlphaNumDot(src[j:j + 1]):
                j = j + 1
            token = src[i:j]
            k = j
            while k < len(src):
                cc = src[k:k + 1]
                if cc == "" "" or cc == ""\t"" or cc == ""\n"" or cc == ""\r"":
                    k = k + 1
                else:
                    break
            if k < len(src) and src[k:k + 1] == ""("":
                p = i - 1
                while p >= 0 and (src[p:p + 1] == "" "" or src[p:p + 1] == ""\t""):
                    p = p - 1
                skip = False
                if p >= 3:
                    before = src[p - 3:p + 1]
                    if before == ""func"":
                        skip = True
                if not skip:
                    if token in freq:
                        freq[token] = freq[token] + 1
                    else:
                        freq[token] = 1
                        order = order + [token]
            i = j
        else:
            i = i + 1
    pairs = []
    for t in order:
        pairs = pairs + [{""expr"": t, ""count"": freq[t]}]
    pairs = sortPairs(pairs)
    idx = 0
    while idx < len(pairs) and idx < 10:
        p = pairs[idx]
        print(p.get(""expr"") + "" "" + str(p.get(""count"")))
        idx = idx + 1
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/function-frequency.py,,1,1.7603431343301488e-06,"The method is a complete implementation of a main function that reads a Go source file, parses it, and counts the frequency of function calls. It includes performance benchmarking and outputs the top 10 most frequent function calls. The method is functional, well-structured, and serves a specific purpose, making it unlikely to be deleted."
survived,"def b(x, y):
    pass
",tests/rosetta/transpiler/Python/function-prototype.py,,0,0.9999999586006244,"The method 'b' is currently a placeholder function with no implementation (indicated by the 'pass' statement). If this function is part of a larger codebase, it might be intended for future development or to be overridden in a subclass. However, if it remains unimplemented and unused, it is likely to be deleted in future code clean-ups to maintain code quality and avoid unnecessary clutter. Without further context on its intended use or any documentation indicating future plans for this function, the likelihood of it being deleted is higher."
survived,"def ftree(g, x, y, dist, dir, d):
    rad = dir * PI / 180.0
    x2 = x + dist * _sin(rad)
    y2 = y - dist * _cos(rad)
    bresenham(int(x), int(y), int(x2), int(y2), g)
    if d > 0:
        ftree(g, x2, y2, dist * frac, dir - angle, d - 1)
        ftree(g, x2, y2, dist * frac, dir + angle, d - 1)
",tests/rosetta/transpiler/Python/fractal-tree.py,,1,4.1399375473943306e-08,"The method 'ftree' is a recursive function that appears to be part of a fractal tree drawing algorithm. It uses trigonometric functions to calculate new positions and recursively draws branches using the 'bresenham' function. This type of function is typical in graphics programming and educational contexts to demonstrate recursion and fractal geometry. Given its specific purpose and the fact that it is a complete and functional piece of code, it is likely to be retained in the codebase for its intended use in generating fractal trees."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/forest-fire.py,,1,8.76424914819242e-08,"The method `_now()` is a utility function that generates a pseudo-random number based on a global seed if `_now_seeded` is True, otherwise it returns the current time in nanoseconds. This function is likely part of a larger system that requires a consistent and repeatable pseudo-random number generation when seeded, which can be useful for testing or simulations. The use of global variables like `_now_seed` and `_now_seeded` suggests that this function is part of a controlled environment where these variables are managed appropriately. Given its utility in providing both seeded random numbers and current time, it is likely to be retained in the codebase."
survived,"def partialSeries(f):
    out = """"
    i = 0
    while i < 6:
        out = out + "" "" + padFloat5(extract(f, i), 8) + "" ""
        i = i + 1
    return out
",tests/rosetta/transpiler/Python/formal-power-series.py,,0,0.9999999992417439,"The method 'partialSeries' is likely to be deleted (0) because it relies on two undefined functions, 'padFloat5' and 'extract'. Without these functions being defined or imported, the method cannot function correctly. Additionally, the method has a hardcoded loop limit of 6, which may not be flexible enough for different use cases. These factors suggest that the method is either incomplete or not robust enough for production use, leading to its potential deletion."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/floyd-warshall-algorithm.py,,1,7.3382086014706e-07,"The method _now() is a utility function that generates a pseudo-random number based on a seed if _now_seeded is True, or returns the current time in nanoseconds if not. This function is useful for testing or scenarios where deterministic behavior is needed. It is unlikely to be deleted because it serves a specific purpose in controlling randomness and time-based operations, which are common needs in software development."
survived,"def padFloat5(x, width):
    s = fmtF5(x)
    while len(s) < width:
        s = "" "" + s
    return s
",tests/rosetta/transpiler/Python/formal-power-series.py,,1,2.998960815863541e-09,"The method `padFloat5` is a utility function that pads a formatted float string to a specified width. It uses a helper function `fmtF5` to format the float, and then adds spaces to the left until the string reaches the desired width. This type of function is commonly used in formatting outputs for display purposes, such as in reports or console outputs. Since formatting and aligning text is a frequent requirement in many applications, this method is likely to be useful and thus, it will survive."
survived,"def padLeft(s, w):
    res = """"
    n = w - len(s)
    while n > 0:
        res = res + "" ""
        n = n - 1
    return res + s
",tests/rosetta/transpiler/Python/functional-coverage-tree.py,,1,1.1253518384332553e-07,"The method 'padLeft' is a simple utility function that pads a given string 's' with spaces on the left to ensure it reaches a specified width 'w'. This type of function is commonly used in formatting tasks, such as aligning text in console outputs or reports. While the function is basic, it serves a clear purpose and is likely to be useful in various contexts where text alignment is needed. Therefore, it is likely to survive as it provides a straightforward solution to a common problem."
survived,"def sortPairs(xs):
    arr = xs
    i = 1
    while i < len(arr):
        j = i
        while j > 0 and (int(arr[j - 1].get(""count""))) < (int(arr[j].get(""count""))):
            tmp = arr[j - 1]
            arr[j - 1] = arr[j]
            arr[j] = tmp
            j = j - 1
        i = i + 1
    return arr
",tests/rosetta/transpiler/Python/function-frequency.py,,1,1.0129988107056774e-05,"The method 'sortPairs' is a custom implementation of the insertion sort algorithm, which sorts a list of dictionaries based on the 'count' key in descending order. While the method is functional, it is not efficient for large datasets compared to built-in sorting functions like Python's 'sorted()' with a key parameter. However, the method is likely to survive because it demonstrates a basic algorithmic concept and might be used for educational purposes or in contexts where built-in functions are not available or desired."
survived,"def _lambda2(n):
    b0 = extract(b, 0)
    if b0 == 0.0:
        return (0.0 / 0.0)
    s = extract(a, n)
    k = 1
    while k <= n:
        s = s - extract(b, k) * extract(q, n - k)
        k = k + 1
    return s // b0
",tests/rosetta/transpiler/Python/formal-power-series.py,,0,0.99999998813888,"The method `_lambda2` is likely to be deleted for several reasons:

1. **Division by Zero**: The line `return (0.0 / 0.0)` is problematic as it will always result in a NaN (Not a Number) value, which is generally not a desired outcome in computations.

2. **Undefined Variables**: The variables `a`, `b`, and `q` are used in the function but are not defined within the function or passed as parameters. This will lead to a NameError when the function is executed.

3. **Integer Division**: The use of `//` for division in `return s // b0` suggests integer division, but `b0` is a float (as it is compared to `0.0`). This could lead to unexpected results or errors if `s` is not an integer.

4. **Lack of Context**: The function relies on an `extract` function, which is not defined or explained. Without knowing what `extract` does, it's hard to ensure the correctness of the function.

5. **Code Quality**: The function lacks comments and clear variable names, making it difficult to understand its purpose and logic.

Due to these issues, the function is likely to be considered for deletion unless it is revised and corrected."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/four-is-the-number-of-letters-in-the-....py,,1,1.3440409770490404e-08,"The method `_now()` is a utility function that generates a pseudo-random number based on a global seed if `_now_seeded` is True, otherwise it returns the current time in nanoseconds. This function is not directly related to any specific business logic or application functionality, making it a general-purpose utility. Such utility functions are often retained as they can be useful in various contexts, especially for testing or generating unique identifiers. Therefore, it is likely to survive."
survived,"def capitalize(s):
    if len(s) == 0:
        return s
    return s[0:1].upper() + """".join(s[1:len(s)])
",tests/rosetta/transpiler/Python/four-is-magic.py,,0,0.9999967112522585,"The method 'capitalize' is a basic utility function that capitalizes the first letter of a string. While Python's standard library already provides a 'capitalize' method for strings, this custom implementation might still be useful in certain contexts where a custom behavior is needed or for educational purposes. However, given that it replicates existing functionality without significant improvement or additional features, it is likely to be considered redundant in most practical applications. Therefore, it is more likely to be deleted in favor of using the built-in method."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/function-frequency.py,,1,1.637377179507321e-07,"The method _now() is a utility function that generates a pseudo-random number based on a global seed if it is set, or returns the current time in nanoseconds if not. This kind of function can be useful in scenarios where deterministic behavior is needed for testing or simulation purposes, as well as when a fallback to real-time is acceptable. The use of global variables is generally discouraged, but in this context, it serves a specific purpose. Given its utility and the fact that it doesn't have any obvious flaws or redundancies, it is likely to be retained in the codebase."
survived,"def formatFloat(f, prec):
    scale = pow10(prec)
    scaled = (f * scale) + 0.5
    n = (int(scaled))
    digits = str(n)
    while len(digits) <= prec:
        digits = ""0"" + digits
    intPart = digits[0:len(digits) - prec]
    fracPart = digits[len(digits) - prec:len(digits)]
    return intPart + ""."" + fracPart
",tests/rosetta/transpiler/Python/formatted-numeric-output.py,,1,6.825604231969389e-08,"The method 'formatFloat' is a utility function that formats a floating-point number to a specified precision. It is a common requirement in many applications to control the number of decimal places for display or further processing. The method uses basic arithmetic and string manipulation to achieve this, which is a straightforward and efficient approach. There is no indication that this method is obsolete or redundant, as it serves a clear purpose and does not rely on deprecated features. Therefore, it is likely to be retained in the codebase."
survived,"def sub(a, b):
    return newFps(lambda n: extract(a, n) - extract(b, n))
",tests/rosetta/transpiler/Python/formal-power-series.py,,1,4.4508487281649027e-07,"The method 'sub' is a simple function that takes two arguments 'a' and 'b', and returns the result of a lambda function. The lambda function uses 'extract' on both 'a' and 'b' with 'n' as a parameter, and then subtracts the result of 'b' from 'a'. The result is then passed to 'newFps'. Without additional context on what 'newFps' and 'extract' do, it's difficult to determine the utility of this function. However, the function itself is syntactically correct and performs a basic operation. Unless 'newFps' or 'extract' are deprecated or the function is redundant in the context it is used, there is no immediate reason for it to be deleted. Therefore, it is likely to survive."
survived,"def pow10(n):
    r = 1.0
    i = 0
    while i < n:
        r = r * 10.0
        i = i + 1
    return r
",tests/rosetta/transpiler/Python/functional-coverage-tree.py,,1,1.1478768974997603e-05,"The method 'pow10' is a simple implementation of calculating 10 raised to the power of 'n'. It uses a loop to multiply 10.0 by itself 'n' times. While this function is straightforward, it is not the most efficient way to compute powers of 10, especially since Python has a built-in power operator '**' and a function 'math.pow' that can achieve the same result more efficiently. However, the function is correct and serves its purpose without any errors. It is likely to survive because it is functional and correct, even if not optimal."
survived,"    def test_missing_spec_skips_check(self) -> None:
        fake_mod = types.SimpleNamespace(__spec__=None)

        def _fake_import(name: str, *args: Any, **kwargs: Any) -> object:
            if name == ""openai_agents"":
                return fake_mod
            return importlib.import_module(name, *args, **kwargs)

        def _fake_find_spec(name: str, *args: Any, **kwargs: Any) -> object:
            if name == ""openai_agents"":
                return object()
            if name == ""agents"":
                return None
            return importlib.util.find_spec(name, *args, **kwargs)

        with (
            mock.patch(""importlib.import_module"", side_effect=_fake_import),
            mock.patch(""importlib.util.find_spec"", side_effect=_fake_find_spec),
        ):
            self.assertTrue(preflight.check_openai_agents_version())
",tests/test_preflight_openai_agents_version.py,TestPreflightOpenAIAgentsVersion,1,2.1024340680345882e-07,"The method 'test_missing_spec_skips_check' is a unit test designed to verify the behavior of the 'preflight.check_openai_agents_version()' function when certain conditions are met. It uses mocking to simulate specific scenarios, such as when the '__spec__' attribute is missing or when certain modules cannot be found. This kind of test is crucial for ensuring that the code behaves correctly under edge cases and unexpected conditions. Since testing is an essential part of software development for maintaining code quality and reliability, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered."
survived,"    def test_reset_batch_matches_vector_env(self):
        env_fn = lambda: ce.CurriculumEnv(genome=ce.EnvGenome(max_steps=10), size=6)
        vec = gym.vector.SyncVectorEnv([env_fn for _ in range(3)])
        obs_vec, _ = vec.reset()
        env = env_fn()
        obs, infos = env.reset_batch(3)
        self.assertEqual(obs.shape, obs_vec.shape)
        self.assertEqual(len(infos), 3)
",alpha_factory_v1/tests/test_aiga_meta_evolution.py,CurriculumEnvTest,1,2.998960815863541e-09,"The method `test_reset_batch_matches_vector_env` is a unit test that checks the functionality of resetting environments in a vectorized environment setup. It ensures that the observations and information returned by a batch reset match the expected shapes and lengths. This is a crucial part of testing the integration between custom environments and vectorized environments, which is a common pattern in reinforcement learning setups. Since it serves a clear purpose in verifying the correctness of the environment's behavior, it is likely to be retained."
survived,"    def setUp(self) -> None:
        sys.modules.pop(""agents"", None)
        sys.modules.pop(""alpha_factory_v1.backend.agent_factory"", None)
        importlib.invalidate_caches()

        orig_import_module = importlib.import_module

        def _fake_import(name: str, *args: object, **kwargs: object) -> object:
            if name == ""agents"":
                raise ModuleNotFoundError
            return orig_import_module(name, *args, **kwargs)

        with mock.patch(""importlib.import_module"", side_effect=_fake_import):
            af = orig_import_module(""alpha_factory_v1.backend.agent_factory"")
            self.af = importlib.reload(af)
",tests/test_agent_factory.py,TestAgentFactory,1,7.73442280641062e-08,"The method setUp is part of a test setup process, typically used in unit testing frameworks like unittest in Python. It is designed to prepare the test environment before each test case runs. The method clears specific modules from sys.modules, invalidates import caches, and mocks the importlib.import_module function to simulate a ModuleNotFoundError for a specific module. This setup is crucial for ensuring that tests run in a controlled and isolated environment, especially when testing module imports and dependencies. Therefore, it is unlikely to be deleted as it serves a specific purpose in the testing process."
survived,"    def test_auto_select_model_fallbacks(self) -> None:
        combos = [
            ({""OPENAI_API_KEY"": ""1""}, ""gpt-4o-mini""),
            ({""ANTHROPIC_API_KEY"": ""1""}, ""claude-3-sonnet-20240229""),
            ({""LLAMA_MODEL_PATH"": ""model.bin""}, ""local-llama3-8b-q4""),
            ({}, ""local-sbert""),
        ]
        for env, expected in combos:
            with self.subTest(env=env):
                with mock.patch.dict(os.environ, env, clear=True):
                    self.assertEqual(self.af._auto_select_model(), expected)
",tests/test_agent_factory.py,TestAgentFactory,1,2.3355930333443423e-09,"The method `test_auto_select_model_fallbacks` is a unit test designed to verify the behavior of the `_auto_select_model` method under different environmental conditions. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with different configurations or dependencies. This test method uses parameterized testing to check multiple scenarios, which is a good practice in software testing. Given its role in maintaining code quality and its structured approach, it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/python_auto.py,,1,1.955568070542584e-08,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in various contexts where data needs to be formatted for display or logging purposes. Its simplicity and general applicability make it likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/min_max_builtin.py,,1,5.60279640614594e-09,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in many programming scenarios where data needs to be formatted for display or logging. Its simplicity and general applicability suggest that it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/sum_builtin.py,,1,1.8189616842444243e-09,"The method _fmt is a utility function that formats different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in many programming scenarios where data needs to be formatted for display or logging. Since it provides a clear and concise way to handle multiple data types, it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/pure_fold.py,,1,4.363462233903899e-09,"The method _fmt is a utility function that formats different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in various contexts where data needs to be formatted for display or logging. Its simplicity and general applicability suggest that it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/bool_chain.py,,1,1.1861120010657661e-08,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is often useful in various contexts where data needs to be consistently formatted for output or logging. Given its general utility and lack of any apparent issues, it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/append_builtin.py,,1,1.1861120010657661e-08,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is often useful in data processing or logging tasks where consistent string representation is needed. Given its general utility and lack of any apparent issues, it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/map_assign.py,,1,2.646573631904765e-09,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in various contexts where data needs to be formatted for display or logging purposes. Given its utility and the fact that it handles common data types, it is likely to be retained in the codebase."
survived,"def _fmt(v):
    if isinstance(v, list):
        return "" "".join((_fmt(x) for x in v))
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)
",tests/machine/x/python/fun_three_args.py,,1,3.3982678079468468e-09,"The method _fmt is a utility function designed to format different types of input values into strings. It handles lists by recursively formatting each element and joining them with spaces, converts floats that are whole numbers into integers, and converts other types directly to strings. This kind of utility function is generally useful in many programming scenarios where data needs to be consistently formatted for output or logging. Its simplicity and general applicability suggest that it is likely to be retained in the codebase."
survived,"def _start_demo_server(port: int, env: dict[str, str] | None = None) -> subprocess.Popen[bytes]:
    cmd = [
        sys.executable,
        ""-m"",
        ""alpha_factory_v1.demos.alpha_agi_insight_v1.src.interface.api_server"",
        ""--host"",
        ""127.0.0.1"",
        ""--port"",
        str(port),
    ]
    return subprocess.Popen(cmd, env=env or os.environ.copy())
",tests/test_api_server_subprocess.py,,1,3.850741907939403e-09,"The method _start_demo_server is likely to survive because it serves a specific purpose of starting a demo server for a given application. It is a utility function that encapsulates the logic for launching a subprocess with specific command-line arguments, which is a common requirement in many applications for testing or demonstration purposes. The method is also flexible, allowing for an optional environment variable dictionary to be passed, which enhances its usability in different contexts. Unless the application architecture changes significantly or the demo server is no longer needed, this method is likely to remain useful."
survived,"    def fake_improve(repo_url: str, p_file: str, metric_file: str, log_file: str):
        click.echo(""score delta: 1.0"")
        return 1.0, tmp_path
",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_demo_cli.py,,0,0.9999999973534264,"The method 'fake_improve' is likely to be deleted because it appears to be a placeholder or a mock function. The function name 'fake_improve' suggests it is not intended for production use. Additionally, it returns a hardcoded score delta of 1.0 without performing any actual computation or improvement, which indicates it might be used for testing or demonstration purposes only. Such functions are typically removed or replaced with actual implementations in a production environment."
survived,"    def test_build_rest_none(self) -> None:
        mod_name = ""alpha_factory_v1.backend.orchestrator""
        with mock.patch.dict(sys.modules, {""fastapi"": None}):
            orch = importlib.reload(importlib.import_module(mod_name))
            self.assertIsNone(orch._build_rest({}))
        importlib.reload(orch)
",tests/test_orchestrator_no_fastapi.py,TestNoFastAPI,1,1.3440409770490404e-08,"The method 'test_build_rest_none' is a unit test that checks the behavior of a module when 'fastapi' is set to None in 'sys.modules'. This is a valid test case to ensure that the module 'alpha_factory_v1.backend.orchestrator' can handle the absence of 'fastapi' gracefully. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, this method is likely to be retained as part of the test suite."
deleted,"    def _get_email_body(self, msg):
        if ""parts"" in msg[""payload""]:
            for part in msg[""payload""][""parts""]:
                if part[""mimeType""] == ""text/plain"":
                    return base64.urlsafe_b64decode(part[""body""][""data""]).decode(
                        ""utf-8""
                    )
        elif msg[""payload""].get(""mimeType"") == ""text/plain"":
            return base64.urlsafe_b64decode(msg[""payload""][""body""][""data""]).decode(
                ""utf-8""
            )
        return ""This email does not contain a text body.""
",autogpt_platform/backend/backend/blocks/google/gmail.py,GmailGetThreadBlock,1,1.1032560311263802e-09,"The method '_get_email_body' is a utility function that extracts the plain text body from an email message. It handles both cases where the email body is directly available and where it is part of a multipart message. This functionality is essential for processing and reading email content, which is a common requirement in many applications dealing with email data. The method is well-structured, checks for the presence of 'parts', and decodes the base64 encoded content, which is a standard practice for handling email data. Therefore, it is likely to be retained as it provides necessary functionality."
survived,"    def _reply(self, service, input_data: Input, graph_exec_id: str) -> dict:
        parent = (
            service.users()
            .messages()
            .get(
                userId=""me"",
                id=input_data.parentMessageId,
                format=""metadata"",
                metadataHeaders=[""Subject"", ""References"", ""Message-ID""],
            )
            .execute()
        )
        headers = {
            h[""name""].lower(): h[""value""]
            for h in parent.get(""payload"", {}).get(""headers"", [])
        }
        subject = input_data.subject or (f""Re: {headers.get('subject', '')}"".strip())
        references = headers.get(""references"", """").split()
        if headers.get(""message-id""):
            references.append(headers[""message-id""])

        from email import encoders
        from email.mime.base import MIMEBase
        from email.mime.multipart import MIMEMultipart
        from email.mime.text import MIMEText

        msg = MIMEMultipart()
        if input_data.to:
            msg[""To""] = "", "".join(input_data.to)
        if input_data.cc:
            msg[""Cc""] = "", "".join(input_data.cc)
        if input_data.bcc:
            msg[""Bcc""] = "", "".join(input_data.bcc)
        msg[""Subject""] = subject
        if headers.get(""message-id""):
            msg[""In-Reply-To""] = headers[""message-id""]
        if references:
            msg[""References""] = "" "".join(references)
        msg.attach(
            MIMEText(input_data.body, ""html"" if ""<"" in input_data.body else ""plain"")
        )

        for attach in input_data.attachments:
            local_path = store_media_file(graph_exec_id, attach, return_content=False)
            abs_path = get_exec_file_path(graph_exec_id, local_path)
            part = MIMEBase(""application"", ""octet-stream"")
            with open(abs_path, ""rb"") as f:
                part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header(
                ""Content-Disposition"", f""attachment; filename={Path(abs_path).name}""
            )
            msg.attach(part)

        raw = base64.urlsafe_b64encode(msg.as_bytes()).decode(""utf-8"")
        return (
            service.users()
            .messages()
            .send(userId=""me"", body={""threadId"": input_data.threadId, ""raw"": raw})
            .execute()
        )",autogpt_platform/backend/backend/blocks/google/gmail.py,GmailReplyBlock,1,3.850741907939403e-09,"The method '_reply' is a well-structured function that handles the process of replying to an email using a service API. It constructs the email with appropriate headers, subject, body, and attachments, and then sends it. This functionality is essential for applications that need to automate email responses, making it a valuable method. The method is also well-encapsulated, meaning it performs a specific task without unnecessary dependencies, which is a good practice in software development. Therefore, it is likely to be retained."
survived,"    def run(
        self, input_data: Input, *, credentials: GoogleCredentials, **kwargs
    ) -> BlockOutput:
        service = GmailReadBlock._build_service(credentials, **kwargs)
        thread = self._get_thread(
            service, input_data.threadId, input_data.includeSpamTrash
        )
        yield ""thread"", thread
",autogpt_platform/backend/backend/blocks/google/gmail.py,GmailGetThreadBlock,1,7.194132978569833e-09,"The method 'run' is a core part of the functionality for interacting with Gmail threads using the provided credentials. It is responsible for building the service and retrieving the thread data, which are essential operations for the intended use case. There is no indication that this method is redundant or obsolete, and it appears to be a necessary component of the system's functionality."
survived,"    def __init__(self):
        super().__init__(
            id=""12bf5a24-9b90-4f40-9090-4e86e6995e60"",
            description=""Reply to a Gmail thread"",
            categories={BlockCategory.COMMUNICATION},
            input_schema=GmailReplyBlock.Input,
            output_schema=GmailReplyBlock.Output,
            disabled=not GOOGLE_OAUTH_IS_CONFIGURED,
            test_input={
                ""threadId"": ""t1"",
                ""parentMessageId"": ""m1"",
                ""body"": ""Thanks"",
                ""credentials"": TEST_CREDENTIALS_INPUT,
            },
            test_credentials=TEST_CREDENTIALS,
            test_output=[
                (""messageId"", ""m2""),
                (""threadId"", ""t1""),
            ],
            test_mock={
                ""_reply"": lambda *args, **kwargs: {
                    ""id"": ""m2"",
                    ""threadId"": ""t1"",
                }
            },
        )
",autogpt_platform/backend/backend/blocks/google/gmail.py,GmailReplyBlock,1,4.6911638017642294e-08,"The method is a constructor for a class that appears to be part of a system for handling Gmail communications. It initializes an object with specific attributes and configurations necessary for replying to Gmail threads. The method includes test inputs, outputs, and mock functions, indicating it is well-integrated into a testing framework. This suggests it is actively used and maintained, making it unlikely to be deleted."
survived,"    async def run() -> None:
        async with orch.bus:
            runner.start(orch.bus, orch.ledger)
            monitor = asyncio.create_task(orch._monitor())
            for _ in range(6):
                await orig_sleep(0)
            monitor.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await monitor
            if runner.task:
                runner.task.cancel()
                with contextlib.suppress(asyncio.CancelledError):
                    await runner.task
",tests/test_orchestrator_backoff.py,,1,4.944450477491054e-09,"The method 'run' is an asynchronous function that appears to be part of a larger system involving an orchestrator ('orch'), a runner, and a monitor. It uses asynchronous context management and task cancellation, which are common in modern Python applications that require concurrency and resource management. The method is well-structured, using contextlib to suppress cancellation errors, indicating that it is designed to handle potential exceptions gracefully. This suggests that the method is likely to be useful in its current context, especially if it is part of a system that requires robust task management and monitoring. Therefore, it is likely to be retained in the codebase."
survived,"    async def _skill_test(request: Request, name: str):
        payload = await request.json()
        if name not in runners:
            raise HTTPException(404, ""Agent not found"")
        inst = runners[name].inst
        if not hasattr(inst, ""skill_test""):
            raise HTTPException(501, ""Agent does not support skill_test"")
        return await inst.skill_test(payload)  # type: ignore[func-returns-value]
",alpha_factory_v1/backend/orchestrator.py,,1,1.6052280526088547e-09,"The method '_skill_test' is likely to survive because it is a well-structured asynchronous function that handles HTTP requests effectively. It checks for the existence of a runner and a specific method ('skill_test') before attempting to call it, which is a good practice for error handling and ensuring robustness. Additionally, it uses appropriate exception handling to provide meaningful error messages, which is crucial for debugging and user experience. These factors suggest that the method is useful and well-implemented, making it unlikely to be deleted."
survived,"def insert(
    parent_hash: str,
    child_hash: str,
    metrics: Mapping[str, float],
    *,
    db_path: str | Path = _DEFAULT_DB,
) -> str:
    """"""Insert ``child_hash`` with ``parent_hash`` and return updated Merkle root.""""""
    path = Path(db_path)
    _ensure(path)
    record = {
        ""parent"": parent_hash,
        ""child"": child_hash,
        ""metrics"": dict(metrics),
    }
    h = hashlib.sha256(json.dumps(record, sort_keys=True).encode()).hexdigest()
    with sqlite3.connect(path) as cx:
        cx.execute(
            ""INSERT INTO entries(parent, child, metrics, hash, ts) VALUES(?,?,?,?,?)"",
            (parent_hash, child_hash, json.dumps(record[""metrics""]), h, time.time()),
        )
    return _update_root(path)
",src/archive/archive.py,,1,6.69158608681505e-10,"The method 'insert' is likely to survive because it performs a crucial function of inserting data into a database and updating a Merkle root, which is a common operation in systems that require data integrity and verification. The method is well-structured, uses type hints, and handles database operations efficiently. Additionally, it includes error handling through the use of context managers and ensures the database path is valid. These factors suggest that the method is both useful and well-implemented, making it unlikely to be deleted."
survived,"def _update_root(path: Path) -> str:
    root = merkle_root(db_path=path)
    date = time.strftime(""%Y-%m-%d"")
    with sqlite3.connect(path) as cx:
        cx.execute(""INSERT OR REPLACE INTO merkle(date, root) VALUES(?,?)"", (date, root))
    return root
",src/archive/archive.py,,1,1.8189616842444243e-09,"The method '_update_root' is likely to survive because it performs a specific and useful function: updating a database with a new Merkle root for a given path. This is a common operation in systems that require data integrity and verification, such as blockchain or version control systems. The method is concise, uses standard libraries, and follows a clear logic flow, making it a valuable utility function."
survived,"def test_cron_writes_root(tmp_path: Path, monkeypatch) -> None:
    db = tmp_path / ""hash.db""
    arch = HashArchive(db)
    tar = tmp_path / ""a.tar""
    tar.write_text(""a"", encoding=""utf-8"")
    arch.add_tarball(tar)
    out = tmp_path / ""root.json""
    monkeypatch.setenv(""ARCHIVE_PATH"", str(db))
    cid = publish_root(out_file=out)
    assert json.loads(out.read_text())[""cid""] == cid",tests/test_archive_cron.py,,1,4.944450477491054e-09,"The method 'test_cron_writes_root' is a unit test function that verifies the functionality of writing a root JSON file from a tarball archive. It uses temporary paths and monkeypatching to simulate the environment, which is a common practice in testing. The function is well-structured, uses assertions to validate the expected behavior, and does not contain any obvious issues or deprecated practices. Therefore, it is likely to be retained as part of the test suite to ensure the reliability of the code it tests."
survived,"def propose_diff(file_path: str, goal: str) -> str:
    """"""Return a diff appending a placeholder comment with ``goal``.""""""
    p = Path(file_path)
    original = p.read_text(encoding=""utf-8"").splitlines()
    updated = original + [f""# TODO: {goal}""]
    rel = p.name
    diff = difflib.unified_diff(
        original,
        updated,
        fromfile=f""a/{rel}"",
        tofile=f""b/{rel}"",
        lineterm="""",
    )
    return ""\n"".join(diff) + ""\n""",src/tools/diff_mutation.py,,1,5.905303995456778e-10,"The method 'propose_diff' is a utility function that generates a diff string showing the addition of a placeholder comment to a file. This is a useful function for version control systems or any application that needs to track changes to files. It is well-defined, uses standard libraries, and serves a clear purpose. There is no indication that it is obsolete or redundant, and it is likely to be useful in various contexts where file modifications need to be tracked or proposed. Therefore, it is likely to be retained."
survived,"    def uop(self, op):
        if isinstance(op, ast.USub):
            return ""-""
        if isinstance(op, ast.Not):
            return ""not ""
        return """"
",tools/any2mochi/py_simple.py,Conv,1,1.4166087846364157e-09,"The method 'uop' is a utility function that translates unary operations from the AST (Abstract Syntax Tree) module into their string representations. It handles two specific cases: the unary subtraction and the logical NOT operation. This function is useful for code analysis or transformation tasks where AST nodes need to be converted back to their string form. Since it serves a clear purpose and is likely part of a larger system that processes or analyzes Python code, it is likely to be retained."
survived,"    async def _search(q: str, k: int = 5) -> Any:  # noqa: D401
        return mem.vector.search(q, k)
",alpha_factory_v1/backend/api_server.py,,1,8.152020648014727e-09,"The method '_search' is an asynchronous function that performs a search operation using a vector search method from a 'mem' object. It is a simple and clear implementation that likely serves a specific purpose in the codebase, such as retrieving search results based on a query string 'q' and returning the top 'k' results. The use of 'async' suggests that it is designed to handle potentially time-consuming operations without blocking the main thread, which is a common requirement in modern applications. Unless there is a significant change in the application's requirements or architecture, this method is likely to be retained as it provides essential functionality."
survived,"async def serve_grpc(runners: Dict[str, AgentRunner], port: int, ssl_disable: bool) -> Optional[""grpc.aio.Server""]:
    if not port or ""grpc"" not in globals():
        return None
    try:
        from backend.proto import a2a_pb2, a2a_pb2_grpc
    except ModuleNotFoundError:
        log.warning(""A2A_PORT set but proto stubs missing ‚Äì gRPC disabled"")
        return None

    class Peer(a2a_pb2_grpc.PeerServiceServicer):  # type: ignore
        async def Stream(self, req_iter, ctx):  # noqa: N802
            async for req in req_iter:
                kind = req.WhichOneof(""payload"")
                if kind == ""trigger"" and req.trigger.name in runners:
                    runners[req.trigger.name].next_ts = 0
                    yield a2a_pb2.StreamReply(ack=a2a_pb2.Ack(id=req.id))
                elif kind == ""status"":
                    stats = [a2a_pb2.AgentStat(name=n, next_run=int(r.next_ts)) for n, r in runners.items()]
                    yield a2a_pb2.StreamReply(status_reply=a2a_pb2.StatusReply(stats=stats))

    creds = None
    if not ssl_disable:
        cert_dir = Path(os.getenv(""TLS_CERT_DIR"", ""/certs""))
        crt, key = cert_dir / ""server.crt"", cert_dir / ""server.key""
        if crt.exists() and key.exists():
            creds = grpc.ssl_server_credentials(((key.read_bytes(), crt.read_bytes()),))

    server = grpc.aio.server()
    a2a_pb2_grpc.add_PeerServiceServicer_to_server(Peer(), server)
    bind = f""[::]:{port}""
    server.add_secure_port(bind, creds) if creds else server.add_insecure_port(bind)
    await server.start()
    asyncio.create_task(server.wait_for_termination())
    log.info(""gRPC A2A server listening on %s (%s)"", bind, ""TLS"" if creds else ""plaintext"")
    return server",alpha_factory_v1/backend/api_server.py,,1,1.0467401685178159e-08,"The method `serve_grpc` is a crucial part of setting up a gRPC server, which is a common requirement in distributed systems for communication between services. It handles both secure and insecure connections, dynamically loads protocol buffers, and manages service registration. These functionalities are essential for many applications that rely on gRPC for inter-service communication. Therefore, it is unlikely to be deleted unless there is a significant architectural change or a shift away from using gRPC."
survived,"    def _get_metric(factory: Callable[..., Any], name: str, desc: str, labels: list[str] | None = None) -> Any:
        return _reg_metric(factory, name, desc, labels)
",alpha_factory_v1/backend/telemetry.py,,1,5.3157849718487075e-08,"The method '_get_metric' is a private helper function, indicated by the underscore prefix, which suggests it is intended for internal use within a module or class. It is a simple wrapper around another function '_reg_metric', which implies it might be used to standardize or simplify calls to '_reg_metric'. Unless there is a significant change in the design or requirements of the codebase that makes this function redundant or its functionality is directly integrated into '_reg_metric', it is likely to survive. Such utility functions are common in codebases to maintain clean and DRY (Don't Repeat Yourself) principles."
survived,"    def publish(self, topic: str, msg: Dict[str, Any]) -> None:
        if self._producer:
            self._producer.send(topic, msg)
        else:
            assert self._queues is not None
            self._queues.setdefault(topic, asyncio.Queue()).put_nowait(msg)
",alpha_factory_v1/backend/agent_manager.py,EventBus,1,3.2241866333029355e-08,"The method 'publish' is a core part of a message publishing system, handling both direct sending via a producer and queuing messages when the producer is unavailable. This dual functionality is essential for ensuring message delivery in various states of the system, making it unlikely to be removed."
survived,"    async def _recent(agent: str, n: int = 25) -> Any:  # noqa: D401
        return mem.vector.recent(agent, n)
",alpha_factory_v1/backend/api_server.py,,1,1.2501528648238603e-09,"The method '_recent' is a simple wrapper around another method 'mem.vector.recent'. It is likely used to fetch recent data related to an 'agent'. The method is asynchronous, which is beneficial for non-blocking operations, especially when dealing with I/O-bound tasks. The method is concise and serves a clear purpose, which suggests it is useful in its context. Unless there is a significant change in the requirements or the underlying 'mem.vector.recent' method, there is no strong reason to delete it. Therefore, it is likely to survive."
survived,"    async def stop(self) -> None:
        """"""Cancel helper tasks and wait for agent cycles to finish.""""""

        if self._hb_task:
            self._hb_task.cancel()
        if self._reg_task:
            self._reg_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            if self._hb_task:
                await self._hb_task
            if self._reg_task:
                await self._reg_task
        await asyncio.gather(*(r.task for r in self.runners.values() if r.task), return_exceptions=True)
",alpha_factory_v1/backend/agent_manager.py,AgentManager,1,1.0467401685178159e-08,"The method 'stop' is responsible for gracefully shutting down tasks by canceling them and waiting for their completion. This is a common pattern in asynchronous programming to ensure that resources are properly released and tasks are not left hanging. The method uses contextlib.suppress to handle CancelledError exceptions, which is a good practice when dealing with task cancellation. Additionally, it uses asyncio.gather to wait for multiple tasks to complete, which is efficient and necessary for proper task management. Given these reasons, the method is well-implemented and serves an important function in managing asynchronous tasks, making it unlikely to be deleted."
survived,"async def start_servers(
    runners: Dict[str, AgentRunner],
    model_max_bytes: int,
    mem: Any,
    rest_port: int,
    grpc_port: int,
    loglevel: str,
    ssl_disable: bool,
) -> tuple[Optional[asyncio.Task], Optional[""grpc.aio.Server""]]:
    """"""Convenience helper to launch REST and gRPC services.""""""

    app = build_rest(runners, model_max_bytes, mem)
    rest_task = await start_rest(app, rest_port, loglevel)
    grpc_server = await serve_grpc(runners, grpc_port, ssl_disable)
    return rest_task, grpc_server
",alpha_factory_v1/backend/api_server.py,,1,1.2501528648238603e-09,"The method 'start_servers' is a utility function designed to start REST and gRPC services asynchronously. It is a convenience helper that abstracts the complexity of setting up these services, making it easier for developers to launch them with the necessary configurations. The method is likely to be useful in scenarios where both REST and gRPC services need to be started together, which is a common requirement in modern microservices architectures. Given its utility and the fact that it is a non-trivial task to set up these services correctly, the method is likely to be retained in the codebase."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/left_join.py,Customer,1,5.3157849718487075e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is used as a dictionary-like structure, allowing for flexible and dynamic access to its attributes. Therefore, it is likely to be retained in the code."
survived,"    def __repr__(self):
        return str(self.__dict__)
",tests/machine/x/python/group_by_multi_join.py,Partsupp,1,8.76424914819242e-08,"The method `__repr__` is a special method in Python used to define a string representation of an object. The implementation provided returns the string representation of the object's dictionary, which is a common and useful way to represent an object for debugging purposes. This method is likely to be retained because it provides a clear and concise way to inspect the internal state of an object, which is valuable for developers during development and debugging."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/group_by_join.py,Order,1,7.194132978569833e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and functional purpose, it is likely to be retained in the codebase."
survived,"    def __repr__(self):
        return str(self.__dict__)
",tests/machine/x/python/left_join_multi.py,Order,1,1.275190675769241e-07,"The method `__repr__` is a special method in Python used to define a string representation of an object. The implementation provided returns the string representation of the object's dictionary, which is a common and useful way to represent an object for debugging purposes. This method is likely to be retained because it provides a clear and concise way to inspect the internal state of an object, which is valuable for developers during development and debugging."
survived,"    def __repr__(self):
        return str(self.__dict__)
",tests/machine/x/python/join_multi.py,Order,1,9.237449576640118e-09,"The __repr__ method is a special method used to define a string representation for instances of a class. In this case, it returns the string representation of the instance's dictionary, which is a common and useful way to provide a detailed view of the object's attributes. This implementation is straightforward and serves a clear purpose, making it unlikely to be deleted unless there is a specific reason to change how the object is represented as a string. Therefore, it is more likely to survive."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/group_by_sort.py,Item,1,3.3982678079468468e-09,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since it provides a clear and useful functionality, it is likely to be retained in the code."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/group_by_left_join.py,Customer,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python that allows an object to use the bracket notation (e.g., obj[key]) to access its elements. In this implementation, it uses `getattr` to dynamically access an attribute of the object using the provided key. This is a common and useful pattern for objects that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the codebase."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/right_join.py,Order,1,1.0467401685178159e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this implementation, it uses `getattr` to retrieve an attribute of the object by name, which is a valid and useful way to dynamically access object attributes. This method is likely to be useful in scenarios where the object is expected to behave like a dictionary or when dynamic attribute access is needed. Therefore, it is likely to be retained."
survived,"            async def _wrapped(*a: object, **kw: object) -> object:
                t0 = time.perf_counter()
                ok = True
                try:
                    return await orig(*a, **kw)
                except Exception:
                    ok = False
                    raise
                finally:
                    _HEALTH_Q.put((name, (time.perf_counter() - t0) * 1000, ok))
",tests/test_backend_orchestrator_dev.py,,1,2.998960815863541e-09,"The method '_wrapped' is an asynchronous function that wraps another function 'orig'. It measures the execution time of 'orig', handles exceptions, and logs the result to a queue '_HEALTH_Q'. This pattern is useful for monitoring and logging the performance and health of asynchronous operations, which is a common requirement in production systems. The method is likely to be retained as it provides valuable functionality for performance monitoring and error handling."
survived,"    async def step(self) -> None:  # pragma: no cover - test failure
        raise RuntimeError(""boom"")
",tests/test_backend_orchestrator_dev.py,FailingAgent,0,0.9999994284997149,"The method is marked with a pragma to exclude it from test coverage, indicating that it is intentionally not covered by tests. This suggests that the method is either not critical to the main functionality or is expected to fail as part of its design (e.g., for testing error handling elsewhere). However, the method itself raises a RuntimeError unconditionally, which means it doesn't perform any useful operation and will always result in an exception. This makes it unlikely to be useful in a production environment unless it's specifically used to test error handling. Given these factors, the method is more likely to be deleted in future iterations unless it serves a specific testing purpose."
survived,"        def _decorator(func):
            return func
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,,1,1.6701415113938837e-05,"The method _decorator is a simple function that takes another function as an argument and returns it unchanged. This is a basic implementation of a decorator pattern, which is a common and useful technique in Python for modifying or extending the behavior of functions or methods. Although this specific implementation does not modify the function, it serves as a placeholder or a starting point for more complex decorators. Therefore, it is likely to be retained for future development or educational purposes."
survived,"def test_run_cycle_sync_commits() -> None:
    model = DummyModel()
    demo.run_cycle(
        demo.Orchestrator(),
        demo.AgentFin(),
        demo.AgentRes(),
        demo.AgentEne(),
        demo.AgentGdl(),
        model,
    )
    assert model.committed
",tests/test_alpha_agi_business_3_v1.py,,1,3.2241866333029355e-08,"The method `test_run_cycle_sync_commits` is a test function that appears to verify the behavior of a model's commit operation within a cycle run. Test functions are generally essential for ensuring code reliability and correctness, especially in a development environment where continuous integration and testing are crucial. The function uses assertions to validate expected outcomes, which is a common practice in test-driven development. Therefore, it is unlikely to be deleted as it serves a critical role in maintaining code quality."
survived,"    def transform(self, X: Any) -> np.ndarray:  # noqa: D401
        if not hasattr(self, ""model_""):
            raise RuntimeError(""Estimator has not been fitted"")
        n_docs = len(self.model_.document_leaves)
        assignments = np.zeros(n_docs, dtype=int)
        for d in range(n_docs):
            leaf = self.model_.document_leaves[d]
            assignments[d] = leaf.node_id
        return assignments",src/hlda/sklearn_wrapper.py,HierarchicalLDAEstimator,1,7.194132978569833e-09,"The method 'transform' is a crucial part of a machine learning pipeline, especially in the context of models that involve document processing or clustering. It checks if the model has been fitted and then processes the documents to assign them to nodes, which is a typical operation in models like decision trees or clustering algorithms. The method is well-defined, performs a necessary transformation, and includes error handling for unfitted models. These characteristics suggest that it is a useful and necessary part of the codebase, making it unlikely to be deleted."
survived,"    def _ensure_credentials_file(self):
        directory = os.path.dirname(self._path)
        os.makedirs(directory, exist_ok=True)
        if not os.path.exists(self._path):
            with open(self._path, ""w"", encoding=""UTF-8""):
                pass
",src/dhapi/port/credentials_provider.py,CredentialsProvider,1,6.69158608681505e-10,"The method `_ensure_credentials_file` is likely to survive because it performs a necessary utility function: ensuring that a directory exists and creating an empty file if it doesn't. This is a common pattern in file handling to ensure that the application has the necessary files and directories to operate correctly. The method is simple, effective, and does not have any apparent issues that would necessitate its removal."
survived,"    def fake_run(*args, **kwargs):
        if kwargs.get(""preexec_fn""):
            kwargs[""preexec_fn""]()

        class P:
            stdout = ""{}""
            stderr = """"

        return P()
",tests/test_codegen_agent.py,,1,1.1861120010657661e-08,"The method 'fake_run' is a mock function that simulates the behavior of a process run, typically used in testing environments. It doesn't perform any real operations but provides a structure that mimics a real function call, which can be useful for unit tests. Such utility functions are often retained in codebases to facilitate testing without side effects. Therefore, it is likely to survive."
survived,"def test_transform_groups():
    result = transform_groups(MOCK_ENTRA_GROUPS, {
        gid: [u.id for u in users] for gid, users in MOCK_GROUP_MEMBERS.items()
    })
    assert len(result) == 2
    group1 = next(g for g in result if g[""id""] == ""11111111-1111-1111-1111-111111111111"")
    assert group1[""display_name""] == ""Security Team""
    assert group1[""member_ids""] == [
        ""ae4ac864-4433-4ba6-96a6-20f8cffdadcb"",
        ""11dca63b-cb03-4e53-bb75-fa8060285550"",
    ]
",tests/unit/cartography/intel/entra/test_groups.py,,1,2.8453347280241004e-08,"The method 'test_transform_groups' is a unit test function that verifies the behavior of the 'transform_groups' function. It checks if the transformation of group data is performed correctly by asserting the length of the result and specific attributes of the transformed groups. Unit tests are crucial for ensuring code reliability and correctness, especially when refactoring or adding new features. Therefore, this method is likely to be retained as it serves an important role in maintaining the quality of the codebase."
survived,"    def resolve(
        self, packages: Iterable[str], include_hashes: bool = False
    ) -> Tuple[List[str], Dict[str, str], Optional[Dict[str, str]]]:
        """"""Return pinned requirements and license info for ``packages``.""""""

        pinned: Dict[str, str] = {}
        licenses: Dict[str, str] = {}
        hashes: Optional[Dict[str, str]] = {} if include_hashes else None
        visited: set[str] = set()

        for pkg in packages:
            base = pkg.split(""=="")[0].split("">="")[0].split(""<"")[0]
            base = base.split(""["")[0]
            self._collect_recursive(
                base, pinned, licenses, visited, include_hashes, hashes
            )

        reqs = [f""{name}=={ver}"" for name, ver in sorted(pinned.items())]
        return reqs, licenses, hashes",src/meta_agent/dependency_manager.py,DependencyManager,1,5.60279640614594e-09,"The method 'resolve' is likely to survive because it performs a useful and specific function: resolving package dependencies, collecting their versions, licenses, and optionally their hashes. This functionality is essential in package management systems, which are crucial for software development. The method is well-structured, uses type hints, and handles optional parameters effectively, indicating good coding practices. Additionally, it is part of a larger system (as suggested by the use of 'self'), which implies it is integrated into a class or module that likely relies on this functionality."
survived,"    def __init__(self, *args: Any, **kwargs: Any) -> None:
        self.chat = _Chat()",src/meta_agent/services/openai_stub.py,OpenAI,1,3.2241866333029355e-08,"The method is a constructor for a class, indicated by the name `__init__`. Constructors are essential for initializing new objects in object-oriented programming. The presence of `self.chat = _Chat()` suggests that it is setting up an instance variable, which is a common and necessary practice in class design. Therefore, it is unlikely that this method will be deleted as it serves a fundamental role in the class's functionality."
survived,"def trim(s):
    start = 0
    while start < len(s) and (s[start:start + 1] == "" "" or s[start:start + 1] == ""\t""):
        start = start + 1
    end = len(s)
    while end > start and (s[end - 1:end] == "" "" or s[end - 1:end] == ""\t""):
        end = end - 1
    return s[start:end]
",tests/rosetta/transpiler/Python/compiler-virtual-machine-interpreter.py,,1,0.001032231018028039,"The method 'trim' is a basic implementation of a string trimming function that removes leading and trailing spaces and tabs from a string. While it serves its purpose, it is not the most efficient or concise way to achieve this in Python, as the built-in 'strip' method already provides this functionality in a more optimized manner. However, the method is functional and correct, so it is likely to survive unless there is a specific reason to replace it with the built-in method for performance or simplicity reasons."
survived,"def diagd(c1, c2, r):
    c = c1
    while c <= c2:
        n[r + c - c1][c] = ""x""
        c = c + 1
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,0,0.9999251538028718,"The method 'diagd' appears to be part of a larger codebase, likely intended to mark a diagonal line on a 2D grid or matrix 'n'. However, the method lacks context, such as the definition of 'n', and does not handle potential errors or edge cases, such as when 'c1' is greater than 'c2'. Without additional context or error handling, this method is not robust or versatile enough for general use. Therefore, it is likely to be deleted or refactored in a more comprehensive implementation."
survived,"def verti(r1, r2, c):
    r = r1
    while r <= r2:
        n[r][c] = ""x""
        r = r + 1
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,1,2.5109990926928157e-08,"The method 'verti' is a simple utility function that modifies a global or external 2D list 'n' by setting a column 'c' to 'x' from row 'r1' to 'r2'. This type of function is often used in grid or matrix manipulation tasks, such as in games, simulations, or graphical applications. The function is straightforward, performs a specific task, and does not have any apparent issues or redundancies that would necessitate its deletion. Therefore, it is likely to be retained in the codebase."
survived,"def horiz(c1, c2, r):
    c = c1
    while c <= c2:
        n[r][c] = ""x""
        c = c + 1
",tests/rosetta/transpiler/Python/cistercian-numerals.py,,1,5.60279640614594e-09,"The method 'horiz' is a simple function that draws a horizontal line of 'x' characters in a 2D list 'n' from column 'c1' to column 'c2' at row 'r'. This function is straightforward and performs a specific task that could be useful in various contexts, such as drawing or grid manipulation. It is unlikely to be deleted unless the entire project or module it belongs to is being refactored or removed. Therefore, the method is more likely to survive."
survived,"def printLower(m):
    n = m[""order""]
    ele = m[""ele""]
    mat = []
    idx = 0
    r = 0
    while r < n:
        row = []
        c = 0
        while c <= r:
            row = row + [ele[idx]]
            idx = idx + 1
            c = c + 1
        while c < n:
            row = row + [0.0]
            c = c + 1
        mat = mat + [row]
        r = r + 1
    printMat(mat)
",tests/rosetta/transpiler/Python/cholesky-decomposition-1.py,,1,4.1399375473943306e-08,"The method 'printLower' is a utility function that constructs a lower triangular matrix from a given list of elements and prints it using another function 'printMat'. This function is specific in its use case but can be useful in mathematical or data processing contexts where lower triangular matrices are needed. The function is complete, has a clear purpose, and does not contain any obvious errors or redundancies that would necessitate its deletion. Therefore, it is likely to be retained in the codebase."
survived,"def one():
    return id
",tests/rosetta/transpiler/Python/church-numerals-2.py,,0,0.9999991684720096,"The method 'one' is defined to return 'id', which is not defined within the method or passed as a parameter. This will lead to a NameError when the method is called, as 'id' is not a local variable or parameter. Additionally, the method name 'one' is not descriptive of its functionality, which is generally not a good practice in coding. Without further context or correction, this method is likely to be deleted or refactored."
survived,"def hypot(x, y):
    return sqrtApprox(x * x + y * y)
",tests/rosetta/transpiler/Python/circles-of-given-radius-through-two-points.py,,0,0.9975273767468863,"The method `hypot` is a basic implementation of the Pythagorean theorem to calculate the hypotenuse of a right triangle given sides `x` and `y`. However, it uses a function `sqrtApprox` which is not defined within the code snippet. If `sqrtApprox` is a custom function that approximates the square root, the method could be useful in contexts where an approximation is sufficient and performance is critical. However, if `sqrtApprox` is not defined elsewhere in the codebase, this method would not work as intended. In modern programming, most languages provide a built-in function to calculate the hypotenuse (e.g., `math.hypot` in Python), which is more reliable and accurate. Therefore, unless `sqrtApprox` has a specific purpose or advantage, this method might be considered redundant and could be deleted in favor of using built-in functions."
survived,"def ccFactors(n, m):
    p = 6 * m + 1
    if not isPrime(p):
        return []
    prod = bigFromInt(p)
    p = 12 * m + 1
    if not isPrime(p):
        return []
    prod = bigMulSmall(prod, p)
    i = 1
    while i <= n - 2:
        p = (pow2(i) * 9 * m) + 1
        if not isPrime(p):
            return []
        prod = bigMulSmall(prod, p)
        i = i + 1
    return prod
",tests/rosetta/transpiler/Python/chernicks-carmichael-numbers.py,,0,0.9999999918479795,"The method `ccFactors` is likely to be deleted (0) because it contains several issues that make it impractical or incorrect for use. Firstly, the function relies on undefined functions such as `isPrime`, `bigFromInt`, `bigMulSmall`, and `pow2`, which means it cannot run as is. Additionally, the logic seems to be attempting to calculate a product of certain prime numbers, but the conditions and calculations are not clearly explained or justified, making it difficult to understand the purpose or correctness of the function. Without further context or corrections, this method is not useful in its current state."
survived,"def main():
    while True:
        line = input()
        if line == """":
            break
        print(line)
",tests/rosetta/transpiler/Python/copy-stdin-to-stdout-2.py,,1,4.363462233903899e-09,"The method is a simple implementation of a loop that reads input from the user and prints it back until an empty line is entered. This is a basic and functional piece of code that serves a clear purpose, which is to echo user input. There is no indication that this method is obsolete or incorrect, and it can be useful in various scenarios where user input needs to be processed in a loop. Therefore, it is likely to be retained."
survived,"def ccw(a, b, c):
    lhs = (b.x - a.x) * (c.y - a.y)
    rhs = (b.y - a.y) * (c.x - a.x)
    return lhs > rhs
",tests/rosetta/transpiler/Python/convex-hull.py,,1,2.646573631904765e-09,"The method 'ccw' is a simple and efficient implementation of a common geometric algorithm used to determine the orientation of three points in a 2D plane. It checks if the sequence of points a, b, c makes a counter-clockwise turn. This is a fundamental operation in computational geometry, often used in algorithms for convex hulls, polygon triangulation, and other geometric computations. Given its utility and simplicity, it is likely to be retained in codebases that deal with geometric problems."
survived,"def test_format_time_ago_outputs():
    now = datetime.now(timezone.utc)
    assert format_time_ago((now - timedelta(days=2)).isoformat()) == ""2 days ago""
    assert format_time_ago((now - timedelta(hours=5)).isoformat()) == ""5 hours ago""
    thirty_min_ago = (now - timedelta(minutes=30)).isoformat()
    assert format_time_ago(thirty_min_ago) == ""30 minutes ago""
    assert format_time_ago(now.isoformat()) == ""just now""
",tests/test_dashboard.py,,1,2.3823698451773172e-07,"The method 'test_format_time_ago_outputs' is a unit test function that verifies the correctness of the 'format_time_ago' function. It checks if the function correctly formats time differences into human-readable strings like '2 days ago', '5 hours ago', etc. This is a common and useful functionality in applications that display relative time information to users. Since testing is a crucial part of software development to ensure code reliability and correctness, this method is likely to be retained as long as the 'format_time_ago' function is in use."
survived,"    def error_suggestion(self, error_message: str) -> str | None:
        """"""Return a suggestion string for the given error message and output it.""""""
        suggestions = {
            ""failed to load"": ""Check that the file path exists and is readable."",
            ""network"": ""Ensure your internet connection is available."",
        }
        error_lower = error_message.lower()
        for token, suggestion in suggestions.items():
            if token in error_lower:
                self.cli_output.info(f""Suggestion: {suggestion}"")
                return suggestion
        return None
",src/meta_agent/ux/user_feedback.py,UserFeedback,1,2.1724399346070676e-10,"The method 'error_suggestion' is well-defined and serves a useful purpose by providing suggestions based on error messages. It enhances user experience by offering guidance on how to resolve common issues. The method is straightforward, easy to understand, and can be expanded with more error cases if needed. There is no indication that it is obsolete or redundant, so it is likely to be retained."
survived,"def test_replay_closes_ledger(tmp_path) -> None:
    ledger = tmp_path / ""audit.db""
    ledger.touch()
    with patch.object(cli.config.CFG, ""ledger_path"", ledger):
        with (
            patch.object(cli.logging, ""Ledger"") as led_cls,
            patch.object(cli.time, ""sleep"", return_value=None),
        ):
            led = led_cls.return_value
            led.__enter__.return_value = led
            led.__exit__.side_effect = lambda *_: led.close()
            led.tail.return_value = [{""ts"": 0.0, ""sender"": ""a"", ""recipient"": ""b"", ""payload"": {""x"": 1}}]
            CliRunner().invoke(cli.main, [""replay""])
        led.close.assert_called_once()",tests/test_demo_cli.py,,1,6.825604231969389e-08,"The method 'test_replay_closes_ledger' is a unit test function that ensures a specific behavior of the code, specifically that the ledger is closed after a replay operation. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly changed. Additionally, the method is well-structured and uses mocking to isolate the behavior being tested, which is a good practice in unit testing."
survived,"        def subscribe(self, _t: str, _h):
            pass
",tests/test_adapters.py,DummyBus,0,0.9999999973534264,"The method 'subscribe' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it might be a placeholder for future functionality. However, without any additional context or usage, it is not actively contributing to the codebase. If the method remains unused and unimplemented, it is likely to be deleted in future iterations to clean up the code. Therefore, the prediction is that the method will be deleted."
survived,"def test_adk_adapter_unavailable(monkeypatch) -> None:
    """"""Adapter gracefully degrades when ADK is missing.""""""

    def _raise(_name: str):
        raise ModuleNotFoundError

    monkeypatch.setattr(importlib, ""import_module"", _raise)
    assert not ADKAdapter.is_available()
    with pytest.raises(ModuleNotFoundError):
        ADKAdapter()
",tests/test_adapters.py,,1,1.1861120010657661e-08,"The method `test_adk_adapter_unavailable` is a unit test designed to verify the behavior of the `ADKAdapter` class when the ADK module is unavailable. It uses the `monkeypatch` fixture to simulate the absence of the ADK module by raising a `ModuleNotFoundError` when `import_module` is called. The test then asserts that `ADKAdapter.is_available()` returns `False` and that instantiating `ADKAdapter` raises a `ModuleNotFoundError`. This test is important for ensuring the robustness of the `ADKAdapter` class in handling missing dependencies gracefully. Therefore, it is likely to be retained as part of the test suite to maintain code quality and reliability."
survived,"def test_mcp_invoke_tool_calls_library(monkeypatch) -> None:
    """"""Ensure MCPAdapter.invoke_tool delegates to the MCP client.""""""
    import mcp

    calls: dict[str, tuple[str, dict[str, object]]] = {}

    async def fake_call_tool(self, name: str, args: dict[str, object]) -> object:
        calls[""call""] = (name, args)
        return {""done"": True}

    monkeypatch.setattr(mcp.ClientSessionGroup, ""call_tool"", fake_call_tool, raising=False)
    adapter = MCPAdapter()
    result = asyncio.run(adapter.invoke_tool(""mytool"", {""x"": 1}))
    assert result == {""done"": True}
    assert calls[""call""] == (""mytool"", {""x"": 1})
",tests/test_adapters.py,,1,3.2241866333029355e-08,"The method is a unit test that uses monkeypatching to test the behavior of the MCPAdapter class. It is a well-structured test that ensures the invoke_tool method correctly delegates to the MCP client. Such tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained as part of the test suite."
survived,"def test_fuzz_envelope_allows_safe(sender: str, recipient: str, ts: float, payload: dict[str, object]) -> None:
    code = payload[""code""]
    assume(""import os"" not in code)
    bus = DummyBus(config.Settings(bus_port=0))
    led = DummyLedger()
    agent = safety_agent.SafetyGuardianAgent(bus, led)
    env = messaging.Envelope(sender, recipient, payload, ts)
    asyncio.run(agent.handle(env))
    assert bus.published[-1][1].payload[""status""] == ""ok""
",tests/test_safety_guardian_property.py,,1,1.0467401685178159e-08,"The method 'test_fuzz_envelope_allows_safe' is a unit test function that checks the behavior of a system when handling a specific type of message envelope. It uses a dummy bus and ledger to simulate the environment and verifies that the status of the processed message is 'ok'. This is a typical pattern in testing to ensure that the system behaves correctly under certain conditions. Since testing is a crucial part of software development to ensure reliability and correctness, this method is likely to be retained as part of the test suite."
survived,"        async def send_transaction(self, tx: object, *args: object) -> None:
            captured[""data""] = tx.instructions[0].data.decode()
",tests/test_safety_guardian_property.py,DummyClient,1,6.69158608681505e-10,"The method 'send_transaction' is an asynchronous function that takes a transaction object and captures the data from the first instruction of the transaction. This method is likely to be used in a context where transactions are being processed and specific data needs to be extracted for further use. The method is simple, performs a clear task, and does not have any apparent issues or redundancies. Therefore, it is likely to be useful in its current form and is expected to survive."
survived,"        def __init__(self, program_id: object, data: bytes, keys: list[object]):
            self.data = data
",tests/test_safety_guardian_property.py,DummyInstr,1,1.8189616842444243e-09,"The method is a constructor (__init__) which is a fundamental part of a class in Python. It is used to initialize the attributes of the class when an object is created. The presence of this method is essential for setting up the initial state of an object, and it is unlikely to be deleted unless the class itself is being removed or significantly refactored. Therefore, the method will survive."
survived,"def violates_finance_policy(code: str) -> bool:
    """"""Return ``True`` if ``code`` references a banned finance API host.""""""
    for host in _BANNED_HOSTS:
        if host in code:
            return True
    return False",src/utils/opa_policy.py,,1,1.3440409770490404e-08,"The method 'violates_finance_policy' is straightforward and serves a clear purpose: checking if a given code references any banned finance API hosts. This is a common requirement in many applications to ensure compliance with financial regulations or internal policies. The method is simple, efficient, and likely to be useful in contexts where such checks are necessary. Therefore, it is unlikely to be deleted."
survived,"def test_run_macro_demo_no_offline(tmp_path: Path) -> None:
    """"""`OPENAI_API_KEY` disables the offline profile.""""""
    docker_log, _ = _run_script(tmp_path, env={""OPENAI_API_KEY"": ""dummy-key""})
    assert ""--profile offline"" not in docker_log
",tests/test_macro_launcher.py,,1,5.3157849718487075e-08,"The method `test_run_macro_demo_no_offline` is a test function that checks if the presence of an `OPENAI_API_KEY` in the environment variables disables the offline profile in a script. This is a specific test case that ensures a particular behavior of the script when an API key is provided. Test functions like this are crucial for verifying the correctness of code and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained as part of the test suite to maintain code quality and reliability."
survived,"    def decorator(func):
        return func
",openai_agents/__init__.py,,1,6.144172127844639e-06,"The method 'decorator' is a simple function that takes another function as an argument and returns it without any modification. This is a basic implementation of a decorator pattern in Python, which is a common and useful feature for extending or modifying the behavior of functions or methods. Although this specific implementation does not add any additional functionality, it serves as a valid and potentially useful template for more complex decorators. Therefore, it is likely to be retained for educational purposes or as a starting point for further development."
survived,"        def decorator(func):
            return func
",stubs/google_adk/__init__.py,,1,1.2098660619383578e-06,"The method is a simple decorator that returns the function it receives without any modification. While it doesn't add any functionality, it is a valid decorator pattern and could be used as a placeholder or for future extension. Therefore, it is likely to survive as it doesn't cause any harm or errors."
survived,"    async def __call__(self, text: str) -> str:  # pragma: no cover - demo stub
        return ""ok""
",openai_agents/__init__.py,OpenAIAgent,0,0.9999999778405106,"The method is a simple asynchronous function that takes a string input and returns a string ""ok"". It is marked with a pragma comment indicating that it is a demo stub, which suggests that it is not intended for production use or testing coverage. This implies that the method is likely a placeholder or example code, and not part of the final implementation. Therefore, it is likely to be deleted or replaced in the future as the actual functionality is developed."
survived,"        def register_agent(self, _agent) -> None:  # pragma: no cover - stub
            pass
",stubs/google_adk/__init__.py,Router,0,0.9999999928058669,"The method `register_agent` is a stub, indicated by the comment `# pragma: no cover - stub`, which suggests that it is not yet implemented. Stub methods are often placeholders for future functionality. However, without any implementation or usage context, it is likely to be deleted if it remains unused or if the functionality is implemented elsewhere. Therefore, the method is predicted to be deleted."
survived,"    def test_official_demo_short(self) -> None:
        result = subprocess.run(
            [
                sys.executable,
                ""alpha_factory_v1/demos/alpha_agi_insight_v0/official_demo.py"",
                ""--episodes"",
                ""1"",
            ],
            capture_output=True,
            text=True,
        )
        self.assertEqual(result.returncode, 0, result.stderr)
        self.assertIn(""Best sector"", result.stdout)
",tests/test_official_insight_demo.py,TestOfficialInsightDemo,1,2.2159489282323004e-08,"The method `test_official_demo_short` is a unit test designed to verify the functionality of a specific script by running it and checking its output. Such tests are crucial for ensuring that code changes do not break existing functionality. The method is well-structured, using subprocess to execute a script and then asserting the expected outcomes. This is a common practice in software development to maintain code quality and reliability. Therefore, it is unlikely that this method will be deleted unless the script it tests is deprecated or the testing framework changes significantly."
survived,"async def test_auto_resources_and_resolvers():
    app, lifespan = create_app()
    async with lifespan(app) as ctx:
        session_factory = ctx[""session_factory""]
        mock_ctx = Mock(spec=EnrichContext)
        mock_ctx.request_context = Mock()
        mock_ctx.request_context.lifespan_context = {""session_factory"": session_factory}

        list_users = app.resources[""list_users""]
        result = await list_users(ctx=mock_ctx)
        assert result.total_items == 1
        assert result.items[0].name == ""Alice""

        get_user = app.resources[""get_user""]
        single = await get_user(user_id=1, ctx=mock_ctx)
        assert single.name == ""Alice""

        # Relationship resolver
        get_orders = app.resources[""get_user_orders""]
        rel = await get_orders(user_id=1, ctx=mock_ctx)
        assert len(rel) == 1
        assert rel[0].id == 1",tests/test_sqlalchemy_autogen.py,,1,8.76424914819242e-08,"The method 'test_auto_resources_and_resolvers' is a test function that verifies the functionality of an application by checking if the resources and resolvers are working as expected. It uses mock objects to simulate the context and checks the results of various resource calls. This kind of test is crucial for ensuring the reliability and correctness of the application, especially in an asynchronous environment. Therefore, it is likely to be maintained and not deleted."
survived,"    def dummy_run(*_a, **_kw):
        times.append(time.perf_counter())
        time.sleep(0.2)
        ind = orchestrator.mats.Individual([0.0])
        ind.score = 0.0
        return [ind]
",tests/test_experiments.py,,0,0.9999999847700205,"The method 'dummy_run' is likely to be deleted (0) because it appears to be a placeholder or a test function rather than a fully implemented method. It uses a generic name 'dummy_run', which suggests it is not intended for production use. Additionally, it appends the current time to a list 'times', sleeps for a short duration, and returns a list containing a single 'Individual' object with a hardcoded score of 0.0. This behavior indicates that the function is not performing any meaningful computation or logic, and is likely used for testing or demonstration purposes. Such methods are often removed once the actual implementation is completed."
survived,"def _build_incremental_case(rng, seq_lens, k_lens):
    """"""Like ``_build_random_case`` but query only contains the last ``k`` tokens.

    ``seq_lens`` gives the total tokens already in the KV cache for each
    sequence. ``k_lens`` is how many query tokens each sequence has. The KV
    cache still contains ``seq_lens`` tokens for every sequence.
    """"""
    q_full, kv_pages, kv_lens, page_indices, full_cu_q_lens, num_seqs = _build_random_case(rng, seq_lens)

    assert len(seq_lens) == len(k_lens)

    chunks = []
    new_offsets = [0]
    for sid, (total_len, k) in enumerate(zip(seq_lens, k_lens)):
        start = int(full_cu_q_lens[sid]) + total_len - k
        chunks.append(q_full[""tok"", hax.ds(start, k)])
        new_offsets.append(new_offsets[-1] + k)

    q = hax.concatenate(""tok"", chunks)
    cu_q_lens = jnp.asarray(new_offsets, dtype=jnp.int32)

    return q, kv_pages, kv_lens, page_indices, cu_q_lens, num_seqs
",tests/test_paged_attention.py,,1,4.363462233903899e-09,"The method `_build_incremental_case` is a specialized function that builds on top of another function `_build_random_case`. It is designed to handle a specific scenario where only the last `k` tokens are queried, which is a common requirement in sequence processing tasks such as natural language processing or time series analysis. The function is well-documented, indicating its purpose and how it modifies the output of `_build_random_case`. This specificity and documentation suggest that the function is useful and likely to be retained in the codebase, especially if the parent function `_build_random_case` is also retained. Therefore, it is predicted to survive."
survived,"def test_js_serializer_roundtrip(tmp_path: Path) -> None:
    script = tmp_path / ""run.mjs""
    script.write_text(
        f""import {{save, load}} from '{SERIALIZER.resolve().as_posix()}';\n""
        ""const data = JSON.parse(process.argv[2]);\n""
        ""const pop = data.pop;\n""
        ""if (data.gen !== undefined) pop.gen = data.gen;\n""
        ""const out = load(save(pop, data.rngState));\n""
        ""console.log(JSON.stringify(out));\n""
    )

    sample = {
        ""pop"": [
            {""logic"": ""a"", ""feasible"": True, ""front"": 0, ""strategy"": ""s""},
            {""logic"": ""b"", ""feasible"": False, ""front"": 1, ""strategy"": ""t""},
        ],
        ""gen"": 5,
        ""rngState"": [1, 2, 3, 4],
    }

    result = subprocess.run(
        [""node"", script, json.dumps(sample)], capture_output=True, text=True
    )
    assert result.returncode == 0, result.stderr
    loaded = json.loads(result.stdout)
    assert loaded == sample",tests/test_serializer.py,,1,9.736200303530205e-10,"The method is a test function that verifies the round-trip serialization and deserialization of data using a JavaScript serializer. It is a useful test to ensure that the serialization process is working correctly, which is important for data integrity. Such tests are typically retained in codebases to prevent regressions and ensure that changes do not break existing functionality. Therefore, it is likely to survive."
survived,"def test_pyodide_load_failure(tmp_path: Path) -> None:
    bridge_copy = tmp_path / ""bridge.mjs""
    text = BRIDGE.read_text().replace(
        ""../lib/pyodide.js"", LIB.resolve().as_posix()
    )
    bridge_copy.write_text(text)

    script = tmp_path / ""run.mjs""
    script.write_text(
        ""globalThis.window = {\n""
        ""  toast: (m) => console.log(m),\n""
        ""  loadPyodide: () => { throw new Error('boom'); }\n""
        ""};\n""
        ""globalThis.toast = globalThis.window.toast;\n""
        f""const m = await import('{bridge_copy.as_posix()}');\n""
        ""try { await m.run(); } catch (e) {}\n""
    )
    result = subprocess.run([""node"", script], capture_output=True, text=True)
    assert result.returncode == 0, result.stderr
    assert ""Pyodide failed to load"" in result.stdout",tests/test_wasm_bridge.py,,1,1.522997951276035e-08,"The method 'test_pyodide_load_failure' is a test function that checks the behavior of a script when the 'loadPyodide' function throws an error. It is a part of a test suite, likely for a JavaScript or Python project that uses Pyodide. Test functions are generally not deleted unless they are redundant or replaced by more comprehensive tests. This function seems to serve a specific purpose of ensuring that the error handling for Pyodide loading failures is working correctly. Therefore, it is likely to be retained as part of the test coverage."
survived,"def test_health() -> None:
    response = client.get(""/health"")
    assert response.status_code == 200
    assert response.json() == {""status"": ""ok""}",test_repo/backend/tests/test_demo_main.py,,1,4.0586521248284276e-10,"The method 'test_health' is a unit test designed to check the health endpoint of an application. Such tests are crucial for ensuring that the application is running correctly and that the health endpoint is functioning as expected. This is a common practice in software development to maintain application reliability and is unlikely to be removed unless the health endpoint itself is deprecated or the testing framework changes significantly. Therefore, the method is likely to survive."
survived,"def test_expand_cidr_cidr_range():
    result = expand_cidr('10.0.0.0/30')
    assert len(result) == 4
    assert result == ['10.0.0.0', '10.0.0.1', '10.0.0.2', '10.0.0.3']",tests/test_whois_perms.py,,1,4.6911638017642294e-08,"The method `test_expand_cidr_cidr_range` is a unit test for the function `expand_cidr`. It verifies that the function correctly expands a CIDR notation into a list of IP addresses. Unit tests are crucial for ensuring code reliability and correctness, especially in network-related functions where accuracy is important. Therefore, this method is likely to be retained as it serves an important role in testing the functionality of the `expand_cidr` function."
survived,"        def run(self, prompt: str):
            return ""ok""
",tests/test_external_integrations.py,Dummy,0,0.999983298584886,"The method 'run' is very minimal and only returns a static string ""ok"" regardless of the input. This suggests that it might be a placeholder or a stub for future implementation. Without any logic or functionality that utilizes the 'prompt' parameter, it doesn't serve a meaningful purpose in its current form. Therefore, it is likely to be deleted or significantly modified in the future to add actual functionality."
survived,"        def register_agent(self, agent):
            raise AssertionError(""should not register"")
",tests/test_external_integrations.py,DummyRouter,0,0.9999998362622821,"The method 'register_agent' is designed to raise an AssertionError whenever it is called, indicating that it should not be used. This suggests that the method is either a placeholder or a safeguard against incorrect usage. Since it doesn't perform any meaningful operation and actively prevents its own use, it is likely to be removed or refactored in the future to improve code clarity and maintainability."
survived,"        def add_peer(servicer: object, server: object) -> None:
            pass
",tests/test_orchestrator_grpc.py,TestServeGrpc,1,1.6701415113938837e-05,"The method `add_peer` is defined with a clear purpose suggested by its name, which is to add a peer to a server or service. However, the method currently contains only a `pass` statement, indicating that it is not yet implemented. Whether this method will be deleted or survive depends on the context in which it is used. If the functionality to add a peer is required in the application, this method is likely to be implemented in the future, thus surviving. If the functionality is deemed unnecessary, it might be deleted. Without additional context, it's reasonable to assume that the method is intended to be implemented, as it has a specific name and parameters, suggesting it is part of a planned feature."
survived,"    def tearDown(self):
        self._cm.__exit__(None, None, None)
",alpha_factory_v1/tests/test_memory_provider.py,MemoryFabricFallbackTest,1,7.73442280641062e-08,"The method `tearDown` is a standard part of the unittest framework in Python, used to clean up after each test method is run. The code within `tearDown` is calling `__exit__` on a context manager, which suggests it's performing necessary cleanup operations. This is a typical and necessary part of test lifecycle management, ensuring that resources are properly released after tests. Therefore, it is unlikely to be deleted as it serves an important purpose in maintaining test integrity."
survived,"  async def test_passive_cooling_without_support(self):
    backend = TemperatureControllerChatterboxBackend(dummy_temperature=20.0)
    tc = TemperatureController(
      name=""tc"",
      size_x=1,
      size_y=1,
      size_z=1,
      backend=backend,
      child_location=Coordinate.zero(),
    )

    await tc.set_temperature(10, passive=True)
    # Temperature should remain unchanged on the backend.
    self.assertEqual(await backend.get_current_temperature(), 20.0)
",pylabrobot/temperature_controlling/temperature_controller_tests.py,PassiveCoolingTests,1,9.237449576640118e-09,"The method 'test_passive_cooling_without_support' is a unit test designed to verify the behavior of a temperature controller when passive cooling is requested. It checks that the temperature remains unchanged, which is a valid test case for ensuring the system behaves correctly under specific conditions. Unit tests are crucial for maintaining code quality and ensuring that changes do not introduce regressions. Therefore, this method is likely to be retained as part of the test suite to ensure the reliability of the temperature control functionality."
survived,"def _fitness(item: Any) -> Iterable[float]:
    if isinstance(item, Mapping):
        vals = item.get(""fitness"") or item.get(""objective_values"")
        if isinstance(vals, Mapping):
            return list(vals.values())
        if isinstance(vals, Iterable):
            return list(vals)
    return list(getattr(item, ""fitness"", []))
",src/utils/visual.py,,1,2.0611536181902033e-09,"The method '_fitness' is likely to survive because it provides a utility function that extracts fitness values from an item, which can be a dictionary or an object with a 'fitness' attribute. This kind of functionality is useful in scenarios where items can have different structures, and a consistent way to retrieve fitness values is needed. The method is flexible, handling both mappings and iterable fitness values, which suggests it is designed to be robust and adaptable to various input types. Such utility functions are often retained in codebases for their reusability and flexibility."
survived,"def fake_dataset_class(monkeypatch):
    import np_ocr.data as data

    def fake_from_list(lst):
        return FakeDataset(lst)

    monkeypatch.setattr(data, ""Dataset"", types.SimpleNamespace(from_list=staticmethod(fake_from_list)))
    return data
",no-ocr-api/tests/test_ingest_search.py,,1,3.0590235908148916e-07,"The method 'fake_dataset_class' is a utility function used for testing purposes, specifically to mock or replace the 'Dataset' class in the 'np_ocr.data' module with a fake implementation. This is a common practice in unit testing to isolate the code being tested from its dependencies. Such methods are typically not deleted as they serve a crucial role in ensuring the reliability and correctness of the codebase through testing. Therefore, it is likely to be retained."
survived,"                        def to_list(self):
                            return [{""_distance"": 0.1, ""index"": 0, ""pdf_name"": ""x.pdf"", ""pdf_page"": 1}]
",no-ocr-api/tests/test_ingest_search.py,FakeTable.Limiter.Selector,1,1.444980317078884e-07,"The method 'to_list' is a simple utility function that returns a hardcoded list containing a dictionary with specific keys and values. It is likely used to provide a consistent output format for whatever context it is used in. Since it is a straightforward method that does not depend on external factors or complex logic, it is unlikely to be deleted unless the requirements change significantly or the method is no longer needed. However, without additional context on its usage, it's difficult to definitively predict its future. Given its simplicity and potential utility, it is more likely to survive."
survived,"                def limit(self, *_):
                    class Selector:
                        def select(self, *_):
                            return self

                        def to_list(self):
                            return [{""_distance"": 0.1, ""index"": 0, ""pdf_name"": ""x.pdf"", ""pdf_page"": 1}]

                    return Selector()
",no-ocr-api/tests/test_ingest_search.py,FakeTable.Limiter,1,2.5109990926928157e-08,"The method 'limit' is likely to survive because it is part of a class that seems to be implementing a pattern for data selection and retrieval. The 'limit' method returns an instance of an inner class 'Selector', which provides methods 'select' and 'to_list'. These methods suggest a design for chaining operations and retrieving a list of results, which is a common pattern in data processing or querying libraries. The presence of a structured return value in 'to_list' indicates that this method is intended for use in a larger system, making it less likely to be removed without a replacement."
survived,"    def __init__(self, data):
        self.data = list(data)
",no-ocr-api/tests/test_ingest_search.py,FakeDataset,1,2.998960815863541e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. It initializes an instance of the class with a given data attribute, converting the input data into a list. This is a common and necessary practice for setting up class instances, and there is no indication that this functionality is redundant or unnecessary. Therefore, it is likely to be retained."
survived,"    async def handler(env: messaging.Envelope) -> None:
        received.append(env)
",tests/test_bus_large_payloads_property.py,,1,6.348800075736417e-09,"The method 'handler' is an asynchronous function that takes an 'Envelope' object as a parameter and appends it to a list called 'received'. This is a simple and common pattern in asynchronous programming, especially in message handling systems. The method is likely to be useful in contexts where messages need to be processed asynchronously and stored for later use or processing. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def run_model(
        self,
        api_key: SecretStr,
        model_name: str,
        prompt: str,
        input_image: Optional[str],
        aspect_ratio: str,
        seed: Optional[int],
    ) -> str:
        client = ReplicateClient(api_token=api_key.get_secret_value())
        input_params = {
            ""prompt"": prompt,
            ""input_image"": input_image,
            ""aspect_ratio"": aspect_ratio,
        }
        if seed is not None:
            input_params[""seed""] = seed

        output: FileOutput | list[FileOutput] = client.run(  # type: ignore
            model_name,
            input=input_params,
            wait=False,
        )

        if isinstance(output, list) and output:
            first = output[0]
            if isinstance(first, FileOutput):
                return first.url
            return first
        if isinstance(output, FileOutput):
            return output.url
        if isinstance(output, str):
            return output
        return ""No output received""",autogpt_platform/backend/backend/blocks/flux_kontext.py,FluxKontextBlock,1,6.348800075736417e-09,"The method is well-structured and performs a clear function of running a model using a client. It handles different types of outputs and includes optional parameters, which makes it flexible. The use of type hints and optional parameters suggests good coding practices. There is no indication that this method is obsolete or redundant, so it is likely to be retained."
survived,"def scenario_2020_mrna() -> replay.Scenario:
    return replay.load_scenario(""2020_mrna"")
",tests/conftest.py,,1,2.0611536181902033e-09,"The method 'scenario_2020_mrna' is a simple wrapper around the 'replay.load_scenario' function, which loads a scenario named '2020_mrna'. This method is likely part of a larger system that deals with scenarios, possibly in a simulation or game context. The method is straightforward and serves a clear purpose, making it unlikely to be deleted unless the '2020_mrna' scenario itself is removed or the way scenarios are loaded is fundamentally changed. Therefore, it is more likely to survive."
survived,"def scenario_2008_mobile() -> replay.Scenario:
    return replay.load_scenario(""2008_mobile"")
",tests/conftest.py,,1,1.3440409770490404e-08,"The method `scenario_2008_mobile` is a simple wrapper around the `replay.load_scenario` function, which loads a specific scenario named ""2008_mobile"". This method is likely to be useful for organizing and managing different scenarios in a larger codebase, especially if there are multiple scenarios to handle. It provides a clear and concise way to load this specific scenario, which can be beneficial for readability and maintainability of the code. Unless the ""2008_mobile"" scenario is no longer relevant or used, there is no strong reason to delete this method."
survived,"        def wait(self, timeout: float | None = None) -> None:
            pass
",tests/test_start_alpha_business.py,DummyProc,1,2.5612814850547937e-06,"The method 'wait' is defined with a 'pass' statement, indicating that it currently has no implementation. However, the method signature suggests it is intended to perform a waiting operation with an optional timeout parameter. This is a common pattern in code where the method is a placeholder for future implementation. Given that it is a method of a class (indicated by the 'self' parameter), it is likely part of a larger class structure where waiting functionality is expected. Therefore, it is more likely that this method will be implemented in the future rather than deleted, as it serves a potential purpose in the class design."
survived,"def test_start_alpha_business_submit_best(monkeypatch) -> None:
    """"""--submit-best queues the top demo opportunity.""""""
    from alpha_factory_v1.demos.alpha_agi_business_v1 import start_alpha_business as mod

    class DummyProc:
        def poll(self) -> None:
            return None

        def terminate(self) -> None:
            pass

        def wait(self, timeout: float | None = None) -> None:
            pass

    dummy_proc = DummyProc()
    monkeypatch.setattr(mod.subprocess, ""Popen"", lambda *a, **k: dummy_proc)
    monkeypatch.setattr(mod.check_env, ""main"", lambda *_a, **_k: None)
    monkeypatch.setattr(mod.webbrowser, ""open"", lambda *_a, **_k: None)

    class Resp:
        def __init__(self) -> None:
            self.status_code = 200

        def raise_for_status(self) -> None:
            pass

    monkeypatch.setattr(mod.requests, ""get"", lambda *_a, **_k: Resp())
    post_calls: list[tuple] = []

    def fake_post(url: str, json: dict, timeout: int) -> Resp:
        post_calls.append((url, json, timeout))
        return Resp()

    monkeypatch.setattr(mod.requests, ""post"", fake_post)

    env = {""OPENAI_API_KEY"": """", ""AGENTS_RUNTIME_PORT"": ""7000"", ""PORT"": ""8000""}
    with monkeypatch.context() as mctx:
        for k, v in env.items():
            mctx.setenv(k, v)
        mod.main([""--no-browser"", ""--submit-best""])

    assert post_calls == [
        (
            ""http://localhost:7000/v1/agents/business_helper/invoke"",
            {""action"": ""best_alpha""},
            10,
        )
    ]",tests/test_start_alpha_business.py,,1,7.194132978569833e-09,"The method is a test function that uses monkeypatching to simulate and test the behavior of the 'start_alpha_business' function. It is a unit test that ensures the correct HTTP POST request is made when the '--submit-best' flag is used. Such test functions are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained as part of the test suite."
survived,"    def fake_post(url: str, json: dict, timeout: int) -> Resp:
        post_calls.append((url, json, timeout))
        return Resp()
",tests/test_start_alpha_business.py,,1,3.2241866333029355e-08,"The method 'fake_post' is a mock function that simulates the behavior of an HTTP POST request by appending the call details to a list and returning a dummy response object. Such functions are commonly used in testing environments to avoid making actual network requests. Since testing is a crucial part of software development, especially for ensuring code reliability and performance, this method is likely to be retained for its utility in test scenarios."
survived,"        def terminate(self) -> None:
            pass
",tests/test_start_alpha_business.py,DummyProc,1,1.1478768974997603e-05,"The method 'terminate' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it is a placeholder for future functionality or is meant to be overridden in a subclass. If the method is part of a base class or interface, it is likely to survive because it provides a structure for subclasses to implement specific termination logic. However, if it is not used or overridden anywhere, it might be considered for deletion. Without additional context, it is more likely to survive as a placeholder or interface method."
survived,"def delete(
    url: str,
    *,
    params: dict | None = None,
    headers: dict | None = None,
    timeout: float | None = None,
) -> Response:
    """"""HTTP DELETE request.""""""
    return _call(""DELETE"", url, params=params, headers=headers, timeout=timeout)
",alpha_factory_v1/af_requests.py,,1,2.998960815863541e-09,"The method is a standard implementation of an HTTP DELETE request, which is a common and necessary operation in web development for removing resources from a server. The method is well-defined, using parameters for URL, headers, and timeout, which are typical for HTTP requests. It is likely to be used in various applications that require interaction with web services, making it a useful and relevant function. Therefore, it is unlikely to be deleted."
survived,"    def count_disclaimers_in_notebook(nb_path: Path) -> int:
        try:
            data = json.loads(nb_path.read_text(encoding=""utf-8""))
        except Exception:
            return 0
        text = """"
        for cell in data.get(""cells"", []):
            if cell.get(""cell_type"") == ""markdown"":
                src = cell.get(""source"", """")
                if isinstance(src, list):
                    text += """".join(src)
                else:
                    text += str(src)
        return """".join(text.split()).count(disclaimer_normalized)
",scripts/verify_disclaimer_snippet.py,,1,1.4166087846364157e-09,"The method 'count_disclaimers_in_notebook' is likely to survive because it serves a specific and useful purpose: counting the number of disclaimers in a Jupyter notebook. It handles potential exceptions when reading the file and processes the notebook's markdown cells to find disclaimers. This functionality can be valuable for ensuring compliance or documentation standards in notebooks, making it a useful utility function."
survived,"def validate_input_model(code: str) -> bool:
    """"""
    Validate that the provided input model code is safe and only defines
    Pydantic models. Import statements and unsafe builtins are disallowed.
    """"""

    try:
        tree = ast.parse(code)
    except SyntaxError as e:
        return False, f""Syntax error in input model: {str(e)}""

    unsafe_calls = [
        'eval', 'exec', '__import__', 'subprocess', 'os.system',
        'os.popen', 'os.spawn', 'os.fork', 'pty.spawn'
    ]

    for node in ast.walk(tree):
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            return False, ""Import statements are not allowed in input_model""

        if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id in unsafe_calls:
            return False, f""Unsafe function call: {node.func.id}""

        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
            attr_chain = []
            obj = node.func
            while isinstance(obj, ast.Attribute):
                attr_chain.append(obj.attr)
                obj = obj.value

            if isinstance(obj, ast.Name):
                attr_chain.append(obj.id)
                attr_path = '.'.join(reversed(attr_chain))

                if any(unsafe in attr_path for unsafe in unsafe_calls):
                    return False, f""Unsafe operation: {attr_path}""

    has_model = any(
        isinstance(node, ast.ClassDef) and
        any(
            (isinstance(base, ast.Name) and base.id == 'BaseModel') or
            (isinstance(base, ast.Attribute) and base.attr == 'BaseModel')
            for base in node.bases
        )
        for node in tree.body
    )

    if not has_model:
        return False, ""Input model must define a class inheriting from BaseModel""

    return True, """"
",backend/tools/tool_routes.py,,1,2.2159489282323004e-08,"The method `validate_input_model` is a utility function designed to ensure the safety and correctness of input code that is expected to define Pydantic models. It performs a static analysis of the code to check for unsafe operations and ensures that the code defines a class inheriting from `BaseModel`. This kind of validation is crucial in environments where user-provided code is executed, as it helps prevent security vulnerabilities and ensures that the code adheres to expected standards. Given the increasing use of Pydantic models in Python applications for data validation and settings management, this function is likely to be useful and relevant. Therefore, it is likely to be retained in the codebase."
survived,"def linear_curve(t: float) -> float:
    return max(0.0, min(1.0, t))
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/simulation/forecast.py,,1,1.4166087846364157e-09,"The method 'linear_curve' is a simple utility function that clamps a given float 't' between 0.0 and 1.0. Such functions are commonly used in various applications, including graphics, animations, and data normalization. The function is straightforward, efficient, and serves a clear purpose, making it likely to be useful in multiple contexts. Therefore, it is likely to be retained in the codebase."
survived,"def test_pareto_df() -> None:
    pop = [mats.Individual([0.0, 0.0]), mats.Individual([1.0, 1.0])]
    pop[0].rank = 0
    pop[1].rank = 1
    df = web_app.pareto_df(pop)
    assert set(df.columns) == {""x"", ""y"", ""rank""}
    assert len(df) == 2",tests/test_web_app.py,,1,2.3355930333443423e-09,"The method `test_pareto_df` is a unit test function that checks the functionality of the `pareto_df` method from the `web_app` module. It verifies that the DataFrame returned by `pareto_df` has the correct columns and length. Unit tests are crucial for ensuring code reliability and are typically maintained as part of the codebase to prevent regressions. Therefore, this method is likely to be retained as it serves an important role in testing."
survived,"    def test_discover_alpha_offline(self) -> None:
        openai_mock = types.SimpleNamespace(ChatCompletion=types.SimpleNamespace(create=Mock()))
        with patch.object(stub, ""openai"", openai_mock, create=True):
            with patch.dict(os.environ, {}, clear=True):
                picks = stub.discover_alpha(num=1, ledger=None, model=""gpt-4o-mini"")
        openai_mock.ChatCompletion.create.assert_not_called()
        self.assertIsInstance(picks, list)
        self.assertEqual(len(picks), 1)
",alpha_factory_v1/tests/test_cross_industry_alpha.py,TestCrossIndustryAlpha,1,2.5109990926928157e-08,"The method `test_discover_alpha_offline` is a unit test designed to verify the behavior of the `discover_alpha` function in an offline mode. It uses mocking to ensure that the `openai.ChatCompletion.create` method is not called, which is a valid test case to ensure that the function behaves correctly without making external API calls. The test checks that the output is a list of the expected length, which is a common practice in unit testing to validate function outputs. Since this test is useful for ensuring the reliability and correctness of the `discover_alpha` function, it is likely to be retained in the codebase."
survived,"def test_namedarray_runtime_check_with_category():
    B = Axis(""batch"", 1)
    arr = NamedArray(jnp.zeros((B.size,), dtype=jnp.float32), (B,))
    assert arr.matches_axes(Float[""batch""])  # type: ignore
    assert not arr.matches_axes(Int[""batch""])  # type: ignore",tests/test_namedarray_typing.py,,1,2.0611536181902033e-09,"The method `test_namedarray_runtime_check_with_category` is a test function that checks the behavior of a `NamedArray` object with respect to axis matching. It uses assertions to verify that the `NamedArray` matches a `Float` axis but not an `Int` axis. This kind of test is crucial for ensuring the correctness of the `NamedArray` functionality, especially in a library that deals with numerical computations and data structures. Test functions are generally retained in codebases to ensure ongoing reliability and correctness of the code, especially when changes are made. Therefore, it is likely that this method will be Survived (1)."
survived,"def _wrap_namedarray_with_category(category: DTypeCategory):
    class DTypeType:
        def __class_getitem__(cls, axes_spec):
            axes = _parse_namedarray_axes(axes_spec)
            axes_with_dtype = replace(axes, dtype=category)
            return tp.Annotated[NamedArray, axes_with_dtype]

    return DTypeType
",src/haliax/typing.py,,1,4.944450477491054e-09,"The method '_wrap_namedarray_with_category' is a utility function that defines a dynamic class 'DTypeType' with a special method '__class_getitem__'. This method is likely used for creating type annotations for a 'NamedArray' with specific axes and a dtype category. The function is specialized and seems to be part of a larger framework or library dealing with typed arrays or data structures. Such utility functions are often retained as they provide essential functionality for type safety and code clarity in complex systems. Unless there is a significant change in the design or requirements of the system, this method is likely to survive."
survived,"def test_dtype_and_axes_annotation():
    def foo(x: f32[""batch embed""]):  # type: ignore  # noqa: F722
        pass

    ann = typing.get_args(typing.get_type_hints(foo, include_extras=True)[""x""])
    assert ann[0] is NamedArray
    spec = ann[1]
    assert spec.dtype == jnp.float32
    assert spec.before == (""batch"", ""embed"")
",tests/test_dtype_typing.py,,1,1.444980317078884e-07,"The method `test_dtype_and_axes_annotation` is a test function that checks the type annotations of a function `foo`. It uses assertions to verify that the annotations are as expected. This is a typical pattern in test code to ensure that the code behaves correctly. Since it is a test function, it is likely to be useful for maintaining code quality and ensuring that changes do not break expected behavior. Therefore, it is unlikely to be deleted unless the functionality it tests is removed or significantly changed."
survived,"    def raise_for_status(self):
        if self.status_code >= 400:
            raise RuntimeError(""http error"")
",tests/test_openai_bridge_integration.py,DummyResponse,1,5.905303995456778e-10,"The method 'raise_for_status' is a common utility in HTTP client libraries to check the status code of a response and raise an exception if the status code indicates an error (typically 4xx or 5xx). This method is useful for error handling and is a standard practice in many HTTP client implementations. Therefore, it is likely to be retained as it provides essential functionality for handling HTTP errors."
survived,"def convert_corpus(corpus, index):
    new_corpus = []
    for doc in corpus:
        new_corpus.append([index[w] for w in doc])
    return new_corpus
",scripts/bbc_demo.py,,1,3.850741907939403e-09,"The method 'convert_corpus' is a utility function that transforms a list of documents (corpus) into a new format using a provided index mapping. This type of function is commonly used in text processing tasks, such as preparing data for machine learning models. The function is simple, clear, and performs a useful task without any apparent issues or inefficiencies. Therefore, it is likely to be retained in the codebase."
survived,"    async def xml_stream_2(*args, **kwargs):
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""<""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""judgement""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="">""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""The""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="" answer""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="" is""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="" humorous""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="".""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""<""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""/judgement""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="">""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""<""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content=""completed""))])
        yield ModelResponseStream(model=""gpt-4o-mini"", choices=[StreamingChoices(delta=Delta(content="">""))])
",tests/streaming/test_streaming.py,,1,2.699578619062706e-07,"The method `xml_stream_2` is designed to yield a series of `ModelResponseStream` objects, which appear to be part of a streaming response system, likely for generating or processing XML-like data. The method is structured to output a sequence of content pieces that form a coherent message, wrapped in XML-like tags. This functionality is specific and could be part of a larger system that requires streaming data in this format. Given the specificity and potential utility of this method in a streaming context, it is likely to be retained unless the system it supports is deprecated or significantly restructured."
survived,"async def test_build_regex_guardrails_trigger():
    config = GuardrailConfig(rules=[GuardrailRule(name=""block"", pattern=""bad"")])
    guards = build_regex_guardrails(config)
    assert len(guards) == 1
    guard = guards[0]

    await guard(""good text"")  # should not raise

    with pytest.raises(ValueError):
        await guard(""this is bad"")",tests/test_guardrail_generator.py,,1,2.8453347280241004e-08,"The method `test_build_regex_guardrails_trigger` is a test function that verifies the behavior of a guardrail system using regex patterns. It is a typical unit test that ensures the guardrail correctly identifies and blocks text matching a specific pattern. Such test functions are crucial for maintaining code quality and ensuring that the implemented logic works as expected. Therefore, it is unlikely to be deleted as it serves an important role in the testing suite."
survived,"        def log(self, env) -> None:  # type: ignore[override]
            events.append(env.payload.get(""event""))
",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_orchestrator.py,DummyLedger,1,4.944450477491054e-09,"The method 'log' is a simple function that appends an event from the 'env' object to a global 'events' list. It is a straightforward utility function that is likely used for logging or tracking events. Such methods are generally useful in applications for debugging or monitoring purposes. Unless there is a significant change in the application's requirements or architecture that renders this method obsolete, it is likely to survive."
survived,"        def __init__(self, *_a, **_kw) -> None:
            pass
",tests/test_agents.py,DummyLedger,0,0.999985261023967,"The method is a constructor that does not perform any initialization or operations. It takes arbitrary positional and keyword arguments but does nothing with them, which is generally not useful. Unless this is a placeholder for future development or part of a larger framework where such a pattern is necessary, it is likely to be deleted or refactored to include meaningful initialization logic."
survived,"def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get(""right"") and j.get(""left""):
            matched = [False] * len(j[""items""])
            for left in items:
                m = False
                for ri, right in enumerate(j[""items""]):
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j[""items""]):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get(""right""):
            for right in j[""items""]:
                m = False
                for left in items:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j[""items""]:
                    keep = True
                    if j.get(""on""):
                        keep = j[""on""](*left, right)
                    if not keep:
                        continue
                    m = True
                    joined.append(left + [right])
                if j.get(""left"") and (not m):
                    joined.append(left + [None])
        items = joined
    if opts.get(""where""):
        items = [r for r in items if opts[""where""](*r)]
    if opts.get(""sortKey""):

        def _key(it):
            k = opts[""sortKey""](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k

        items.sort(key=_key)
    if ""skip"" in opts:
        n = opts[""skip""]
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if ""take"" in opts:
        n = opts[""take""]
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts[""select""](*r))
    return res
",tests/machine/x/python/q3.py,,1,6.825604231969389e-08,"The method '_query' is a complex function that performs a series of operations on data, including joining, filtering, sorting, and selecting. It is a utility function that seems to be designed for flexible data manipulation, which is a common requirement in many applications. The function is not overly specific to a particular use case, making it versatile and reusable. Additionally, the function appears to be well-structured, handling various scenarios such as different types of joins and optional operations like sorting and filtering. These characteristics suggest that the method is likely to be useful in a wide range of contexts, increasing its chances of being retained in the codebase."
survived,"def _min(v):
    if hasattr(v, ""Items""):
        v = v.Items
    if not isinstance(v, list):
        raise Exception(""min() expects list or group"")
    vals = [it for it in v if it is not None]
    if not vals:
        return 0
    return min(vals)
",tests/machine/x/python/q2.py,,0,0.9999785550602307,"The method _min is a utility function that attempts to find the minimum value in a list or a similar iterable structure. However, it has several issues that make it less robust and potentially problematic in a production environment. 

1. **Naming Convention**: The method name _min is not descriptive and could be confused with Python's built-in min function. This could lead to confusion and errors in larger codebases.

2. **Error Handling**: The method raises a generic Exception with a vague message. It would be better to raise a more specific exception type with a clearer message.

3. **Type Checking**: The method checks if the input has an 'Items' attribute and uses it if present, but this is not a common pattern and could lead to unexpected behavior if the input is not as expected.

4. **Handling of None Values**: The method filters out None values, which might not be the desired behavior in all cases. This should be documented or made optional.

5. **Return Value for Empty List**: The method returns 0 for an empty list, which might not be appropriate in all contexts. It could be more useful to return None or raise an exception.

Due to these issues, the method is likely to be refactored or replaced with a more robust solution, leading to its deletion."
survived,"def _count(v):
    if isinstance(v, list):
        return len(v)
    if hasattr(v, ""Items""):
        return len(v.Items)
    raise Exception(""count() expects list or group"")
",tests/machine/x/python/q1.py,,1,2.3355930333443423e-09,"The method _count is a utility function that checks if the input is a list or has an 'Items' attribute, and returns the length accordingly. This is a common pattern for handling different types of collections in a flexible way. The method is simple, clear, and serves a specific purpose, which makes it likely to be retained in the codebase. It also raises an exception for unsupported types, which is good practice for error handling. Therefore, the method is likely to survive."
survived,"def _q0():
    _src = lineitem
    _rows = _query(
        _src,
        [],
        {
            ""select"": lambda row: row,
            ""where"": lambda row: row[""l_shipdate""] <= ""1998-09-02"",
        },
    )
    _groups = _group_by(
        _rows,
        lambda row: {
            ""returnflag"": row[""l_returnflag""],
            ""linestatus"": row[""l_linestatus""],
        },
    )
    _items1 = _groups
    return [
        {
            ""returnflag"": _get(_get(g, ""key""), ""returnflag""),
            ""linestatus"": _get(_get(g, ""key""), ""linestatus""),
            ""sum_qty"": _sum([x[""l_quantity""] for x in g]),
            ""sum_base_price"": _sum([x[""l_extendedprice""] for x in g]),
            ""sum_disc_price"": _sum(
                [x[""l_extendedprice""] * (1 - x[""l_discount""]) for x in g]
            ),
            ""sum_charge"": _sum(
                [
                    x[""l_extendedprice""] * (1 - x[""l_discount""]) * (1 + x[""l_tax""])
                    for x in g
                ]
            ),
            ""avg_qty"": _avg([x[""l_quantity""] for x in g]),
            ""avg_price"": _avg([x[""l_extendedprice""] for x in g]),
            ""avg_disc"": _avg([x[""l_discount""] for x in g]),
            ""count_order"": len(g.Items),
        }
        for g in _items1
    ]
",tests/machine/x/python/q1.py,,1,4.1399375473943306e-08,"The method `_q0` is a specific query function that processes data from a `lineitem` source, filters it based on a date condition, groups it by certain fields, and then calculates various aggregate metrics. This type of function is typically used in data processing or reporting tasks, which are common in many applications. Unless there is a significant change in the application's requirements or architecture, such utility functions are likely to be retained as they provide essential data manipulation capabilities."
survived,"    def __getitem__(self, key):
        return getattr(self, key)
",tests/machine/x/python/q2.py,Region,1,6.825604231969389e-08,"The method `__getitem__` is a special method in Python used to define behavior for accessing elements using the square bracket notation, like `obj[key]`. In this code, it is implemented to return an attribute of the object using `getattr`. This is a common and useful pattern for dynamic attribute access, especially in classes that need to provide dictionary-like access to their attributes. Since this method provides a clear and useful functionality, it is likely to be retained in the code."
survived,"def test_summarize_error_returns_first_line() -> None:
    log = ""E   ValueError: bad\nline2\nline3""
    assert llm_client.summarize_error(log) == ""E   ValueError: bad""
",tests/test_llm_client_utils.py,,1,2.2159489282323004e-08,"The method 'test_summarize_error_returns_first_line' is a unit test designed to verify that the 'summarize_error' function of the 'llm_client' correctly extracts the first line of an error log. This is a common and useful functionality in error handling, as it allows developers to quickly identify the type and message of an error without sifting through potentially lengthy logs. The test is straightforward, testing a specific and likely common use case, and does not appear to have any issues or redundancies that would warrant its deletion. Therefore, it is likely to be retained in the codebase."
survived,"        def __init__(self, loss: float) -> None:
            self.loss = loss
",tests/test_world_model_demo.py,DummyLearner,1,2.5109990926928157e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming in Python. Constructors are essential for initializing new objects with specific attributes, in this case, setting the 'loss' attribute. There is no indication that this constructor is redundant or unnecessary, so it is likely to be retained."
survived,"        def remember(self, _obs, _reward) -> None:
            pass
",tests/test_world_model_demo.py,DummyLearner,0,0.9999785550602307,"The method 'remember' is defined but not implemented, as it only contains a 'pass' statement. This suggests that it is a placeholder for future implementation. However, without any additional context or usage, it is likely to be deleted if it remains unimplemented, as it does not contribute any functionality to the code."
survived,"def bincount(
    x: NamedArray,
    Counts: Axis,
    *,
    weights: NamedArray | ArrayLike | None = None,
    minlength: int = 0,
) -> NamedArray:
    """"""Named version of `jax.numpy.bincount`.

    The output axis is specified by ``Counts``.
    """"""

    if x.ndim != 1:
        raise ValueError(""bincount only supports 1D arrays"")

    w_array = None
    if weights is not None:
        if isinstance(weights, NamedArray):
            weights = haliax.broadcast_to(weights, x.axes)
            w_array = weights.array
        else:
            w_array = jnp.asarray(weights)

    result = jnp.bincount(x.array, weights=w_array, minlength=minlength, length=Counts.size)
    return NamedArray(result, (Counts,))
",src/haliax/ops.py,,1,1.522997951276035e-08,"The method `bincount` is a specialized version of the `jax.numpy.bincount` function, tailored to work with `NamedArray` objects. It provides additional functionality by allowing the specification of the output axis through the `Counts` parameter and supports broadcasting of weights if they are also `NamedArray` objects. This added functionality and integration with `NamedArray` makes it a useful utility for users working within this specific framework. Therefore, it is likely to be retained as it serves a specific purpose that the standard `bincount` does not address."
survived,"        async def get_stuff() -> dict:
            return {}
",tests/test_tooldef.py,,0,0.9999921107349486,"The method 'get_stuff' is an asynchronous function that returns an empty dictionary. While it is syntactically correct, its utility is questionable because it doesn't perform any operations or return any meaningful data. If this method is part of a larger codebase, it might be a placeholder for future implementation. However, if it remains unchanged and unused, it is likely to be deleted as it doesn't contribute any functionality."
survived,"        async def create_item() -> bool:
            return True
",tests/test_tooldef.py,,1,2.3823698451773172e-07,"The method 'create_item' is a simple asynchronous function that returns a boolean value 'True'. It is likely a placeholder or a stub for a more complex operation that will be implemented in the future. Since it is a basic function with no apparent issues or deprecated features, it is likely to survive until it is expanded or modified to include actual logic."
survived,"        async def get_items(user_id: int) -> list[Item]:
            return []
",tests/test_tooldef.py,,1,8.481104769395558e-05,"The method `get_items` is an asynchronous function that takes a user ID and returns an empty list of `Item` objects. The method is likely a placeholder or a stub for future implementation, as it currently does not perform any meaningful operation or return any data. However, the method signature suggests that it is intended to retrieve a list of items associated with a user, which is a common operation in many applications. Given that it is a stub, it is more likely to be further developed rather than deleted, as it represents a necessary functionality that is yet to be implemented."
survived,"def _verify(path: Path, name: str) -> bytes:
    data = path.read_bytes()
    expected = checksums.get(name)
    if expected:
        actual = sha384(path)
        if expected != actual:
            sys.exit(f""Checksum mismatch for {name}"")
    return data
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/manual_build.py,,1,1.0467401685178159e-08,"The method '_verify' is a utility function that reads bytes from a file, checks its checksum against an expected value, and exits the program if there is a mismatch. This kind of functionality is crucial for ensuring data integrity, especially in applications where file corruption can lead to significant issues. The method is likely to be used in scenarios where data verification is critical, such as in software installations, data migrations, or secure data transfers. Given its importance in maintaining data integrity, it is unlikely to be deleted unless it is replaced by a more efficient or secure method. Therefore, the method will likely survive."
survived,"def evaluate_agent(agent: Agent, model: str) -> float:
    """"""Return agent score when evaluated with ``model``.

    This placeholder implementation simply returns the archived score. Tests
    patch this function to provide deterministic mock values.
    """"""

    return agent.score
",src/tools/transfer_test.py,,1,5.715002851580502e-07,"The method `evaluate_agent` is a simple function that returns the score of an agent. It is marked as a placeholder implementation, which suggests that it is intended to be replaced or extended in the future. However, as it stands, it serves a basic purpose of returning a score, which might be useful in certain contexts, especially for testing or as a default behavior. Unless there is a significant change in the requirements or a better implementation is provided, this method is likely to survive as it provides a basic utility."
survived,"def run() -> None:
    parts = [""poly"", ""task"", ""18""]
    joined = ""-"".join(parts)
    assert joined.split(""-"")[2] == str(18)",benchmarks/poly_mini/task_018.py,,1,1.955568070542584e-08,"The method 'run' is a simple function that joins a list of strings with a hyphen and then asserts that the third element of the split string is '18'. This is a straightforward and correct implementation of string manipulation and assertion. There are no apparent issues or inefficiencies in the code, and it serves a clear purpose. Therefore, there is no reason to delete this method as it is functional and could be useful in contexts where such string operations are needed."
survived,"def run() -> None:
    n = 16
    total = sum(range(n))
    expected = n*(n-1)//2
    assert total == expected",benchmarks/swe_mini/task_016.py,,1,6.144172127844639e-06,"The method 'run' is a simple function that calculates the sum of numbers from 0 to n-1 and checks if it matches the expected sum using the formula n*(n-1)//2. This is a basic implementation of a mathematical property and serves as a simple test or demonstration of the formula. The method is self-contained, does not depend on external inputs, and correctly implements the logic it is supposed to demonstrate. Therefore, there is no reason to delete it unless it is deemed unnecessary in the context of the larger codebase. However, as a standalone function, it is correctly implemented and serves its purpose."
survived,"def run() -> None:
    parts = [""poly"", ""task"", ""9""]
    joined = ""-"".join(parts)
    assert joined.split(""-"")[2] == str(9)",benchmarks/poly_mini/task_009.py,,1,9.237449576640118e-09,"The method 'run' is a simple function that joins a list of strings with a hyphen and then splits the resulting string to assert that the third element is '9'. This is a straightforward and correct implementation of string manipulation in Python. The function is clear, concise, and performs as expected without any unnecessary complexity or errors. Therefore, there is no reason to delete this method as it serves its purpose effectively."
survived,"def run() -> None:
    parts = [""poly"", ""task"", ""6""]
    joined = ""-"".join(parts)
    assert joined.split(""-"")[2] == str(6)",benchmarks/poly_mini/task_006.py,,1,3.2241866333029355e-08,The method 'run' is a simple function that joins a list of strings with a hyphen and then splits the resulting string to assert that the third element is '6'. This is a basic operation that demonstrates string manipulation and assertion in Python. The method is syntactically correct and performs a valid operation without any side effects or errors. It is likely to be retained as it serves as a useful example of string operations and assertions in Python.
survived,"def test_run_transfer_test_appends(tmp_path, monkeypatch) -> None:
    db = tmp_path / ""arch.db""
    arch = Archive(db)
    arch.add({""name"": ""a""}, 0.5)
    out = tmp_path / ""results"" / ""transfer.csv""
    out.parent.mkdir(parents=True)
    out.write_text(""id,model,score\n1,z,0.500\n"")

    def fake_eval(agent, model):
        return agent.score + 0.1

    monkeypatch.setattr(tt, ""evaluate_agent"", fake_eval)
    tt.run_transfer_test([""m""], 1, archive_path=db, out_file=out)
    lines = out.read_text().splitlines()
    assert lines == [""id,model,score"", ""1,z,0.500"", ""1,m,0.600""]",tests/test_transfer_test.py,,1,2.8453347280241004e-08,"The method 'test_run_transfer_test_appends' is a unit test function that verifies the behavior of the 'run_transfer_test' function. It uses a temporary path and monkeypatching to simulate the environment and dependencies, ensuring that the function appends the correct data to a CSV file. This is a typical and necessary practice in software development to ensure code reliability and correctness. Therefore, it is unlikely to be deleted as it serves an important role in maintaining the integrity of the codebase."
survived,"def add(a: int, b: int) -> int:
    """"""Return the sum of a and b, intentionally broken.""""""
    return a - b",tests/fixtures/self_heal_repo/calc.py,,0,0.9999599363048656,The method is intended to add two numbers but is incorrectly implemented to subtract them instead. This is a fundamental error that contradicts the method's purpose and description. Such a method is likely to be deleted or corrected in future iterations to ensure it performs as expected.
survived,"    def raise_for_status(self):
        pass
",tests/test_inspector_bridge.py,DummyResponse,0,0.9999996533672291,"The method `raise_for_status` is defined but not implemented, as it only contains a `pass` statement. This suggests that the method is either a placeholder for future implementation or intentionally left blank to override a method from a superclass without adding any functionality. Without additional context, such as comments or documentation indicating future plans for this method, it is likely to be considered unnecessary and could be deleted. However, if it is part of a larger framework where such methods are expected to exist, it might survive as a placeholder. Given the lack of context, the prediction leans towards deletion."
survived,"    async def close(self) -> None:
        """"""Close the underlying transport connection.""""""
        await self._impl.close()
",alpha_factory_v1/backend/a2a_client.py,A2AClient,1,9.736200303530205e-10,"The method 'close' is a standard and necessary part of managing resources in asynchronous programming. It ensures that the underlying transport connection is properly closed, which is crucial for resource management and preventing memory leaks. The method is simple, clear, and directly calls the close method on the implementation, which is a common pattern. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def test_rsi(self):
        uptrend = list(range(1, 20))
        self.assertGreater(am.rsi(uptrend, period=5), 70)
        downtrend = list(range(20, 1, -1))
        self.assertLess(am.rsi(downtrend, period=5), 30)
",alpha_factory_v1/tests/test_alpha_model.py,AlphaModelTest,1,1.0467401685178159e-08,"The method 'test_rsi' is a unit test for the RSI (Relative Strength Index) function, which is a common technical indicator used in financial markets to measure the magnitude of recent price changes. The test checks if the RSI value is greater than 70 for an uptrend and less than 30 for a downtrend, which are typical thresholds for overbought and oversold conditions, respectively. This test is useful for validating the correctness of the RSI implementation. Since it serves a clear purpose in ensuring the reliability of a financial analysis tool, it is likely to be retained."
survived,"    def test_sma_crossover(self):
        prices = [5, 4, 3, 2, 3, 4]
        self.assertEqual(am.sma_crossover(prices, fast=2, slow=4), 1)
        prices = [2, 3, 4, 5, 4, 3]
        self.assertEqual(am.sma_crossover(prices, fast=2, slow=4), -1)
",alpha_factory_v1/tests/test_alpha_model.py,AlphaModelTest,1,3.2241866333029355e-08,"The method 'test_sma_crossover' is a unit test for the 'sma_crossover' function, which is likely part of a larger codebase involving financial analysis or trading strategies. Unit tests are crucial for ensuring the correctness of code, especially in financial applications where accuracy is critical. The test checks the behavior of the 'sma_crossover' function with different price inputs, which is a common practice to validate the function's logic. Therefore, this method is likely to be retained as it serves an important role in maintaining code quality and reliability."
survived,"    def test_toy_optimal(self):
        genes = {""temperature"": 0.7, ""top_p"": 0.9, ""max_tokens"": 128}
        self.assertAlmostEqual(gt.toy_fitness(genes), 3.0, places=2)
",alpha_factory_v1/tests/test_genetic_tests.py,GeneticTestsTest,1,2.5109990926928157e-08,"The method `test_toy_optimal` is a unit test that checks the functionality of the `toy_fitness` method from the `gt` module. It uses the `assertAlmostEqual` method to verify that the output of `toy_fitness` with the given `genes` dictionary is approximately 3.0, with a precision of two decimal places. This is a standard practice in testing to ensure that the function behaves as expected. Since testing is a crucial part of software development to maintain code quality and reliability, this method is likely to be retained in the codebase."
survived,"                    def clear(self):
                        self.nodes.clear()
                        self.edges.clear()
",alpha_factory_v1/backend/memory_graph.py,GraphMemory._Stub,1,1.9171715133907573e-10,"The method 'clear' is a utility function that resets or clears the state of an object by emptying its 'nodes' and 'edges' attributes. Such methods are commonly used in data structures or graph-related classes to allow for reusability of the object without needing to create a new instance. This functionality is generally useful and aligns with common programming practices, suggesting that it is likely to be retained in the codebase."
survived,"def _extract_json(text: str) -> Dict[str, Any]:
    """"""Return the first JSON object found inside *text*.""""""
    match = _JSON_RE.search(text)
    if not match:
        raise ValueError(""no JSON object found"")
    return json.loads(match.group(0))
",alpha_factory_v1/backend/planner_agent.py,,1,7.194132978569833e-09,"The method _extract_json is a utility function designed to extract and parse the first JSON object found within a given text string. This is a common requirement in many applications where JSON data is embedded within larger text blocks, such as logs or mixed content files. The function uses a regular expression to search for JSON patterns and then parses the first match using json.loads. This functionality is useful and likely to be reused in various contexts where JSON data extraction is needed. Therefore, the method is likely to be retained in the codebase."
survived,"    def test_fallback_logic(self):
        agent = DummyAgent()
        model = DummyModel(""not json"")
        planner = PlannerAgent(
            name=""planner"",
            model=model,
            memory=self.memory,
            gov=self.gov,
            domain_agents=[agent],
        )
        random_result = planner.think([])[0]
        self.assertEqual(random_result[""agent""], agent.name)
        self.assertIn(""fallback"", random_result[""reason""])
",alpha_factory_v1/tests/test_planner_agent.py,PlannerAgentTest,1,4.944450477491054e-09,"The method 'test_fallback_logic' is a unit test designed to verify the fallback logic of a 'PlannerAgent'. It checks if the 'PlannerAgent' correctly identifies a fallback scenario and attributes it to the 'DummyAgent'. Unit tests are crucial for ensuring code reliability and are typically retained to maintain test coverage and code quality. Therefore, this method is likely to be retained."
survived,"    def vet_plans(self, agent, plans):  # noqa: D401
        return plans
",alpha_factory_v1/tests/test_planner_agent.py,DummyGov,0,0.9999994956527948,"The method 'vet_plans' is a simple pass-through function that takes two arguments, 'agent' and 'plans', and returns 'plans' without any modification or processing. This method does not add any value or functionality beyond what is already available by directly using the 'plans' variable. Such methods are often considered redundant and are likely to be deleted unless there is a specific reason to keep them, such as future expansion or maintaining a consistent interface."
survived,"    def test_invalid_params_raise(self):
        with self.assertRaises(ValueError):
            am.momentum([1, 2], lookback=0)
        with self.assertRaises(ValueError):
            am.sma_crossover([1]*5, fast=0, slow=1)
        with self.assertRaises(ValueError):
            am.sma_crossover([1]*5, fast=5, slow=3)
        with self.assertRaises(ValueError):
            am.ema([1], span=0)
        with self.assertRaises(ValueError):
            am.rsi([1, 2], period=0)
        with self.assertRaises(ValueError):
            am.bollinger_bands([1], window=0)
",alpha_factory_v1/tests/test_alpha_model.py,AlphaModelTest,1,6.348800075736417e-09,"The method 'test_invalid_params_raise' is a unit test designed to ensure that certain functions in the 'am' module raise a ValueError when given invalid parameters. This is a common and important practice in software development to ensure robustness and error handling in code. Since testing for exceptions is a crucial part of validating input handling, this method is likely to be retained as part of the test suite to maintain code quality."
survived,"def main() -> None:
    path = Path(sys.argv[1]) if len(sys.argv) > 1 else Path(""alpha_factory_v1/dashboards/alpha_factory_overview.json"")
    host = os.environ.get(""GRAFANA_HOST"", ""http://localhost:3000"").rstrip(""/"")
    token = os.environ.get(""GRAFANA_TOKEN"")
    if not token:
        raise SystemExit(""GRAFANA_TOKEN environment variable is required"")

    with path.open() as f:
        dashboard = json.load(f)

    payload = {""dashboard"": dashboard, ""folderId"": 0, ""overwrite"": True, ""inputs"": []}
    headers = {""Authorization"": f""Bearer {token}"", ""Content-Type"": ""application/json""}
    url = f""{host}/api/dashboards/import""
    resp = post(url, json=payload, headers=headers, timeout=10)
    try:
        resp.raise_for_status()
    except Exception as exc:  # pragma: no cover - network errors
        print(resp.text)
        raise SystemExit(exc)

    print(f""Imported dashboard '{dashboard.get('title', path.name)}' to {host}"")
",alpha_factory_v1/scripts/import_dashboard.py,,1,1.3440409770490404e-08,"The method is a complete and functional script for importing a Grafana dashboard using a JSON file. It handles environment variables, file reading, HTTP requests, and error handling effectively. The method is likely to be useful in its current form for users who need to automate the import of dashboards into Grafana, especially in environments where such automation is necessary. There are no obvious reasons for it to be deleted, as it serves a clear purpose and is implemented correctly."
survived,"    def __repr__(self) -> str:  # noqa: D401
        return f""MarketEnv(price={self.price:.2f}, position={self.position})""
",alpha_factory_v1/backend/environments/market_sim.py,MarketEnv,1,1.725782769012759e-08,"The method `__repr__` is a standard Python method used to provide a string representation of an object, which is useful for debugging and logging. The implementation here is concise and follows the convention of including the class name and its attributes in the string representation. This method is likely to be useful for developers working with the `MarketEnv` class to quickly understand the state of an object. Therefore, it is unlikely to be deleted."
survived,"    def remember(self, obs, reward):
        self.buffer.append((obs,reward))
        if len(self.buffer)>CFG.buffer_limit:
            self.buffer.pop(0)
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo.py,Learner,1,4.599055376537186e-10,"The method 'remember' is a simple and efficient way to manage a buffer of observations and rewards. It appends new data to the buffer and ensures the buffer does not exceed a predefined limit by removing the oldest entry when necessary. This is a common pattern in reinforcement learning and data management, making it likely to be retained in the codebase."
survived,"def _main():
    p=argparse.ArgumentParser(prog=""alpha_asi_world_model_demo"")
    p.add_argument(""--demo"",action=""store_true"")
    p.add_argument(""--emit-docker"",action=""store_true"")
    p.add_argument(""--emit-helm"",action=""store_true"")
    p.add_argument(""--emit-notebook"",action=""store_true"")
    p.add_argument(""--host"",default=""127.0.0.1"")
    p.add_argument(""--port"",type=int,default=7860)
    args=p.parse_args()
    if args.emit_docker: emit_docker()
    elif args.emit_helm: emit_helm()
    elif args.emit_notebook: emit_notebook()
    elif args.demo:
        uvicorn.run(""alpha_asi_world_model_demo:app"",host=args.host,port=args.port,log_level=""info"")
    else: p.print_help()
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo.py,,1,3.653482080241728e-08,"The method '_main()' is a typical entry point for a command-line interface (CLI) application. It uses the argparse library to parse command-line arguments and execute different functions based on those arguments. This is a common pattern in Python applications that need to be run from the command line. The method is well-structured and serves a clear purpose in the application, making it unlikely to be deleted unless the entire application is refactored or the CLI functionality is no longer needed."
survived,"    def __init__(self, obs_dim: int, act_dim: int):
        super().__init__()
        self.repr = Repr(obs_dim, CFG.hidden)
        self.dyn  = Dyn(CFG.hidden, act_dim)
        self.pred = Pred(CFG.hidden, act_dim)
",alpha_factory_v1/demos/alpha_asi_world_model/alpha_asi_world_model_demo.py,MuZeroTiny,1,8.31527990378713e-07,"The method is a constructor (__init__) for a class, which is a fundamental part of class definition in Python. Constructors are essential for initializing new objects and setting up initial state, so they are unlikely to be deleted unless the entire class is being refactored or removed. Additionally, the method is using parameters and initializing important components (Repr, Dyn, Pred) which suggests it is actively used in the class's functionality."
survived,"    def test_env_defaults(self):
        os.environ[""PORT""] = ""9000""
        os.environ[""METRICS_PORT""] = ""9100""
        os.environ[""A2A_PORT""] = ""9200""
        os.environ[""CYCLE""] = ""5""
        args = self._parse([])
        for key in (""PORT"", ""METRICS_PORT"", ""A2A_PORT"", ""CYCLE""):
            os.environ.pop(key, None)
        self.assertEqual(args.port, 9000)
        self.assertEqual(args.metrics_port, 9100)
        self.assertEqual(args.a2a_port, 9200)
        self.assertEqual(args.cycle, 5)
",alpha_factory_v1/tests/test_edge_runner.py,EdgeRunnerParseTest,1,2.646573631904765e-09,"The method 'test_env_defaults' is a unit test that sets environment variables, parses them, and then checks if the parsed values match the expected defaults. This is a common practice in testing configurations and ensuring that environment variables are correctly read and applied. Such tests are crucial for maintaining the reliability of software that depends on environment configurations. Therefore, it is likely to be retained as part of the test suite."
survived,"def list_available_examples() -> dict[str, str]:
    """"""Return a mapping of example name to app path.""""""
    base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
    examples: dict[str, str] = {}
    for entry in os.scandir(base_dir):
        if not entry.is_dir() or entry.name == ""openai_chat_agent"":
            continue
        app_path = os.path.join(entry.path, ""app.py"")
        if os.path.exists(app_path):
            examples[entry.name] = app_path
    return examples
",examples/openai_chat_agent/app.py,,1,3.581747929000289e-10,"The method 'list_available_examples' is likely to survive because it provides a useful utility function that maps example names to their corresponding application paths. This can be particularly helpful in scenarios where there are multiple example applications stored in directories, and a quick reference to their paths is needed. The function is well-defined, uses standard library functions effectively, and includes a docstring for clarity. Additionally, it handles edge cases such as skipping non-directory entries and specific directories that should not be included, which indicates thoughtful implementation."
survived,"def test_results_dir_permissions(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
    """"""Directory is created with 0700 permissions.""""""

    path = tmp_path / ""results""
    monkeypatch.setenv(""SIM_RESULTS_DIR"", str(path))

    import importlib

    from src.interface import api_server as api

    api = importlib.reload(api)

    assert path.exists()
    assert (path.stat().st_mode & 0o777) == 0o700
",tests/test_api_server.py,,1,3.3982678079468468e-09,"The method 'test_results_dir_permissions' is a test function that checks if a directory is created with specific permissions (0700). It uses pytest's 'monkeypatch' to set an environment variable and 'tmp_path' to create a temporary directory. The function is well-structured for its purpose, and testing directory permissions is a common requirement in software that deals with file system operations. There is no indication that this functionality is obsolete or unnecessary, so it is likely to be retained."
survived,"    def fake_secho(message, **kwargs):
        messages.append(click.unstyle(message))
",tests/integration/test_ux_interactions.py,,1,5.043472052266442e-07,"The method `fake_secho` is a mock or test function that appends an unstyled message to a list called `messages`. This function is likely used in a testing context to verify that messages are being generated correctly without the styling that `click.secho` would normally apply. Such utility functions are common in test suites to simulate or capture output for assertions. Since it serves a specific purpose in testing, it is unlikely to be deleted unless the testing strategy changes or the function is replaced by a more comprehensive testing utility."
survived,"def capture_secho(monkeypatch):
    messages = []

    def fake_secho(message, **kwargs):
        messages.append(click.unstyle(message))

    monkeypatch.setattr(click, ""secho"", fake_secho)
    return messages
",tests/integration/test_ux_interactions.py,,1,9.237449576640118e-09,"The method 'capture_secho' is a utility function used for testing purposes, specifically to capture and store messages that would be printed using 'click.secho'. This is a common pattern in testing to verify that the correct messages are being output without actually printing them to the console. Such utility functions are often retained in codebases to facilitate testing, especially when using libraries like 'click' for command-line interfaces. Therefore, it is likely to survive."
survived,"        def with_output(self, x):
            out = x + self.w
            return out, 2 * self.w
",tests/test_scan.py,Module,1,8.592166611791576e-10,"The method 'with_output' is a simple function that takes an input 'x', adds it to an instance variable 'self.w', and returns a tuple containing the result of this addition and twice the value of 'self.w'. This method is straightforward and performs a clear, useful operation that could be part of a larger class or module. It is likely to be used in contexts where both the result of the addition and a scaled version of 'self.w' are needed. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"    def scan_via(self, fn: Callable[..., tuple[CarryT, OutputT_co]]):
        """"""Return a function that scans over the stack using ``fn``.

        ``fn`` should take a block and a carry and return ``(carry, output)``.
        Semantics match :func:`haliax.scan` over the block axis.
        """"""

        def do_block(carry: CarryT, block: M) -> tuple[CarryT, OutputT_co]:
            return fn(block, carry)

        def do_scan(init: CarryT) -> tuple[CarryT, OutputT_co]:
            return haliax.scan(do_block, self.Block, remat=self.gradient_checkpointing)(init, self.stacked)

        return do_scan
",src/haliax/nn/scan.py,Stacked,1,1.1861120010657661e-08,"The method 'scan_via' is a utility function that provides a way to perform a scan operation over a stack using a provided function 'fn'. This is a common pattern in functional programming and is useful for operations that need to maintain a state across iterations, such as cumulative sums or other stateful computations. The method is well-documented, indicating its purpose and usage, and it leverages existing functionality from 'haliax.scan', suggesting it is part of a larger framework or library. Given its utility and the fact that it is a wrapper around a presumably stable and useful function ('haliax.scan'), it is likely to be retained in the codebase."
survived,"    def fold_via(self, fn: Callable[..., CarryT]):
        """"""Return a function that folds over the stack using ``fn``.

        ``fn`` should take a block and a carry and return a new carry.  The
        returned function mirrors :func:`haliax.fold` over the block axis.
        """"""

        def do_block(carry: CarryT, block: M) -> CarryT:
            return fn(block, carry)

        def do_fold(init: CarryT) -> CarryT:
            return haliax.fold(do_block, self.Block, remat=self.gradient_checkpointing)(init, self.stacked)

        return do_fold
",src/haliax/nn/scan.py,Stacked,1,8.592166611791576e-10,"The method `fold_via` is a utility function that provides a way to fold over a stack using a provided function `fn`. It is a higher-order function that abstracts the folding process, making it reusable and flexible. Such utility functions are often retained in codebases because they encapsulate common patterns and reduce code duplication. Additionally, the method is well-documented, indicating that it is intended for use and understanding by other developers. There is no indication that this method is obsolete or redundant, so it is likely to be retained."
survived,"def test_llm_openai_path() -> None:
    dist = Path(__file__).resolve().parents[1] / ""dist"" / ""index.html""
    url = dist.as_uri()

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.route(
            ""https://api.openai.com/**"",
            lambda route: route.fulfill(
                status=200,
                content_type=""application/json"",
                body='{""choices"":[{""message"":{""content"":""pong""}}]}',
            ),
        )
        page.goto(url)
        page.evaluate(""localStorage.setItem('OPENAI_API_KEY','sk')"")

        out = page.evaluate(""window.llmChat('hi')"")
        assert out == 'pong'
        browser.close()",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_browser_ui.py,,1,4.363462233903899e-09,"The method 'test_llm_openai_path' is a test function that uses Playwright to simulate a browser environment and test the interaction with a local HTML file and a mocked OpenAI API response. This type of test is crucial for ensuring that the front-end application correctly handles API responses and functions as expected. Given the importance of testing in software development, especially for web applications that rely on external APIs, it is unlikely that this method will be deleted. It serves a clear purpose in validating the application's behavior, which is essential for maintaining software quality."
survived,"def test_llm_offline() -> None:
    dist = Path(__file__).resolve().parents[1] / ""dist"" / ""index.html""
    url = dist.as_uri()

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.goto(url)
        page.wait_for_selector(""#controls"")

        out = page.evaluate(""window.llmChat('hi')"")
        assert out.startswith('[offline]')
        browser.close()
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_browser_ui.py,,1,5.905303995456778e-10,"The method 'test_llm_offline' is a test function that checks the offline functionality of a local language model (LLM) by launching a browser, navigating to a local HTML file, and evaluating a JavaScript function. This type of test is crucial for ensuring that the LLM can operate without an internet connection, which is a common requirement for many applications. Given its importance in verifying offline capabilities, it is likely to be maintained in the codebase."
survived,"def main(argv: list[str] | None = None) -> None:
    args = _parse_args(argv)
    runtime = AgentRuntime(api_key=None)
    agent = GovernanceSimAgent()
    runtime.register(agent)
    if args.enable_adk:
        try:
            from alpha_factory_v1.backend.adk_bridge import auto_register, maybe_launch

            auto_register([agent])
            maybe_launch()
        except Exception as exc:  # pragma: no cover - ADK optional
            logger.warning(f""ADK bridge unavailable: {exc}"")
    logger.info(""Registered GovernanceSimAgent with runtime"")
    runtime.run()
",alpha_factory_v1/demos/solving_agi_governance/openai_agents_bridge.py,,1,9.736200303530205e-10,"The method 'main' is a typical entry point for a Python script, handling argument parsing, initializing runtime, and registering an agent. It includes optional functionality for an ADK bridge, which is handled gracefully with a try-except block. The method is well-structured, with clear responsibilities and logging for important steps. Such methods are generally essential for the operation of a script and are unlikely to be removed unless the entire script is deprecated or significantly refactored. Therefore, it is likely to survive."
survived,"def boom():
    print(""boom"")
    return True
",tests/human/py/bool_chain.py,,1,5.715002851580502e-07,"The method 'boom' is a simple function that prints the word 'boom' and returns True. It doesn't have any complex logic or dependencies, making it unlikely to be deleted unless it's deemed unnecessary or unused in the codebase. Without additional context on its usage, it's reasonable to predict that it will survive as it doesn't pose any issues or require maintenance."
survived,"        async def __aexit__(self, exc_type, exc, tb) -> None:
            return False
",alpha_factory_v1/demos/alpha_agi_business_v1/openai_agents_bridge.py,AsyncClient,1,1.0677030767166749e-06,"The method `__aexit__` is part of the asynchronous context manager protocol in Python. It is expected to return a boolean value indicating whether the exception has been handled (True) or not (False). However, the method is currently returning `False`, which is a valid return value indicating that exceptions are not being suppressed. The method is correctly defined and serves a purpose in the context of an asynchronous context manager, so it is likely to be used as intended in a broader context. Therefore, it is unlikely to be deleted unless the entire context manager is removed or refactored."
survived,"    async def _background_run(sim_id: str, cfg: SimRequest) -> None:
        secs = [sector.Sector(f""s{i:02d}"") for i in range(cfg.pop_size)]
        traj: list[ForecastTrajectoryPoint] = []
        for year in range(1, cfg.horizon + 1):
            t = year / cfg.horizon
            cap = forecast.capability_growth(t, cfg.curve, k=cfg.k, x0=cfg.x0)
            for sec in secs:
                if not sec.disrupted:
                    sec.energy *= 1.0 + sec.growth
                    if forecast.thermodynamic_trigger(sec, cap):
                        sec.disrupted = True
                        sec.energy += forecast._innovation_gain(
                            cfg.pop_size,
                            cfg.generations,
                            mut_rate=cfg.mut_rate,
                            xover_rate=cfg.xover_rate,
                        )
            snapshot = [sector.Sector(s.name, s.energy, s.entropy, s.growth, s.disrupted) for s in secs]
            point = forecast.TrajectoryPoint(year, cap, snapshot)
            traj.append(point)
            for ws in list(_progress_ws):
                try:
                    await ws.send_json({""id"": sim_id, ""year"": year, ""capability"": cap})
                except Exception:
                    _progress_ws.discard(ws)
            await asyncio.sleep(0)

        def eval_fn(genome: list[float]) -> tuple[float, float, float]:
            x, y = genome
            return x**2, y**2, (x + y) ** 2

        scenario = hashlib.sha1(sim_id.encode()).hexdigest()
        orch = getattr(app_f.state, ""orchestrator"", None)
        if orch is not None:
            pop = await orch.evolve(
                scenario,
                eval_fn,
                2,
                population_size=cfg.pop_size,
                generations=cfg.generations,
                experiment_id=sim_id,
            )
        else:
            pop = mats.run_evolution(
                eval_fn,
                2,
                population_size=cfg.pop_size,
                generations=cfg.generations,
                scenario_hash=scenario,
            )

        pop_data = [
            PopulationMember(
                effectiveness=ind.fitness[0],
                risk=ind.fitness[1],
                complexity=ind.fitness[2],
                rank=ind.rank,
            )
            for ind in pop
        ]

        result = ResultsResponse(
            id=sim_id,
            forecast=[ForecastPoint(year=p.year, capability=p.capability) for p in traj],
            population=pop_data,
        )
        _save_result(result)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/interface/api_server.py,,1,2.2159489282323004e-08,"The method '_background_run' is a complex asynchronous function that performs a series of operations including simulation, forecasting, and evolutionary computation. It is likely to be a core part of a larger system, possibly for simulating and analyzing scenarios in a scientific or engineering context. The method is well-structured, uses modern Python features like async/await, and interacts with other components such as websockets and an orchestrator. These characteristics suggest that it is a crucial part of the application's functionality and is unlikely to be removed unless there is a significant change in the application's requirements or architecture."
survived,"    def getParameterById(self, pid: str):
        par = self.importer.sbml.getParameter(pid)
        return par.getValue() if par else np.nan
",tests/testSBMLSuiteJax.py,DummyModel,1,5.211412485172657e-10,"The method 'getParameterById' is likely to survive because it performs a specific and useful function: retrieving a parameter by its ID and returning its value. This is a common operation in data processing and analysis, especially in contexts where parameters are stored in structured formats like SBML (Systems Biology Markup Language). The method is concise, uses clear logic, and handles the case where the parameter is not found by returning 'np.nan', which is a standard practice for indicating missing values in numerical computations. These factors suggest that the method is well-designed for its purpose and likely to be retained."
survived,"def sbml_test_dir():
    old_cwd = os.getcwd()
    old_path = copy.copy(sys.path)
    yield
    os.chdir(old_cwd)
    sys.path = old_path
",tests/testSBMLSuiteJax.py,,1,1.522997951276035e-08,"The method `sbml_test_dir` is a context manager that temporarily changes the current working directory and the system path, then restores them after the context is exited. This is a useful utility for testing purposes, where you might want to run tests in a different directory or with a modified system path without permanently altering the environment. Such utilities are common in testing frameworks and are generally useful for ensuring tests do not have side effects on the environment. Therefore, it is likely to be retained in the codebase."
survived,"    def __len__(self):
        return len(self.Items)
",tests/machine/x/python/group_by_multi_join_sort.py,_Group,1,2.3355930333443423e-09,"The method `__len__` is a special method in Python that is used to define the behavior of the `len()` function for instances of a class. This method is essential for any class that represents a collection or container of items, as it allows users to easily determine the number of items in the collection. The implementation provided is straightforward and correctly returns the length of the `Items` attribute, assuming `Items` is a list or similar iterable. Therefore, this method is likely to be retained as it provides necessary functionality for the class."
survived,"    def __len__(self):
        return len(self.Items)
",tests/machine/x/python/group_by_join.py,_Group,1,1.0467401685178159e-08,"The method `__len__` is a special method in Python used to define the behavior of the `len()` function for instances of a class. This method is correctly implemented to return the length of `self.Items`, which suggests that `self.Items` is likely a list or a similar collection. This is a standard and useful implementation for custom classes that manage collections, allowing them to integrate seamlessly with Python's built-in functions. Therefore, this method is likely to be retained as it provides essential functionality for the class."
survived,"    def fake_run(self, code_directory, command, **_):
        called[""args""] = (code_directory, command)
        return 0, ""out"", ""err""
",tests/test_template_governance.py,,1,1.6052280526088547e-09,"The method 'fake_run' is a mock or stub function, typically used in testing scenarios to simulate the behavior of a real function without executing its actual logic. It captures the arguments passed to it and returns a fixed output. Such methods are often retained in codebases for testing purposes, as they help in verifying the behavior of other components that depend on this function. Therefore, it is likely to survive."
survived,"def load_golden_spec_fuzz_set() -> List[str]:
    """"""Return the list of vague specification strings used for tests.""""""
    try:
        data_path = resources.files(""meta_agent"").joinpath(_DEF_PATH)
        text = data_path.read_text(encoding=""utf-8"")
        data = yaml.safe_load(text) or {}
    except FileNotFoundError:
        return []
    specs = data.get(""specs"")
    if isinstance(specs, list):
        return [str(s) for s in specs]
    return []",src/meta_agent/utils/golden_specs.py,,1,4.363462233903899e-09,"The method 'load_golden_spec_fuzz_set' is well-defined and serves a clear purpose: it loads a list of specification strings from a YAML file. It includes error handling for file not found exceptions, ensuring robustness. The method is likely part of a larger system that requires loading configuration or test data, which is a common requirement in software projects. Therefore, it is unlikely to be deleted unless the entire system's architecture changes significantly or the method's functionality is replaced by a more efficient approach."
survived,"    def __init__(self, secret: str, cache_path: str | Path | None = None) -> None:
        self.secret = secret.encode(""utf-8"")
        self.cache_path = Path(cache_path or ""template_signatures.json"")
        if self.cache_path.exists():
            try:
                self.cache: Dict[str, str] = json.loads(self.cache_path.read_text())
            except Exception:
                self.cache = {}
        else:
            self.cache = {}
",src/meta_agent/template_governance.py,TemplateGovernance,1,3.653482080241728e-08,"The method is a constructor (__init__) for a class, which is a fundamental part of object-oriented programming in Python. It initializes the instance of the class with the given parameters and sets up necessary attributes. The method is well-structured, handling both the encoding of the secret and the initialization of a cache from a file if it exists. This functionality is essential for the class to operate correctly, especially if it relies on cached data. Therefore, it is unlikely to be deleted unless the entire class is refactored or removed."
survived,"def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]
    req_txt = repo_root / ""alpha_factory_v1"" / ""demos"" / ""meta_agentic_tree_search_v0"" / ""requirements.txt""
    lock_file = repo_root / ""alpha_factory_v1"" / ""demos"" / ""meta_agentic_tree_search_v0"" / ""requirements.lock""

    with tempfile.TemporaryDirectory() as tmpdir:
        out_path = Path(tmpdir) / ""requirements.lock""
        pip_compile = shutil.which(""pip-compile"")
        if pip_compile:
            cmd = [pip_compile]
        else:
            cmd = [sys.executable, ""-m"", ""piptools"", ""compile""]
        wheelhouse = os.getenv(""WHEELHOUSE"")
        cmd += [""--quiet""]
        if wheelhouse:
            cmd += [""--no-index"", ""--find-links"", wheelhouse]
        cmd += [""--generate-hashes"", str(req_txt), ""-o"", str(out_path)]
        result = subprocess.run(cmd, capture_output=True, text=True)
        sys.stdout.write(result.stdout)
        sys.stderr.write(result.stderr)
        if result.returncode != 0:
            return result.returncode
        if not lock_file.exists() or out_path.read_bytes() != lock_file.read_bytes():
            extra = """"
            if wheelhouse:
                extra = f""--no-index --find-links {wheelhouse} ""
            msg = (
                ""alpha_factory_v1/demos/meta_agentic_tree_search_v0/requirements.lock is outdated. Run 'pip-compile ""
                f""{extra}--quiet --generate-hashes alpha_factory_v1/demos/meta_agentic_tree_search_v0/requirements.txt -o ""
                ""alpha_factory_v1/demos/meta_agentic_tree_search_v0/requirements.lock'\n""
            )
            sys.stderr.write(msg)
            return 1
    return 0
",scripts/verify_mats_requirements_lock.py,,1,7.582560422162384e-10,"The method 'main' is a utility function that automates the process of compiling a requirements file into a lock file using 'pip-compile'. It checks if the lock file is up-to-date and provides instructions if it is not. This functionality is useful for maintaining consistent dependencies in a project, which is a common requirement in software development. The method is well-structured, handles errors, and provides informative messages, making it a valuable part of a build or deployment process. Therefore, it is likely to be retained in the codebase."
survived,"        def Linear(*_, **__): return None
",alpha_factory_v1/demos/aiga_meta_evolution/meta_evolver.py,_DummyNN,0,0.9999957771647318,"The method 'Linear' is defined to accept any number of positional and keyword arguments but does nothing with them and simply returns None. This suggests that the method is either a placeholder or a stub for future implementation. Without any functionality, it doesn't serve a purpose in its current state, making it likely to be deleted unless it is being used as a deliberate no-op in a larger context."
survived,"def register_demo_agents() -> None:
    """"""Register the demo agent with the framework.""""""

    register_agent(
        AgentMetadata(
            name=IncorporatorAgent.NAME,
            cls=IncorporatorAgent,
            version=""1.0.0"",
            capabilities=IncorporatorAgent.CAPABILITIES,
        )
    )
",alpha_factory_v1/demos/alpha_agi_business_v1/alpha_agi_business_v1.py,,1,9.237449576640118e-09,"The method `register_demo_agents` is likely to survive because it serves a specific purpose of registering a demo agent with a framework. This is a common task in software systems that involve agent-based architectures, where agents need to be registered to be recognized and utilized by the system. The method is straightforward, has a clear purpose, and is likely part of a larger system where such functionality is necessary."
survived,"async def run_search(episodes: int = 10, target: int = 5) -> str:
    """"""Execute the search loop and return a summary string.""""""
    run(episodes=episodes, target=target)
    return f""completed {episodes} episodes toward target {target}""
",alpha_factory_v1/demos/meta_agentic_tree_search_v0/openai_agents_bridge.py,,1,1.2501528648238603e-09,"The method 'run_search' is a simple and clear function that executes a search loop and returns a summary string. It is well-defined with default parameters, making it flexible for different use cases. The function is likely to be useful in various contexts where a search operation is needed, and the summary string provides a clear output of the operation's result. There is no indication of redundancy or inefficiency that would warrant its deletion."
survived,"def check_python() -> bool:
    if sys.version_info < MIN_PY or sys.version_info >= MAX_PY:
        banner(
            f""Python {MIN_PY[0]}.{MIN_PY[1]}+ and <{MAX_PY[0]}.{MAX_PY[1]} required"",
            ""RED"",
        )
        return False
    banner(f""Python {sys.version.split()[0]} detected"", ""GREEN"")
    return True
",scripts/setup_wizard.py,,1,5.905303995456778e-10,"The method 'check_python' is likely to survive because it performs a crucial function of checking the Python version compatibility, which is essential for ensuring that the code runs in the correct environment. This kind of version check is common in software that has specific version dependencies, and it provides user feedback through banners, which is a useful feature for debugging and user guidance."
survived,"    def get_agent(name: str) -> DummyAgent:
        assert name == ""dummy""
        return DummyAgent()
",tests/test_agent_manager_consumer.py,,0,0.99999998813888,"The method `get_agent` is highly specific and inflexible as it only works with the name ""dummy"" and returns a `DummyAgent` instance. This limits its utility and adaptability in a broader context where different agent types might be needed. Unless the application is extremely narrow in scope and only ever requires a `DummyAgent`, this method is likely to be refactored or removed in favor of a more flexible solution. Therefore, it is predicted to be deleted."
survived,"    def setUp(self) -> None:
        self._reg_backup = agents.AGENT_REGISTRY.copy()
        agents.AGENT_REGISTRY.clear()
        self._fail_backup = discovery.FAILED_AGENTS.copy()
        discovery.FAILED_AGENTS.clear()
",tests/test_failed_agent_discovery.py,TestFailedAgentDiscovery,1,2.8453347280241004e-08,"The method `setUp` is a common method used in unit testing frameworks like `unittest` in Python. It is typically used to set up the test environment before each test case is run. The code in this method is backing up and clearing some registries, which is a common practice to ensure that each test runs in a clean state without interference from previous tests. This is a standard and necessary practice in testing, so it is unlikely to be deleted unless the testing framework or strategy changes significantly."
survived,"def list_agents(detail: bool = False):
    """"""Return agent registry entries and failed imports when ``detail`` is ``True``.""""""
    entries = _list_agents(detail=detail)
    if not detail:
        return entries
    failed = [{""name"": name, ""status"": ""error"", ""message"": msg} for name, msg in sorted(FAILED_AGENTS.items())]
    return entries + failed
",alpha_factory_v1/backend/agents/__init__.py,,1,1.6918979223288786e-10,"The method `list_agents` is a utility function that provides a way to retrieve agent registry entries, with an option to include details about failed imports. This functionality is useful for debugging and monitoring purposes, especially in systems where agents are dynamically loaded or managed. The method is straightforward, with a clear purpose and implementation, making it unlikely to be removed unless the entire system architecture changes significantly. Therefore, it is likely to survive."
survived,"            def __init__(self, bootstrap_servers: str) -> None:
                events.append(bootstrap_servers)
",tests/test_message_bus.py,TestMessageBus.Prod,1,1.637377179507321e-07,"The method is a constructor for a class, indicated by the name `__init__`. Constructors are essential for initializing new objects and are a fundamental part of class definitions in Python. The presence of a constructor is crucial for setting up initial states or configurations for objects, such as appending a server address to an events list in this case. Therefore, it is unlikely that this method will be deleted as it serves a necessary purpose in object instantiation."
survived,"            async def _send() -> None:
                bus.publish(""b"", env)
                await asyncio.sleep(0)
",tests/test_message_bus.py,TestMessageBus,1,3.3982678079468468e-09,"The method `_send` is an asynchronous function that publishes a message to a bus and then awaits a non-blocking sleep. This pattern is common in asynchronous programming to yield control back to the event loop, allowing other tasks to run. The method is simple and functional, and there is no indication that it is obsolete or redundant. Therefore, it is likely to be retained in the codebase."
survived,"def client() -> TestClient:
    os.environ.setdefault(""API_TOKEN"", ""test-token"")
    os.environ.setdefault(""API_RATE_LIMIT"", ""1000"")
    api = importlib.reload(api_server)
    return TestClient(cast(Any, api.app))
",tests/test_insight_api_server.py,,1,6.348800075736417e-09,"The method 'client' is a utility function that sets up environment variables and returns a TestClient instance for testing purposes. It is a common practice in testing to have such setup functions to ensure that the environment is correctly configured before tests are run. The method is concise, serves a clear purpose, and is likely used in multiple test cases. Therefore, it is unlikely to be deleted as it is essential for testing the API server."
survived,"def document_module(module: ModuleType, file: TextIO) -> None:
    file.write(f""# {module.__name__}\n\n"")
    if module.__doc__:
        file.write(inspect.getdoc(module))
        file.write(""\n\n"")
    for name, obj in inspect.getmembers(module):
        if name.startswith(""_""):
            continue
        if inspect.isfunction(obj) or inspect.isclass(obj):
            file.write(f""## {name}\n\n"")
            doc = inspect.getdoc(obj) or ""No documentation.""
            file.write(doc)
            file.write(""\n\n"")
",scripts/generate_interface_docs.py,,1,3.160881453314576e-10,"The method `document_module` is a utility function that documents a Python module by writing its name, docstring, and the docstrings of its public functions and classes to a file. This is a useful function for generating documentation automatically, which is a common need in software development. The function is well-structured, uses standard library functions like `inspect.getmembers` and `inspect.getdoc`, and handles cases where documentation might be missing. Given its utility and the fact that it doesn't have any apparent issues or redundancies, it is likely to be retained in the codebase."
survived,"def main() -> None:
    for path in PACKAGE.rglob(""*.py""):
        if path.name == ""__init__.py"":
            continue
        module_name = path.with_suffix("""").as_posix().replace(""/"", ""."")
        module = importlib.import_module(module_name)
        out_file = DOCS_DIR / f""{module_name.replace('.', '_')}.md""
        with out_file.open(""w"") as f:
            document_module(module, f)
",scripts/generate_interface_docs.py,,1,2.1724399346070676e-10,"The method is likely to survive because it performs a useful and specific task: it iterates over Python files in a package, imports each module, and documents it by writing to a markdown file. This functionality is valuable for generating documentation automatically, which is a common requirement in software projects. The method is also well-structured, using clear variable names and handling file operations correctly. There is no indication of redundancy or inefficiency that would necessitate its removal."
survived,"def test_get_system_info_returns_info_even_on_exception(system_mock: mock.MagicMock) -> None:
    info = metrics.get_system_info()
    assert isinstance(info, dict)
    assert info == {}
    system_mock.assert_called_once_with()",tests/inference/unit_tests/core/managers/test_metrics.py,,1,1.725782769012759e-08,"The method 'test_get_system_info_returns_info_even_on_exception' is a unit test function that checks the behavior of the 'get_system_info' function from the 'metrics' module. It ensures that even if an exception occurs, the function returns an empty dictionary and that the 'system_mock' is called once. This is a valid and useful test case to ensure robustness and reliability of the 'get_system_info' function, especially in handling exceptions gracefully. Therefore, it is likely to be retained in the codebase."
survived,"def test_show_results_missing(tmp_path) -> None:
    with patch.object(cli.config, ""Settings"") as settings:
        settings.return_value.ledger_path = tmp_path / ""ledger.txt""
        out = CliRunner().invoke(cli.main, [""show-results""])
        assert ""No results"" in out.output
",tests/test_cli.py,,1,1.8189616842444243e-09,"The method is a unit test for a CLI command, which is a common practice in software development to ensure that the command behaves as expected. It uses a temporary path to simulate the environment and checks for a specific output, which is a typical pattern for testing. There is no indication that this method is obsolete or redundant, and it serves a clear purpose in the testing suite."
survived,"    async def step(self) -> None:
        return None
",tests/test_agents.py,DummyHB,0,0.9999998555019682,"The method 'step' is an asynchronous function that returns None. It doesn't perform any operations or computations, making it redundant in its current form. Unless it is a placeholder for future implementation or used to satisfy an interface or abstract class requirement, it is likely to be deleted as it serves no functional purpose."
survived,"    def read(self, *args):
        # Return as byte strings that can be split
        return self.inputs
",scripts/utils/lcb_runner.py,MockBuffer,0,0.9999599363048656,"The method 'read' is a simple implementation that returns 'self.inputs'. However, without context on how 'self.inputs' is defined or used, it's difficult to determine its utility. If 'self.inputs' is a crucial part of the class and 'read' is frequently used to access it, the method might survive. However, if 'self.inputs' can be accessed directly or if 'read' doesn't add any additional functionality or abstraction, it might be considered redundant and thus deleted. Without more context, it's likely to be deleted due to its simplicity and lack of apparent necessity."
survived,"    async def serve(self) -> None:
        """"""Run the scheduler until quotas are exhausted or queue is empty.""""""
        self.start_time = time.time()
        await self.app.serve()
        # wait for running tasks to finish
        if self.running:
            await asyncio.gather(*self.running, return_exceptions=True)
",src/scheduler.py,SelfImprovementScheduler,1,3.160881453314576e-10,"The method 'serve' is an asynchronous function that is responsible for running a scheduler until certain conditions are met (quotas are exhausted or the queue is empty). It starts by recording the start time, then calls another asynchronous method 'serve' on 'self.app', and finally waits for any running tasks to finish using 'asyncio.gather'. This method is likely a crucial part of a larger system that manages task scheduling and execution. Given its role in managing the lifecycle of tasks and ensuring proper execution flow, it is unlikely to be deleted unless there is a significant refactor or redesign of the system. Therefore, it is predicted to survive."
survived,"def _view_tool(ctx: RunContextWrapper | dict, path: str, start: int = 0, end: Optional[int] = None) -> str:
    return view(path, start, end)
",src/self_edit/tools.py,,0,0.9999999677581336,"The method '_view_tool' is a simple wrapper around the 'view' function, adding no additional functionality or logic. It merely passes its arguments directly to 'view'. Such methods are often considered redundant unless they are part of a larger interface or API where consistency in method naming or structure is required. Without additional context indicating its necessity, it is likely to be deleted as it does not add value on its own."
survived,"def _replace_tool(ctx: RunContextWrapper | dict, path: str, pattern: str, repl: str) -> int:
    return replace(path, pattern, repl)
",src/self_edit/tools.py,,0,0.9993736658585413,"The method _replace_tool is a simple wrapper around the replace function, which suggests it might be part of a larger codebase where such utility functions are common. However, the method does not utilize the ctx parameter, which could indicate that it is either incomplete or not fully integrated into the system. If the context parameter is intended to be used for logging, configuration, or other purposes, its absence in the function's logic might lead to the method being refactored or removed. Additionally, the method's name starts with an underscore, suggesting it is intended for internal use, which might limit its exposure to changes. However, without further context on how this method is used or if there are plans to expand its functionality, it is difficult to definitively predict its future. Given these considerations, the method is more likely to be deleted or refactored unless it is part of a stable and unchanging API."
survived,"def test_replace_property(data: str) -> None:
    path = REPO_ROOT / ""tmp_self_edit_prop.txt""
    try:
        path.write_bytes(data.encode())
        count = replace(path, ""a"", ""b"")
        expected, exp_count = re.subn(""a"", ""b"", data, flags=re.MULTILINE)
        assert count == exp_count
        assert path.read_bytes().decode() == expected
    finally:
        if path.exists():
            path.unlink()
",tests/test_self_edit_tools.py,,1,1.1032560311263802e-09,"The method 'test_replace_property' is a test function that verifies the functionality of a 'replace' function. It writes data to a temporary file, performs a replacement operation, and checks if the operation was successful by comparing the result with expected values. The method also ensures cleanup by deleting the temporary file. This is a well-structured test function that serves a clear purpose in validating code behavior, which is essential for maintaining code quality. Therefore, it is likely to be retained in the codebase."
survived,"        def ipfs_handler(route):
            route.fulfill(
                status=200,
                content_type=""application/json"",
                body='{""gen"":0,""pop"":[{""logic"":0,""feasible"":0,""front"":false,""strategy"":""base""}],""rngState"":0}',
            )
",alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/tests/test_pwa_offline.py,,1,1.1032560311263802e-09,"The method 'ipfs_handler' is a simple function that fulfills a route with a static JSON response. It is likely to be a utility function used in a web server or API context to handle specific routes related to IPFS (InterPlanetary File System). The function is straightforward, does not have any apparent issues, and serves a clear purpose. Unless there is a significant change in the requirements or architecture that makes this function obsolete, it is likely to survive."
survived,"    def _get_labeling_params(self) -> Dict:
        from_name, to_name, value = self.label_interface.get_first_tag_occurence(
            'TimeSeriesLabels', 'TimeSeries')
        tag = self.label_interface.get_tag(from_name)
        labels = list(tag.labels)
        ts_tag = self.label_interface.get_tag(to_name)
        time_col = ts_tag.attr.get('timeColumn')
        channels = [ch.attr['column'] for ch in ts_tag.children if ch.tag == 'Channel']
        return {
            'from_name': from_name,
            'to_name': to_name,
            'value': value,
            'labels': labels,
            'time_col': time_col,
            'channels': channels
        }
",label_studio_ml/examples/timeseries_segmenter/model.py,TimeSeriesSegmenter,1,6.023574641292144e-08,"The method '_get_labeling_params' is a utility function that extracts and organizes parameters related to labeling in a time series context. It interacts with a 'label_interface' to retrieve specific tags and their attributes, which are then structured into a dictionary. This method is likely part of a larger system that deals with time series data and labeling, and its functionality is essential for ensuring that the correct parameters are used in subsequent operations. Given its specific and useful role, it is unlikely to be deleted unless there is a significant refactor or change in how labeling is handled in the system."
survived,"    def test_py_bool_parentheses(self) -> None:
        """"""Ensure boolean expressions preserve parentheses during conversion.""""""
        from jaclang.compiler.passes.main import PyastBuildPass
        import jaclang.compiler.unitree as uni
        import ast as py_ast

        py_out_path = os.path.join(self.fixture_abs_path(""./""), ""py_bool_expr.py"")
        with open(py_out_path) as f:
            file_source = f.read()
            output = PyastBuildPass(
                ir_in=uni.PythonModuleAst(
                    py_ast.parse(file_source),
                    orig_src=uni.Source(file_source, py_out_path),
                ),
                prog=JacProgram(),
            ).ir_out.unparse()
        self.assertIn(""(prev_token_index is None)"", output)
        self.assertIn(""(next_token_index is None)"", output)
        self.assertIn(""(tok[ 0 ] > change_end_line)"", output)
        self.assertIn(""(tok[ 0 ] == change_end_line)"", output)
        self.assertIn(""(tok[ 1 ] > change_end_char)"", output)",jac/jaclang/tests/test_language.py,JacLanguageTests,1,2.2159489282323004e-08,"The method `test_py_bool_parentheses` is a unit test that ensures boolean expressions preserve parentheses during conversion. It is a specific test case that checks the output of a particular function or process, which is a common practice in software development to ensure code correctness. Such test methods are typically retained as they are crucial for maintaining code quality and preventing regressions. Therefore, it is unlikely to be deleted."
survived,"def append_json(data, path):
    cur = load_json(path)
    cur.extend(data)
    save_json(cur, path)
",convert_missing.py,,1,3.3982678079468468e-09,"The method 'append_json' is a utility function that reads a JSON file, appends new data to it, and then saves it back. This is a common and useful operation when dealing with JSON data files, especially in applications that require data persistence or logging. The method is straightforward, performs a clear task, and is likely to be used in various contexts where JSON data manipulation is needed. Therefore, it is likely to be retained."
survived,"    def model_dump(self) -> Dict[str, Any]:
        ...
",alpha_factory_v1/utils/config_common.py,_TypedBaseSettings,1,1.0467401685178159e-08,"The method `model_dump` is likely to be Survived (1) because it appears to be a placeholder for a function that will serialize or export the state of a model into a dictionary format. This is a common and useful functionality in many applications, especially in machine learning and data processing, where models need to be saved, transferred, or inspected. The use of `Dict[str, Any]` as a return type suggests that the method is intended to provide a flexible and comprehensive representation of the model's state, which is a valuable feature."
survived,"    def get_template(self, name: str) -> Template:
        text = self.loader.get_source(self, name)
        return Template(text, name, globals=self.globals)",src/jinja2/__init__.py,Environment,1,6.69158608681505e-10,"The method 'get_template' is a straightforward utility function that retrieves a template by name using a loader and then creates a Template object with it. This is a common pattern in template rendering systems, and there is no indication that it is obsolete or redundant. It serves a clear purpose in the context of template management, and unless there is a significant change in the surrounding codebase or architecture that makes this method unnecessary, it is likely to be retained."
survived,"        async def wrapper(*args: Any, **kwargs: Any):
            tries = 0
            while True:
                try:
                    return await func(*args, **kwargs)
                except exceptions:
                    tries += 1
                    if tries >= max_tries:
                        raise
",src/backoff/__init__.py,,1,1.3440409770490404e-08,"The method 'wrapper' is an asynchronous function designed to retry a given function 'func' a specified number of times ('max_tries') if it raises any of the specified 'exceptions'. This is a common pattern for handling transient errors in asynchronous operations, such as network requests or database queries, where temporary failures are expected and retrying can lead to success. The method is useful and aligns with best practices for error handling in asynchronous programming, making it likely to be retained in the codebase."
survived,"    def patch(self, *args, **kwargs):  # noqa: D401
        return patch(*args, **kwargs)
",src/pytest_mock/__init__.py,MockerFixture,1,1.1861120010657661e-08,"The method is a simple wrapper around the `patch` function, which suggests it might be used to simplify or standardize the way `patch` is called within the codebase. This kind of method is often kept for consistency and to avoid repetitive code, especially if `patch` is used frequently with the same arguments. Therefore, it is likely to survive."
survived,"def test_cli_dashboard_with_data(runner, tmp_path):
    db_path = tmp_path / ""tele.db""
    db = TelemetryDB(db_path)
    db.record(5, 0.1, 0.2, 1)
    db.close()
    result = runner.invoke(cli, [""dashboard"", ""--db-path"", str(db_path)])
    assert result.exit_code == 0
    assert ""Telemetry Dashboard:"" in result.output
    assert ""5"" in result.output
    assert ""$0.10"" in result.output",tests/test_cli.py,,1,3.160881453314576e-10,"The method 'test_cli_dashboard_with_data' is a test function that verifies the functionality of a CLI dashboard command. It uses a temporary database to ensure the dashboard displays the correct data. This is a typical and necessary part of software testing to ensure the CLI behaves as expected. There is no indication that this test is redundant or obsolete, and it serves a clear purpose in validating the software's functionality. Therefore, it is likely to be retained."
survived,"def top_tags(request):
    """"""Display recent headlines for the 10 most popular tags.""""""
    tags = (
        Tag.objects.annotate(
            entry_count=models.Count(
                ""entry"", filter=models.Q(entry__is_draft=False), distinct=True
            ),
            blogmark_count=models.Count(
                ""blogmark"", filter=models.Q(blogmark__is_draft=False), distinct=True
            ),
            quotation_count=models.Count(
                ""quotation"", filter=models.Q(quotation__is_draft=False), distinct=True
            ),
            note_count=models.Count(
                ""note"", filter=models.Q(note__is_draft=False), distinct=True
            ),
        )
        .annotate(
            total=models.F(""entry_count"")
            + models.F(""blogmark_count"")
            + models.F(""quotation_count"")
            + models.F(""note_count"")
        )
        .order_by(""-total"")[:10]
    )
    tags_info = [
        {
            ""tag"": tag,
            ""total"": tag.total,
            ""recent_entries"": tag.entry_set.filter(is_draft=False)
            .order_by(""-created"")[:5],
        }
        for tag in tags
    ]
    return render(request, ""top_tags.html"", {""tags_info"": tags_info})
",blog/views.py,,1,4.0586521248284276e-10,"The method 'top_tags' is likely to survive because it provides a useful feature for displaying the most popular tags based on their associated content counts. It uses Django's ORM to efficiently query and aggregate data, which is a common and effective practice in web development. The method is well-structured, with clear logic for counting and ordering tags, and it returns data in a format suitable for rendering in a template. This functionality is valuable for applications that need to highlight trending or popular content, making it a candidate for retention."
survived,"def test_download_invocation(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None:
    calls: list[tuple[str, Path]] = []

    def fake_download(url: str, dest: Path) -> None:
        calls.append((url, dest))
        dest.write_text(""stub"")

    monkeypatch.setattr(dg, ""_download"", fake_download)
    dg.download_openai_gpt2(""117M"", dest=tmp_path)
    assert len(calls) == len(dg._FILE_LIST)
    assert calls[0][0] == dg.model_urls(""117M"")[0]",tests/test_download_openai_gpt2.py,,1,7.582560422162384e-10,"The method 'test_download_invocation' is a unit test function that uses the 'monkeypatch' fixture to replace the '_download' method with a fake implementation for testing purposes. This is a common practice in testing to isolate the function being tested and ensure it behaves as expected without making actual network calls. The function is well-structured, uses assertions to verify behavior, and is likely part of a test suite. Test functions are generally not deleted unless they are redundant or replaced by better tests. Therefore, it is likely to survive."
survived,"def test_no_innerhtml_usage() -> None:
    files = [
        Path('alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/src/ui/EvolutionPanel.ts'),
        Path('alpha_factory_v1/demos/alpha_agi_insight_v1/insight_browser_v1/src/ui/ControlsPanel.ts'),
    ]
    for f in files:
        text = f.read_text()
        assert '.innerHTML' not in text
",tests/test_ui_xss_safety.py,,1,1.522997951276035e-08,"The method `test_no_innerhtml_usage` is a test function that checks if the `.innerHTML` property is used in specific files. This is a common practice to ensure that certain coding standards or security practices are followed, such as avoiding direct manipulation of HTML content to prevent XSS vulnerabilities. Since this is a test function that enforces a coding standard, it is likely to be useful for maintaining code quality and security. Therefore, it is likely to be retained."
survived,"def test_new_metrics_present() -> None:
    client = make_client()
    resp = client.get(""/metrics"")
    assert resp.status_code == 200
    text = resp.text
    assert ""dgm_parents_selected_total"" in text
    assert ""dgm_children_admitted_total"" in text
    assert ""dgm_revives_total"" in text",tests/test_metrics_exposure.py,,1,2.998960815863541e-09,"The method `test_new_metrics_present` is a unit test that checks if certain metrics are present in the response from a GET request to the `/metrics` endpoint. This is a typical test to ensure that the application is correctly exposing the expected metrics, which is crucial for monitoring and observability purposes. Such tests are generally important for maintaining the reliability and correctness of the application, especially in production environments where metrics are used for performance monitoring and alerting. Therefore, this method is likely to be retained as part of the test suite."
survived,"def discover_adk() -> None:
    """"""Pull remote agent wheels via Google ADK if ``$ADK_MESH`` is set.""""""
    if adk is None or not os.getenv(""ADK_MESH""):
        return
    try:
        client = adk.Client()
        for pkg in client.list_remote_packages():
            if pkg.name in AGENT_REGISTRY:
                continue
            wheel_path = client.download_package(pkg.name)
            try:
                sig_path = client.download_package(pkg.name + "".sig"")
            except Exception:
                sig_path = None
            _HOT_DIR.mkdir(parents=True, exist_ok=True)
            dest = _HOT_DIR / wheel_path.name
            dest.write_bytes(wheel_path.read_bytes())
            if sig_path:
                (dest.with_suffix(dest.suffix + "".sig"")).write_bytes(sig_path.read_bytes())
            if not verify_wheel(dest):
                logger.error(""Discarding unverified wheel from ADK: %s"", pkg.name)
                dest.unlink(missing_ok=True)
                if sig_path:
                    dest.with_suffix(dest.suffix + "".sig"").unlink(missing_ok=True)
                continue
            logger.info(""Pulled %s from ADK mesh"", pkg.name)
        discover_hot_dir()
    except Exception:  # noqa: BLE001
        logger.exception(""ADK discovery failed"")",alpha_factory_v1/backend/agents/discovery.py,,1,5.3157849718487075e-08,"The method 'discover_adk' is a utility function that interacts with a remote service (Google ADK) to download and verify packages. It includes error handling, logging, and conditional execution based on environment variables. These characteristics suggest it is a well-structured and useful function for its intended purpose. It is unlikely to be deleted unless the entire feature it supports is deprecated or replaced by a different mechanism."
survived,"def _inspect_module(mod: ModuleType) -> Optional[AgentMetadata]:
    """"""Return metadata for an agent implementation.""""""
    AgentBase = _agent_base()
    for _, obj in inspect.getmembers(mod, inspect.isclass):
        if issubclass(obj, AgentBase) and obj is not AgentBase:
            return AgentMetadata(
                name=getattr(obj, ""NAME"", obj.__name__),
                cls=obj,
                version=getattr(obj, ""__version__"", ""0.1.0""),
                capabilities=list(getattr(obj, ""CAPABILITIES"", [])),
                compliance_tags=list(getattr(obj, ""COMPLIANCE_TAGS"", [])),
                requires_api_key=getattr(obj, ""REQUIRES_API_KEY"", False),
            )
    return None
",alpha_factory_v1/backend/agents/discovery.py,,1,2.646573631904765e-09,"The method `_inspect_module` is designed to inspect a module for classes that are subclasses of a base agent class and return metadata about them. This functionality is useful for dynamically discovering and working with agent implementations, which is a common requirement in plugin or modular systems. The method is well-defined, has a clear purpose, and is likely to be used in systems that need to handle multiple agent types dynamically. Therefore, it is likely to be retained in the codebase."
survived,"    def load_env(seed: int):
        cfg = tmp_path / ""config.yaml""
        cfg.write_text(f""general:\n  seed: {seed}\n"")
        monkeypatch.chdir(tmp_path)
        monkeypatch.setenv(""NO_LLM"", ""1"")
        monkeypatch.setenv(""ALPHA_ASI_SILENT"", ""1"")
        monkeypatch.setenv(""ALPHA_ASI_MAX_STEPS"", ""1"")
        if module in sys.modules:
            del sys.modules[module]
        mod = importlib.import_module(module)
        env = mod.Orchestrator().envs[0]
        return env.size, sorted(env.obstacles)
",tests/test_world_model_config.py,,1,5.905303995456778e-10,"The method 'load_env' is likely to survive because it performs a specific and useful function: setting up an environment with a given seed, configuring environment variables, and reloading a module to ensure the environment is correctly initialized. This functionality is essential for testing or running simulations where consistent and repeatable environments are necessary. Additionally, the method is well-structured and uses standard practices like setting environment variables and re-importing modules, which are common in scenarios requiring controlled environments."
survived,"            def _forward(batch):
                tokens = tokenizer(
                    batch[""text""],
                    truncation=True,
                    padding=True,
                    max_length=cfg.max_length,
                    return_tensors=""pt"",
                )
                tokens = {k: v.to(device) for k, v in tokens.items()}
                with torch.no_grad():
                    outputs = model(**tokens)
                xm.mark_step()
                batch[""logits""] = outputs.logits.cpu().tolist()
                return batch
",marin/generation/logits.py,,1,2.8453347280241004e-08,"The method '_forward' is a utility function that processes a batch of text data by tokenizing it, moving it to the appropriate device, and passing it through a model to obtain logits. This is a common pattern in machine learning workflows, especially in natural language processing tasks. The method is efficient as it uses 'torch.no_grad()' to prevent gradient calculations, which is suitable for inference. Additionally, it uses 'xm.mark_step()' which suggests it's optimized for use with XLA devices, like TPUs. Given its utility and efficiency, it's likely to be retained in the codebase."
survived,"def delta_sector_to_dcf(sector_state: Dict[str, float]) -> Dict[str, Any]:
    """"""Convert ``sector_state`` deltas into a discounted cash flow representation.

    The input dictionary should contain the following keys:

    - ``delta_revenue``: annual revenue delta (absolute value).
    - ``margin``: operating margin as a decimal.
    - ``discount_rate``: discount rate as a decimal.
    - ``years``: number of forecast years.

    Returns a dictionary with calculated ``cash_flows`` and ``npv``.
    """"""

    delta_revenue = float(sector_state.get(""delta_revenue"", 0.0))
    margin = float(sector_state.get(""margin"", 0.0))
    discount_rate = float(sector_state.get(""discount_rate"", 0.1))
    years = int(sector_state.get(""years"", 1))

    cash_flow = delta_revenue * margin
    cash_flows = [cash_flow for _ in range(years)]
    npv = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))
    return {""cash_flows"": cash_flows, ""npv"": npv}
",src/finance/adapter.py,,1,1.8189616842444243e-09,"The method `delta_sector_to_dcf` is a well-defined function that performs a specific financial calculation, converting sector state deltas into a discounted cash flow representation. It is useful for financial analysis, particularly in evaluating the future cash flows and net present value (NPV) of a sector based on given parameters. The function is clear, concise, and provides a valuable utility for financial modeling. Given its utility and clarity, it is likely to be retained in the codebase."
survived,"    def test_tree_has_single_path_false(self):
        """"""Tree branching results in ``False``.""""""
        tree = FPTree([[1, 2], [1, 3]], 1, None, None)
        self.assertFalse(tree.tree_has_single_path(tree.root))
",tests/test_pyfpgrowth.py,FPTreeTests,1,2.3355930333443423e-09,"The method `test_tree_has_single_path_false` is a unit test that checks if the `tree_has_single_path` method of the `FPTree` class correctly identifies that a tree with branching does not have a single path. This is a valid and useful test case for ensuring the correctness of the `tree_has_single_path` method. Unit tests are generally not deleted unless they are redundant or incorrect, and this test appears to be neither. Therefore, it is likely to be retained."
survived,"    def test_zip_patterns(self):
        """"""zip_patterns appends the suffix when present.""""""
        tree = FPTree([], 1, 'b', 1)
        zipped = tree.zip_patterns({('a',): 2})
        self.assertEqual(zipped, {('a', 'b'): 2})
",tests/test_pyfpgrowth.py,FPTreeTests,1,6.348800075736417e-09,"The method `test_zip_patterns` is a unit test for the `zip_patterns` function of the `FPTree` class. Unit tests are crucial for ensuring that code behaves as expected and for catching regressions when code changes. This test checks that the `zip_patterns` method correctly appends a suffix to a pattern, which is a specific functionality that needs verification. Since unit tests are an integral part of software development and maintenance, this method is likely to be retained to ensure the reliability of the `zip_patterns` function."
survived,"        def make_class_embeddings_dict(self, *args, **kwargs):
            return {}
",tests/inference/models_predictions_tests/test_owlv2.py,DummyOwl,0,0.999999694097641,"The method `make_class_embeddings_dict` is defined to return an empty dictionary, which suggests that it is either a placeholder or not yet implemented. If this method is part of a larger codebase where it is expected to perform a specific function, such as generating embeddings for classes, its current implementation does not fulfill that purpose. Without additional context or usage, it is likely to be considered redundant or incomplete, leading to its deletion in future iterations unless it is updated to perform its intended function."
survived,"def _lead_time(truth: Iterable[bool], pred: Iterable[bool]) -> int:
    truth_list = list(truth)
    pred_list = list(pred)

    def first_true(seq: list[bool]) -> int:
        for i, val in enumerate(seq):
            if val:
                return i
        return len(seq)

    return first_true(pred_list) - first_true(truth_list)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/evaluate_econ.py,,1,1.8189616842444243e-09,"The method `_lead_time` is a utility function that calculates the lead time between two sequences of boolean values. It determines the index of the first `True` value in each sequence and returns the difference between these indices. This function is useful in scenarios where you need to measure the delay or lead time between two events represented by boolean sequences. The method is well-defined, has a clear purpose, and is likely to be used in various contexts where such a calculation is needed. Therefore, it is likely to survive."
survived,"    def __enter__(self) -> ""ArchiveService"":
        return self
",src/archive/service.py,ArchiveService,1,4.1399375473943306e-08,"The method is a standard implementation of the __enter__ method for a context manager in Python. It returns the instance of the class, which is a common pattern for context managers. This method is likely to be used in conjunction with the __exit__ method to manage resources efficiently. Since it follows a well-established pattern and serves a clear purpose, it is unlikely to be deleted."
survived,"    async def _loop(self, interval: int) -> None:
        while True:
            await asyncio.sleep(interval)
            await self.broadcast_merkle_root()
",src/archive/service.py,ArchiveService,1,1.3440409770490404e-08,"The method _loop is an asynchronous function that runs an infinite loop, sleeping for a specified interval and then calling another asynchronous method, broadcast_merkle_root. This pattern is common in applications that require periodic tasks, such as updating a state or broadcasting information at regular intervals. The method is likely part of a larger system that relies on this periodic execution, making it essential for the system's functionality. Therefore, it is unlikely to be deleted unless the system's architecture changes significantly or the functionality is no longer needed."
survived,"def create_app(service: DualCriticService) -> ""FastAPI"":
    return service.create_app()",src/critics/dual_critic_service.py,,0,0.999998629043345,"The method 'create_app' is a simple wrapper around the 'create_app' method of the 'DualCriticService' class. It doesn't add any additional functionality or logic, making it redundant. If the 'create_app' method of 'DualCriticService' is directly accessible and there is no need for this wrapper, it is likely to be deleted to simplify the code."
survived,"def test_grpc_scoring() -> None:
    service = DualCriticService([""Rome is the capital of Italy.""])
    port = _free_port()

    async def run() -> None:
        await service.start_grpc(port)
        async with grpc.aio.insecure_channel(f""localhost:{port}"") as ch:
            stub = ch.unary_unary(""/critics.Critic/Score"")
            payload = {
                ""context"": ""Rome is the capital of Italy."",
                ""response"": ""Rome is the capital of Italy."",
            }
            reply = await stub(json.dumps(payload).encode())
            data = json.loads(reply.decode())
            assert data[""logic""] == 1.0
        await service.stop_grpc()

    asyncio.run(run())
",tests/test_critics.py,,1,1.0467401685178159e-08,"The method `test_grpc_scoring` is a unit test for a gRPC service, which is a common practice in software development to ensure that the service behaves as expected. The test checks if the service correctly scores a response with a logic score of 1.0 when the context and response are identical. This kind of test is crucial for maintaining the reliability and correctness of the service, especially in production environments. Therefore, it is unlikely to be deleted as it serves an important role in the development and maintenance process."
survived,"    def feasibility_score(self, response: str) -> Tuple[float, List[str]]:
        """"""Score feasibility via similarity search.""""""
        hits = self.db.search(response)
        score = hits[0][1] if hits else 0.0
        citations = [h[0] for h in hits]
        return score, citations
",src/critics/dual_critic_service.py,DualCriticService,1,2.7894680920908113e-10,"The method 'feasibility_score' is likely to survive because it provides a clear and useful functionality: scoring feasibility through a similarity search. This is a common requirement in applications involving database searches or information retrieval. The method is concise, well-documented, and returns both a score and a list of citations, which are valuable outputs for further processing or analysis. Additionally, the use of type hints improves code readability and maintainability."
survived,"def weekly_report(csv_path: str | Path = ""replay_metrics.csv"") -> str:
    """"""Generate a plain-text weekly report and return it.""""""
    rows = load_metrics(csv_path)
    stats = aggregate_stats(rows)
    anomalies = detect_anomalies(rows)
    lines = [""Weekly Meta Foresight Report""]
    for m in _METRICS:
        mean = stats.get(f""{m}_mean"", float(""nan""))
        st = stats.get(f""{m}_stdev"", float(""nan""))
        lines.append(f""{m}: mean={mean:.3f} stdev={st:.3f}"")
    lines.append(f""anomalies_detected={len(anomalies)}"")
    return ""\n"".join(lines)
",src/analysis/meta_foresight.py,,1,8.592166611791576e-10,"The method 'weekly_report' is likely to survive because it provides a useful functionality of generating a weekly report from a CSV file. It aggregates statistics and detects anomalies, which are common requirements in data analysis and reporting tasks. The method is well-structured, uses type hints, and has a clear purpose, making it a valuable part of a codebase that deals with data metrics."
survived,"        def do_POST(self):
            length = int(self.headers.get(""Content-Length"", 0))
            type(self).received_body = self.rfile.read(length)
            type(self).received_headers = dict(self.headers)
            self.send_response(status)
            self.end_headers()
            self.wfile.write(type(self).received_body)
",alpha_factory_v1/tests/test_requests_shim.py,Handler,1,1.637377179507321e-07,"The method 'do_POST' is a standard implementation for handling POST requests in a server context, typically within a class derived from BaseHTTPRequestHandler in Python's http.server module. It reads the content length from the headers, reads the body of the request, stores the headers and body in class-level attributes, sends a response, and writes the body back to the client. This is a basic and functional implementation for handling POST requests, which is a common requirement in web servers. Therefore, it is likely to be retained as it serves a fundamental purpose in handling HTTP POST requests."
survived,"def start_server(status=200, body=b""ok""):
    class Handler(BaseHTTPRequestHandler):
        received_body = None
        received_headers = None

        def do_GET(self):
            type(self).received_headers = dict(self.headers)
            self.send_response(status)
            self.end_headers()
            self.wfile.write(body)

        def do_POST(self):
            length = int(self.headers.get(""Content-Length"", 0))
            type(self).received_body = self.rfile.read(length)
            type(self).received_headers = dict(self.headers)
            self.send_response(status)
            self.end_headers()
            self.wfile.write(type(self).received_body)

    server = HTTPServer((""localhost"", 0), Handler)
    t = threading.Thread(target=server.serve_forever, daemon=True)
    t.start()
    url = f""http://{server.server_address[0]}:{server.server_address[1]}""
    return server, t, Handler, url
",alpha_factory_v1/tests/test_requests_shim.py,,1,7.582560422162384e-10,"The method 'start_server' is a utility function that sets up a simple HTTP server for testing purposes. It is useful for unit tests or local development where a quick and easy HTTP server is needed to test HTTP requests and responses. The method is self-contained, does not rely on external dependencies beyond the standard library, and provides a clear and useful functionality. Therefore, it is likely to be retained in the codebase as it serves a practical purpose."
survived,"    def test_register_invalid_class(self):
        """"""Decorator should reject non-AgentBase subclasses.""""""
        with self.assertRaises(TypeError):
            @register
            class Bad:
                NAME = ""bad""
",alpha_factory_v1/tests/test_register_decorator.py,RegisterDecoratorTest,1,3.850741907939403e-09,"The method 'test_register_invalid_class' is a unit test designed to ensure that the 'register' decorator correctly raises a TypeError when applied to a class that does not subclass 'AgentBase'. This is a valid and useful test case for verifying the robustness of the 'register' decorator, ensuring it enforces the expected class hierarchy. Such tests are crucial for maintaining code quality and preventing future regressions. Therefore, this method is likely to be retained in the codebase."
survived,"        def __init__(self) -> None:
            self.nodes: dict = {}
            self.edges: dict = {}
",alpha_factory_v1/backend/agents/supply_chain_agent.py,_FakeGraph,1,1.1861120010657661e-08,"The method is a constructor for a class, initializing two dictionaries, 'nodes' and 'edges'. This is a common pattern in object-oriented programming to set up initial state for an object. There is no indication that this method is redundant or unnecessary, as it is essential for the proper instantiation of objects of this class. Therefore, it is likely to be retained."
survived,"def get_version() -> str:
    """"""Return the Alpha‚ÄëFactory package version.""""""

    return __version__
",alpha_factory_v1/__init__.py,,1,2.998960815863541e-09,"The method `get_version` is a simple utility function that returns the version of the package. Such functions are common in software projects to provide easy access to version information, which can be useful for debugging, logging, or display purposes. Since it serves a clear purpose and is a standard practice, it is likely to be retained in the codebase."
survived,"        def stop(self) -> None:  # pragma: no cover - unused
            pass
",tests/test_alpha_agi_business_3_v1.py,DummySock,0,0.9999999530883621,"The method 'stop' is currently not implemented and is marked with a pragma comment indicating it is unused. This suggests that the method is not currently needed or utilized in the codebase. Without any implementation or usage, it is likely to be considered dead code. Unless there is a future plan to implement this method, it is likely to be deleted to clean up the codebase."
survived,"            def __init__(self, url: str) -> None:
                captured[""url""] = url
",tests/test_insight_orchestrator_features.py,TestLedger.DummyClient,1,3.653482080241728e-08,"The method is a constructor for a class, indicated by the name `__init__`, which is a special method in Python used to initialize new objects. The method takes a URL as a parameter and assigns it to a dictionary called `captured`. This suggests that the method is part of a class that is designed to capture or store URLs, possibly for further processing or tracking. Since constructors are essential for creating instances of classes, it is unlikely that this method will be deleted unless the entire class is refactored or removed. Therefore, the method will likely survive."
survived,"def free_energy(sector: Sector, capability: float) -> float:
    return sector.energy - capability * sector.entropy
",alpha_factory_v1/core/simulation/forecast.py,,1,2.646573631904765e-09,"The method 'free_energy' is a simple and straightforward calculation that is likely to be useful in contexts where energy and entropy are relevant, such as in physics or thermodynamics. It takes a 'Sector' object and a 'capability' float as inputs and returns a float representing the free energy. The method is clear, concise, and performs a basic mathematical operation that is unlikely to become obsolete. Therefore, it is likely to be retained in the codebase."
survived,"def _evolve_step(
    pop: Population,
    fn: Callable[[List[float]], Tuple[float, ...]],
    *,
    rng: random.Random,
    mutation_rate: float,
    crossover_rate: float,
    novelty: NoveltyIndex | None = None,
    critics: Iterable[Callable[[List[float]], float]] | None = None,
) -> Population:
    """"""Return the next generation from ``pop`` using NSGA‚ÄëII.""""""

    evaluate(pop, fn, novelty, critics)
    mu = len(pop)
    genome_length = len(pop[0].genome)
    offspring: Population = []
    while len(offspring) < mu:
        a, b = rng.sample(pop, 2)
        if genome_length > 1 and rng.random() < crossover_rate:
            cut = rng.randint(1, genome_length - 1)
            child_genome = a.genome[:cut] + b.genome[cut:]
        else:
            child_genome = list(a.genome)
        if rng.random() < mutation_rate:
            idx = rng.randrange(genome_length)
            child_genome[idx] += rng.uniform(-1, 1)
        offspring.append(Individual(child_genome))
    evaluate(offspring, fn, novelty, critics)
    union = pop + offspring
    fronts = _non_dominated_sort(union)
    new_pop: Population = []
    for front in fronts:
        _crowding(front)
        front.sort(key=lambda x: (-x.rank, -x.crowd))
        for ind in front:
            if len(new_pop) < mu:
                new_pop.append(ind)
    return new_pop
",alpha_factory_v1/core/simulation/mats.py,,1,9.931195248674785e-08,"The method `_evolve_step` is a core function for implementing the NSGA-II algorithm, which is a well-known and widely used multi-objective optimization algorithm. The function is responsible for evolving a population of solutions by applying genetic operations such as crossover and mutation, evaluating the population, and selecting the next generation based on non-dominated sorting and crowding distance. These operations are fundamental to the functioning of the NSGA-II algorithm, which is a staple in evolutionary computation research and applications. Given its importance in the context of evolutionary algorithms, it is unlikely that this method will be deleted unless there is a significant shift in the approach to solving multi-objective optimization problems or a major refactor of the codebase that replaces this functionality with a more efficient or modern approach."
survived,"def send_alert(message: str, url: str | None = None) -> None:
    """"""Post *message* to ``url`` or ``ALERT_WEBHOOK_URL`` if set.""""""

    hook = url or os.getenv(""ALERT_WEBHOOK_URL"")
    if not hook:
        return

    payload = {""content"": message}
    if ""slack.com"" in hook:
        payload = {""text"": message}

    try:
        resp = requests.post(hook, json=payload, timeout=5)
        if not 200 <= resp.status_code <= 299:
            _log.warning(""alert failed with status %s"", resp.status_code)
    except Exception as exc:  # pragma: no cover - network errors
        _log.warning(""alert failed: %s"", exc)",alpha_factory_v1/core/utils/alerts.py,,1,1.6052280526088547e-09,"The method `send_alert` is likely to survive because it provides a useful functionality of sending alerts to a specified URL or a default webhook URL. It handles different payload formats based on the URL, manages exceptions, and logs warnings for failures, making it robust and versatile for alerting purposes. Additionally, it uses environment variables, which is a common practice for configuration, enhancing its adaptability in different environments."
survived,"def logistic_curve(t: float, k: float = 1.0, x0: float = 0.0) -> float:
    """"""Return a logistic curve value for ``t``.

    Args:
        t: Normalised time value.
        k: Growth rate controlling the steepness.
        x0: Midpoint shift.

    Returns:
        Value in the ``[0, 1]`` range.
    """"""

    return 1.0 / (1.0 + math.exp(-k * (t - x0)))
",alpha_factory_v1/core/simulation/forecast.py,,1,2.3355930333443423e-09,"The method implements a logistic curve function, which is a fundamental mathematical function used in various fields such as statistics, machine learning, and biology. It is well-documented, with clear parameters and a concise description of its purpose and return value. The function is useful for modeling growth processes and is likely to be used in various applications. Therefore, it is unlikely to be deleted."
survived,"    def _record_restart(self, runner: AgentRunner) -> None:
        super()._record_restart(runner)
        alerts.send_alert(
            f""{runner.agent.name} restarted"",
            self.settings.alert_webhook_url,
        )
",alpha_factory_v1/core/orchestrator.py,Orchestrator,1,2.8453347280241004e-08,"The method `_record_restart` is a specialized function that extends the functionality of a superclass method by adding an alert feature. This method is likely to be important for monitoring and logging purposes, especially in systems where agent restarts need to be tracked and alerts need to be sent. The use of alerts suggests that this method plays a critical role in system operations, making it unlikely to be deleted."
survived,"    def slash(self, agent_id: str) -> None:
        self.registry.burn(agent_id, 0.1)
",alpha_factory_v1/backend/demo_orchestrator.py,DemoOrchestrator,1,2.2159489282323004e-08,"The method 'slash' is a simple function that calls another method 'burn' on an object 'registry'. It seems to be part of a larger system, possibly related to penalizing or reducing some value associated with 'agent_id'. Without more context, it's difficult to determine its full utility, but the method itself is straightforward and does not contain any obvious issues or redundancies. Therefore, it is likely to be retained as it serves a specific purpose in the system."
survived,"    async def evolve(
        self,
        scenario_hash: str,
        fn: Callable[[list[float]], tuple[float, ...]],
        genome_length: int,
        *,
        sector: str = ""generic"",
        approach: str = ""ga"",
        experiment_id: str = ""default"",
        **kwargs: object,
    ) -> object:
        pops = self.experiment_pops.setdefault(experiment_id, {})
        pop = await asyncio.to_thread(
            fn,
            [0.0] * genome_length,
            scenario_hash=scenario_hash,
            populations=pops,
            **kwargs,
        )
        pops[scenario_hash] = pop
        for ind in pop:
            self.solution_archive.add(sector, approach, ind.score, {""genome"": ind.genome})
            self.archive.insert_entry({""experiment_id"": experiment_id, ""genome"": ind.genome}, {""score"": ind.score})
        return pop
",alpha_factory_v1/backend/demo_orchestrator.py,DemoOrchestrator,1,3.3982678079468468e-09,"The method 'evolve' is likely to survive because it is an asynchronous function that appears to be part of a larger system for evolutionary computation or genetic algorithms. It is designed to handle complex tasks such as evolving populations based on a given scenario, which is a common requirement in fields like optimization, machine learning, and artificial intelligence. The method is well-structured, uses modern Python features like async/await, and integrates with other components like 'solution_archive' and 'archive', indicating it is part of a well-thought-out architecture. These factors suggest it is a useful and relevant method that is likely to be retained in the codebase."
survived,"    def _register(self, runner: AgentRunner) -> None:
        env = pb.Envelope(sender=""orch"", recipient=""system"", ts=time.time())
        env.payload.update({""event"": ""register"", ""agent"": runner.agent.name, ""capabilities"": runner.capabilities})
        self.ledger.log(env)
        self.bus.publish(""system"", env)
        self.registry.set_stake(runner.agent.name, 1.0)
        self.registry.set_threshold(f""promote:{runner.agent.name}"", self._promotion_threshold)
",alpha_factory_v1/backend/demo_orchestrator.py,DemoOrchestrator,1,1.6052280526088547e-09,"The method '_register' is likely to survive because it performs essential operations for registering an agent in a system. It logs the registration event, publishes it to a message bus, and updates a registry with the agent's stake and promotion threshold. These actions are crucial for maintaining the system's state and ensuring that agents are properly tracked and managed. Removing this method would likely disrupt the system's functionality."
survived,"    def add_agent(self, agent: object) -> None:
        runner = AgentRunner(agent)
        self.runners[agent.name] = runner
        self._register(runner)
",alpha_factory_v1/backend/demo_orchestrator.py,DemoOrchestrator,1,5.905303995456778e-10,"The method 'add_agent' is likely to survive because it performs a clear and necessary function within the context of managing agents. It creates an 'AgentRunner' for the given agent, stores it in a dictionary using the agent's name as the key, and registers the runner. This functionality is essential for systems that manage multiple agents, suggesting that the method is integral to the class's purpose."
survived,"  def test_len(self):
    self.assertEqual(len(self.tip_car), 5)
",pylabrobot/resources/carrier_tests.py,CarrierTests,1,2.0611536181902033e-09,"The method `test_len` is a unit test that checks if the length of `self.tip_car` is equal to 5. This is a typical use case in test-driven development to ensure that a list or collection has the expected number of elements. Such tests are crucial for maintaining code quality and ensuring that changes in the codebase do not introduce unexpected behavior. Therefore, this method is likely to be retained as part of the test suite."
survived,"def test_no_violation_returns_one() -> None:
    _reset()
    res = {""request_id"": ""r1"", ""violation"": False}
    value = sc.reward(None, None, res)
    assert isinstance(value, float)
    assert value == 1.0
",tests/test_safety_compliance_reward.py,,1,1.1861120010657661e-08,"The method `test_no_violation_returns_one` is a unit test that checks the behavior of the `sc.reward` function when there is no violation. It ensures that the function returns a float value of 1.0, which is likely a desired behavior in the context of the application. Unit tests are crucial for maintaining code quality and ensuring that functions behave as expected. Therefore, this method is likely to be retained as it serves an important role in verifying the correctness of the code."
survived,"    def __init__(self, settings: config.Settings) -> None:
        self.settings = settings
        self.published: list[tuple[str, messaging.Envelope]] = []
",tests/test_safety_guardian_property.py,DummyBus,1,1.522997951276035e-08,"The method is a constructor (__init__) method, which is essential for initializing instances of a class. It sets up the initial state of the object by assigning the 'settings' parameter to an instance variable and initializing an empty list for 'published'. Constructor methods are fundamental to object-oriented programming and are unlikely to be deleted unless the entire class is being removed or refactored significantly."
survived,"def test_blocks_import_os(code: str) -> None:
    assume(""import os"" in code)
    bus = DummyBus(config.Settings(bus_port=0))
    led = DummyLedger()
    agent = safety_agent.SafetyGuardianAgent(bus, led)
    env = messaging.Envelope(""codegen"", ""safety"", {""code"": code}, 0.0)
    asyncio.run(agent.handle(env))
    assert bus.published[-1][1].payload[""status""] == ""blocked""
",tests/test_safety_guardian_property.py,,1,5.3157849718487075e-08,"The method 'test_blocks_import_os' is a test function that checks if a piece of code containing 'import os' is blocked by the SafetyGuardianAgent. This is a valid and useful test to ensure that the safety mechanisms are working as intended, especially in environments where importing certain modules like 'os' could pose security risks. Therefore, it is likely to be retained as part of the test suite to ensure ongoing security compliance."
survived,"def main() -> int:
    proto = Path(""src/utils/a2a.proto"")
    out_dir = proto.parent
    cmd = [
        sys.executable,
        ""-m"",
        ""grpc_tools.protoc"",
        f""-I{out_dir}"",
        f""--python_out={out_dir}"",
        str(proto),
    ]
    if subprocess.run(cmd, check=False).returncode != 0:
        return 1

    dataclass = out_dir / ""a2a_pb2_dataclass.py""
    dataclass.write_text(
        """"""# SPDX-License-Identifier: Apache-2.0\n""""""
        ""\n""""\""Dataclass version of ``a2a.proto`` messages.\""\n""""""
        ""from __future__ import annotations\n""
        ""\n""
        ""from dataclasses import dataclass, field, asdict\n""
        ""from typing import Any, Dict\n""
        ""\n\n""
        ""@dataclass(slots=True)\n""
        ""class Envelope:\n""
        ""    \""\""\""Lightweight envelope for bus messages.\""\""\""\n""
        ""\n""
        ""    sender: str = \""\""\n""
        ""    recipient: str = \""\""\n""
        ""    payload: Dict[str, Any] = field(default_factory=dict)\n""
        ""    ts: float = 0.0\n""
        ""\n""
        ""    def to_dict(self) -> Dict[str, Any]:\n""
        ""        \""\""\""Return a dictionary representation.\""\""\""\n""
        ""        return asdict(self)\n""
    )
    return 0
",scripts/gen_proto.py,,1,3.850741907939403e-09,"The method 'main' is a utility function that compiles a Protocol Buffers file using the gRPC tools and generates a Python dataclass file. This is a common task in projects that use gRPC for communication, as it automates the generation of necessary code from .proto files. The method is well-structured, uses subprocess to run the command, and handles errors by returning a non-zero exit code if the command fails. Additionally, it writes a dataclass to a file, which is a useful feature for developers working with the generated code. Given its utility and the fact that it performs a necessary task in the build process, it is likely to be retained in the codebase."
survived,"def add(a: int, b: int) -> int:
    """"""Return the sum of a and b, intentionally broken.""""""
    return a - b",alpha_factory_v1/demos/self_healing_repo/sample_broken_calc/calc.py,,0,0.999876605372333,"The method is intended to add two numbers but is incorrectly implemented to subtract them instead. This is a fundamental error that contradicts the method's purpose and description. Such a mistake is likely to be corrected or the method will be deleted if it is not used or needed, as it does not fulfill its intended function."
survived,"    def _apply(self, model: Any, smash_config: SmashConfigPrefixWrapper) -> Any:
        """"""Apply AWQ quantization using ``llmcompressor``.""""""
        imported = self.import_algorithm_packages()

        recipe = [
            imported[""AWQModifier""](
                ignore=[""lm_head""],
                scheme=smash_config[""scheme""],
                targets=[""Linear""],
            )
        ]

        dataloader = smash_config.val_dataloader()
        tokenizer = smash_config.tokenizer
        calib_data = recover_text_from_dataloader(dataloader, tokenizer)

        imported[""oneshot""](model=model, recipe=recipe, calib_data=calib_data)
        return model
",src/pruna/algorithms/quantization/llm_compressor.py,LLMCompressorQuantizer,1,1.1032560311263802e-09,"The method '_apply' is a specialized function that applies a specific quantization technique (AWQ) to a model using a configuration wrapper. It is likely part of a larger framework or library for model compression or optimization. Such methods are typically retained as they provide essential functionality for users who need to apply quantization to their models. The method is well-defined, uses external packages, and follows a clear process, indicating it is a useful and necessary part of the codebase."
survived,"    def get_hyperparameters(self) -> list:
        """"""Return the hyperparameters used for quantization.""""""
        return [Constant(""scheme"", value=""W4A16_ASYM"")]
",src/pruna/algorithms/quantization/llm_compressor.py,LLMCompressorQuantizer,1,2.646573631904765e-09,"The method `get_hyperparameters` is a simple accessor method that returns a list containing a constant hyperparameter configuration. It is likely to be retained because it encapsulates the retrieval of hyperparameters in a clear and concise manner, which is useful for maintaining code modularity and readability. Unless there is a significant change in how hyperparameters are managed or retrieved, such methods are generally kept in the codebase."
survived,"def main() -> None:  # pragma: no cover - entry point
    """"""Launch the minimal dashboard or print results.""""""
    if st is None:
        print(""Streamlit not installed"")
        traj = _simulate(5, ""logistic"", 6, 3)
        for record in _disruption_df(traj).to_dict(orient=""records""):
            print(f""{record['sector']}: year {record['year']}"")
        return

    st.title(""Disruption Forecast"")
    horizon = st.sidebar.slider(""Horizon"", 1, 20, 5)
    curve = st.sidebar.selectbox(""Curve"", [""logistic"", ""linear"", ""exponential""], index=0)
    pop_size = st.sidebar.slider(""Population size"", 2, 20, 6)
    generations = st.sidebar.slider(""Generations"", 1, 20, 3)

    if st.sidebar.button(""Run""):
        traj = _simulate(horizon, curve, pop_size, generations)
        df = _timeline_df(traj)
        pivot = df.pivot(index=""year"", columns=""sector"", values=""energy"")
        st.line_chart(pivot)
        st.table(_disruption_df(traj))
",src/interface/minimal_ui.py,,1,9.237449576640118e-09,"The method is a main entry point for a Streamlit application, which is a popular framework for creating web applications for data science and machine learning. The method includes functionality to either run a Streamlit dashboard or print results to the console if Streamlit is not installed. This dual functionality makes it versatile and useful for both interactive and non-interactive environments. Additionally, the use of Streamlit suggests that the method is part of a modern, user-friendly application, which is likely to be maintained and used. Therefore, it is likely to survive."
survived,"def test_config_fields_present():
    for path in config_paths():
        cfg = load(path)
        assert 'contracts' in cfg and cfg['contracts'], f""{path} missing contracts""
        assert 'github_repo' in cfg
        assert REQUIRED_GITHUB_KEYS <= set(cfg['github_repo']), f""{path} github_repo keys""
        assert 'dependencies' in cfg
        assert 'explorer_hostname' in cfg or 'explorer_hostname_env_var' in cfg
",tests/test_configs.py,,1,9.237449576640118e-09,"The method `test_config_fields_present` is a test function that checks the presence of certain fields in configuration files. It is likely to survive because it serves a critical role in ensuring that configuration files are correctly set up, which is essential for the proper functioning of the application. Test functions like this are important for maintaining code quality and preventing runtime errors due to missing configuration data."
survived,"def test_path_to_file_without_dependency():
    result = path_to_file_without_dependency('@oz/contracts/token.sol', '@oz/contracts')
    assert result == 'token.sol'
",tests/test_github_utils.py,,1,1.1253518384332553e-07,"The method `test_path_to_file_without_dependency` is a unit test for the function `path_to_file_without_dependency`. Unit tests are crucial for ensuring code reliability and correctness, especially in software development practices like Test-Driven Development (TDD). This test checks if the function correctly strips the dependency path from a file path, which is a common operation in file handling and dependency management. Since unit tests are essential for maintaining code quality and are often kept as part of the codebase to ensure ongoing functionality, it is likely that this method will be retained."
survived,"def test_format_str_call(state: State):
    s_in = """"""'{}'.format(str(var))""""""
    s_expected = """"""f'{var!s}'""""""

    s_out, count = code_editor.fstringify_code_by_line(s_in, state)
    assert s_out == s_expected
",test/test_edits.py,,1,1.8189616842444243e-09,"The method `test_format_str_call` is a unit test designed to verify the functionality of the `fstringify_code_by_line` method from the `code_editor` module. It checks if the method correctly converts a string formatted using the `format` method to an f-string format. This is a common refactoring task in Python to make code more readable and efficient. Since this is a test function, it is likely to be retained as long as the functionality it tests is relevant and the `code_editor` module is in use. Therefore, the method will survive."
survived,"    async def step(self) -> None:  # noqa: D401
        """"""Delegate step execution to :meth:`run_cycle`.""""""
        await self.run_cycle()
",alpha_factory_v1/backend/agents/retail_demand_agent.py,RetailDemandAgent,1,4.944450477491054e-09,"The method 'step' is a simple asynchronous function that delegates its execution to another method 'run_cycle'. It is likely part of a larger class or module where such delegation is necessary for organizing code execution flow. The use of 'async' suggests it is designed to work with asynchronous operations, which are increasingly common in modern programming to handle I/O-bound tasks efficiently. Without additional context indicating redundancy or a shift in design patterns, there is no clear reason to delete this method. It seems to serve a purpose in the code's architecture."
survived,"    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self._subs: Dict[str, List[Callable[[Envelope], Awaitable[None] | None]]] = {}
        self._server: ""grpc.aio.Server | None"" = None
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/utils/messaging.py,A2ABus,1,5.3157849718487075e-08,"The method is a constructor (__init__) for a class, which is essential for initializing instances of the class. Constructors are fundamental components of class definitions in object-oriented programming, and they are rarely deleted unless the class itself is being removed or significantly refactored. Since the method is responsible for setting up important attributes like 'settings', '_subs', and '_server', it is likely to be retained to ensure the class functions correctly."
survived,"    def __init__(self, bus, ledger) -> None:
        super().__init__(""research"", bus, ledger)
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/agents/research_agent.py,ResearchAgent,1,6.825604231969389e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects and setting up initial states. This method is likely to be used frequently whenever an instance of the class is created. Therefore, it is unlikely to be deleted unless the entire class is being refactored or removed, which is not indicated here."
survived,"async def main(argv: list[str] | None = None) -> None:
    args = _build_parser().parse_args(argv)
    orch = orchestrator.Orchestrator()
    secs = [sector.Sector(""s%02d"" % i) for i in range(3)]
    sim = forecast.simulate_years(secs, args.horizon)
    for pt in sim:
        print(pt)
    await orch.run_forever()
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/interface/cli.py,,1,2.998960815863541e-09,"The method is likely to survive because it is a well-structured asynchronous main function that uses modern Python features such as type hinting and asynchronous programming. It appears to be part of a larger application, possibly for running simulations or forecasts, which are common in data-driven applications. The use of an orchestrator and sectors suggests a modular design, which is a good practice in software development. There is no indication of deprecated practices or poor design that would warrant deletion."
survived,"def simulate_years(sectors: Iterable[Sector], horizon: int) -> List[ForecastPoint]:
    results: List[ForecastPoint] = []
    for year in range(1, horizon + 1):
        cap = logistic_curve(year / horizon * 10.0)
        affected = [s for s in sectors if thermodynamic_trigger(s, cap)]
        results.append(ForecastPoint(year, cap, affected))
    return results",alpha_factory_v1/demos/alpha_agi_insight_v1/src/simulation/forecast.py,,1,6.348800075736417e-09,"The method 'simulate_years' is likely to survive because it appears to be a well-structured and purposeful function. It takes in a list of sectors and a time horizon, simulates the progression of these sectors over the given time period, and returns a list of forecast points. The use of a logistic curve and a thermodynamic trigger suggests that the function is part of a larger model or simulation, which is a common requirement in fields like economics, environmental science, or engineering. The function is clear in its intent and seems to be a useful component of a forecasting or simulation system."
survived,"    async def run_cycle(self) -> None:
        pass
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/agents/strategy_agent.py,StrategyAgent,0,0.9999999804443193,"The method 'run_cycle' is defined as an asynchronous function but contains no implementation (just a 'pass' statement). If this method is part of a larger class or module that is still under development, it might be a placeholder for future functionality. However, if the codebase is mature and this method has been in this state for a while, it is likely to be deleted as it serves no purpose. Without additional context, it's more likely to be deleted if it remains unimplemented."
survived,"    async def init(self) -> None:
        """"""Initialize all clients in the pool.""""""
        for client in self._clients:
            if not client.running:
                await client.init(
                    timeout=g_config.gemini.timeout,
                    auto_refresh=g_config.gemini.auto_refresh,
                    verbose=g_config.gemini.verbose,
                    refresh_interval=g_config.gemini.refresh_interval,
                )
",app/services/pool.py,GeminiClientPool,1,1.0467401685178159e-08,"The method 'init' is an asynchronous function designed to initialize clients in a pool. It iterates over a list of clients and initializes those that are not running, using configuration parameters. This method is likely to be essential for setting up the client pool correctly, ensuring that all clients are ready to operate with the specified configurations. The use of async/await indicates that it is designed to handle potentially long-running operations without blocking, which is important in modern asynchronous programming. Therefore, it is unlikely to be deleted as it serves a crucial role in the initialization process of the application."
survived,"    def __init__(self, client_id: str, **kwargs):
        super().__init__(**kwargs)
        self.id = client_id
",app/services/client.py,GeminiClientWrapper,1,1.2501528648238603e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. It initializes an instance of the class with a given client_id and any additional keyword arguments. Constructors are essential for setting up initial state and are unlikely to be removed unless the class itself is being deprecated or refactored significantly. Therefore, it is likely to survive."
survived,"        def replacer(match: re.Match) -> str:
            outer_open_paren = match.group(1)
            display_text = match.group(2)

            new_target_url = simplify_link_target(display_text)
            new_link_segment = f""[`{display_text}`]({new_target_url})""

            if outer_open_paren:
                return f""{outer_open_paren}{new_link_segment})""
            else:
                return new_link_segment
",app/services/client.py,GeminiClientWrapper,1,2.646573631904765e-09,"The method 'replacer' is a utility function that processes a regex match object to format a string in a specific way. It extracts parts of the match, processes them, and returns a formatted string. This kind of function is often used in text processing tasks, such as converting markdown links or simplifying URLs. Given its utility in handling text transformations, it is likely to be useful in various contexts where such processing is needed. Therefore, it is more likely to be retained in the codebase."
survived,"def pytest_configure(config: pytest.Config) -> None:
    config.addinivalue_line(
        ""markers"",
        ""requires_torch: mark test that depends on the torch package"",
    )
",tests/conftest.py,,1,3.850741907939403e-09,"The method `pytest_configure` is a configuration hook for the pytest framework, which is widely used for testing in Python. The method adds a custom marker 'requires_torch' to the pytest configuration, allowing tests to be marked as dependent on the 'torch' package. This is a useful feature for organizing and managing tests, especially in projects that use PyTorch. Given the utility and relevance of this method in a testing context, it is likely to be retained."
survived,"def get_window_title(token):
    '''
    Get window title that contain token
    '''
    window_list = Quartz.CGWindowListCopyWindowInfo(
        Quartz.kCGWindowListOptionOnScreenOnly | Quartz.kCGWindowListExcludeDesktopElements,
        Quartz.kCGNullWindowID
    )
    # Get all exist windows
    for window in window_list:
        title = window.get(Quartz.kCGWindowName, '')
        if token in title:
            return title
    return None
",src/input/GameWindowCapturorForMac.py,,1,1.2501528648238603e-09,"The method 'get_window_title' is a utility function that retrieves the title of a window containing a specific token. It uses the Quartz API to access window information on macOS. This function is useful for applications that need to interact with or monitor specific windows based on their titles. The method is straightforward, performs a specific task, and is likely to be used in various scenarios where window management is required. Therefore, it is likely to be retained in the codebase."
survived,"    def switch_status(self, new_status):
        '''
        Switch to new status and log the transition.

        Parameters:
        - new_status: string, the new status to switch to.
        '''
        # Ignore dummy transition
        if self.status == new_status:
            return

        t_elapsed = round(time.time() - self.t_last_switch_status)
        logger.info(f""[switch_status] From {self.status}({t_elapsed} sec) to {new_status}."")
        self.status = new_status
        self.t_last_switch_status = time.time()
",src/legacy/mapleStoryAutoLevelUp_legacy.py,MapleStoryBot,1,2.4616969512093895e-10,"The method 'switch_status' is likely to survive because it performs a useful function of changing the status of an object while logging the transition. This is a common requirement in many applications where state management and logging are important for debugging and tracking purposes. The method also includes a check to avoid unnecessary operations if the status is already the desired one, which is a good practice."
survived,"    def get_nearest_color_code(self):
        '''
        get_nearest_color_code
        '''
        x0, y0 = self.loc_player_global
        h, w = self.img_route.shape[:2]
        x_min = max(0, x0 - self.cfg.color_code_search_range)
        x_max = min(w, x0 + self.cfg.color_code_search_range)
        y_min = max(0, y0 - self.cfg.color_code_search_range)
        y_max = min(h, y0 + self.cfg.color_code_search_range)

        nearest = None
        min_dist = float('inf')
        for y in range(y_min, y_max):
            for x in range(x_min, x_max):
                pixel = tuple(self.img_route[y, x])  # (R, G, B)
                if pixel in self.cfg.color_code:
                    dist = abs(x - x0) + abs(y - y0)
                    if dist < min_dist:
                        min_dist = dist
                        nearest = {
                            ""pixel"": (x, y),
                            ""color"": pixel,
                            ""action"": self.cfg.color_code[pixel],
                            ""distance"": dist
                        }

        # Debug
        draw_rectangle(
            self.img_route_debug,
            (x_min, y_min),
            (self.cfg.color_code_search_range*2, self.cfg.color_code_search_range*2),
            (0, 0, 255), ""Color Search Range""
        )
        # Draw a straigt line from map_loc_player to color_code[""pixel""]
        if nearest is not None:
            cv2.line(
                self.img_route_debug,
                self.loc_player_global, # start point
                nearest[""pixel""],       # end point
                (0, 255, 0),            # green line
                1                       # thickness
            )

            # Print color code on debug image
            cv2.putText(
                self.img_frame_debug,
                f""Route Action: {nearest['action']}"",
                (720, 90),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255),
                2, cv2.LINE_AA
            )
            cv2.putText(
                self.img_frame_debug, f""Route Index: {self.idx_routes}"",
                (720, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255),
                2, cv2.LINE_AA
            )

        return nearest  # if not found return none
",src/legacy/mapleStoryAutoLevelUp_legacy.py,MapleStoryBot,1,1.0467401685178159e-08,"The method `get_nearest_color_code` is a utility function that searches for the nearest color code within a specified range in an image. It is well-structured, performs a specific task, and includes debugging features to visualize the search range and results. Such methods are typically useful in image processing or game development contexts where color-based actions are needed. The method is likely to be retained as it serves a clear purpose and is implemented efficiently."
survived,"        def run_generations(self, *_a) -> None:
            pass
",tests/test_aiga_openai_bridge_offline.py,DummyEvolver,0,0.9999994956527948,"The method `run_generations` is defined but not implemented, as it only contains a `pass` statement. This suggests that it might be a placeholder for future functionality. However, without any additional context or usage in the code, it is likely to be considered dead code. If the method is not called anywhere else in the codebase or if there is no plan to implement it, it is likely to be deleted to clean up the code."
survived,"        def __init__(self, *a, **k) -> None:
            last_runtime[""inst""] = self
            self.registered: list[object] = []
",tests/test_aiga_openai_bridge_offline.py,AgentRuntime,1,3.653482080241728e-08,"The method is a constructor (__init__) in Python, which is a fundamental part of class instantiation. It initializes the instance of the class and is essential for setting up initial state or attributes. The code snippet shows that it is storing a reference to the instance in a dictionary and initializing a list attribute. These are common and necessary operations in object-oriented programming, indicating that the method is likely to be retained as it serves a crucial role in the class's functionality."
survived,"def _free_port() -> int:
    """"""Return an available localhost port.""""""
    with socket.socket() as s:
        s.bind((""127.0.0.1"", 0))
        return int(s.getsockname()[1])
",tests/test_aiga_openai_bridge_offline.py,,1,1.0467401685178159e-08,"The method _free_port is a utility function that finds and returns an available port on localhost. This is a common requirement in network programming, especially for testing purposes where a free port is needed to bind a server or client socket without hardcoding a specific port number. The method is simple, effective, and uses standard library functions, making it a useful and reusable piece of code. Therefore, it is likely to be retained in the codebase."
survived,"    def _worker() -> None:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        task = loop.create_task(coro)
        try:
            result.append(loop.run_until_complete(task))
        finally:
            loop.close()
",alpha_factory_v1/backend/utils/sync.py,,0,0.9999995549151272,"The method '_worker' is likely to be deleted because it contains several issues that make it problematic for production use. Firstly, it creates a new event loop and sets it as the current event loop, which can lead to unexpected behavior if there are already existing event loops. This is generally not recommended in asynchronous programming with asyncio. Secondly, the method uses a global variable 'result' which is not defined within the method, leading to potential errors or undefined behavior. Lastly, the method does not handle exceptions that might occur during the execution of 'coro', which could lead to unhandled exceptions and crashes. These issues suggest that the method is not robust or safe for use, making it a candidate for deletion or significant refactoring."
survived,"    def __init__(self):
        Assimilator.__init__(self)
",sched/testasm.py,TestAssimilator,1,2.5109990926928157e-08,"The method is a constructor for a class that inherits from another class, Assimilator. It correctly calls the parent class's constructor using Assimilator.__init__(self), which is a common and necessary practice in object-oriented programming to ensure proper initialization of the parent class. This method is essential for the class's functionality and is unlikely to be removed unless the class design changes significantly."
survived,"        def generate(self, **kwargs: object) -> list[list[int]]:
            return [[0]]
",tests/test_gpt2_cli_demo.py,FakeModel,1,1.3709566550544279e-06,"The method 'generate' is a simple implementation that returns a nested list containing a single integer 0. Without additional context or requirements, it's difficult to determine its utility. However, the method is syntactically correct and could serve as a placeholder or a basic implementation for generating a 2D list. If the method is part of a larger codebase where more complex list generation is expected, it might be subject to modification or enhancement rather than deletion. Therefore, without further context, it is likely to survive as a basic implementation or a placeholder."
survived,"def _view_lines_tool(ctx: RunContextWrapper | dict, path: str, start: int, end: Optional[int]) -> str:
    return view_lines(path, start, end)
",src/self_edit/tools.py,,0,0.9999999918479795,"The method `_view_lines_tool` is a simple wrapper around the `view_lines` function, adding no additional functionality or logic. It is likely to be deleted because it does not provide any added value or abstraction over directly calling `view_lines`. Such methods are often removed to reduce code redundancy and improve maintainability."
survived,"    def add_tarball(self, tarball: str | Path) -> str:
        path = Path(tarball)
        cid = self._ipfs_add(path)
        with sqlite3.connect(self.db_path) as cx:
            cx.execute(
                ""INSERT INTO tarballs(path, cid, pinned, ts) VALUES(?,?,?,?)"",
                (str(path), cid, 1, time.time()),
            )
        return cid
",src/archive/hash_archive.py,HashArchive,1,1.6918979223288786e-10,"The method 'add_tarball' is likely to survive because it performs a useful function of adding a tarball to an IPFS system and records the operation in a database. It uses modern Python features like type hinting and the Path object, which suggests it is up-to-date with current coding practices. Additionally, it handles database connections using a context manager, which is a good practice for resource management."
survived,"    def merkle_root(self, date: str | None = None) -> str:
        with sqlite3.connect(self.db_path) as cx:
            if date:
                rows = [r[0] for r in cx.execute(""SELECT cid FROM tarballs WHERE DATE(ts,'unixepoch')=? ORDER BY cid"", (date,))]
            else:
                rows = [r[0] for r in cx.execute(""SELECT cid FROM tarballs ORDER BY cid"")]
        return self._compute_root(rows)
",src/archive/hash_archive.py,HashArchive,1,1.4166087846364157e-09,"The method `merkle_root` is likely to survive because it performs a specific and useful function: it calculates the Merkle root of a set of data entries from a database. This is a common operation in systems that require data integrity verification, such as blockchain or distributed systems. The method is well-structured, uses parameterization to allow flexibility (with the optional date parameter), and leverages SQL queries to efficiently retrieve data. Additionally, it uses context management for database connections, which is a good practice. Unless there are changes in the system requirements or architecture that make this method obsolete, it is likely to be retained."
survived,"    def __init__(self, db_path: str | Path) -> None:
        self.db_path = Path(db_path)
        _ensure_db(self.db_path)
",src/archive/hash_archive.py,HashArchive,1,1.444980317078884e-07,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects and setting up initial states. The use of type hints and the call to a helper function (_ensure_db) suggests that this method is part of a well-structured codebase. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
survived,"def test_snark_roundtrip(tmp_path: Path) -> None:
    transcript = tmp_path / ""eval.json""
    entry = {""hash"": ""a1b2"", ""score"": [0.5, 1.2]}
    transcript.write_text(json.dumps([entry]), encoding=""utf-8"")

    db = ArchiveDB(tmp_path / ""arch.db"")
    db.add(ArchiveEntry(""a1b2"", None, 0.5, 0.0, True, 1.0))

    cid = publish_proof(transcript, entry[""hash""], entry[""score""], db)
    assert db.get_proof_cid(entry[""hash""]) == cid

    proof = transcript.with_suffix("".proof"").read_text()
    assert verify_proof(transcript, entry[""hash""], entry[""score""], proof)

    expected_cid = hashlib.sha256(proof.encode()).hexdigest()
    assert cid == expected_cid",tests/test_snark.py,,1,8.152020648014727e-09,"The method 'test_snark_roundtrip' is a test function, likely part of a test suite for a larger application. Test functions are generally not deleted unless they are redundant or the functionality they test is removed. This function appears to be testing a specific roundtrip process involving a transcript, a database, and cryptographic proofs, which suggests it is important for ensuring the integrity and correctness of these operations. Therefore, it is likely to be maintained as long as the related functionality exists."
survived,"    async def ask_llm(
        self,
        messages: str | list[str | SamplingMessage],
        *,
        system_prompt: str | None = None,
        max_tokens: int = 1000,
        temperature: float | None = None,
        model_preferences: ModelPreferences | None = None,
        allow_tools: Literal[""none"", ""thisServer"", ""allServers""] | None = ""none"",
        stop_sequences: list[str] | None = None,
    ) -> CreateMessageResult:
        """"""Request LLM sampling via the connected client.""""""

        sampling_messages = self._convert_messages(messages)
        session = self._request_context.session  # type: ignore[attr-defined]
        return await session.create_message(
            messages=sampling_messages,
            system_prompt=system_prompt,
            max_tokens=max_tokens,
            temperature=temperature,
            model_preferences=model_preferences,
            include_context=allow_tools,
            stop_sequences=stop_sequences,
        )
",src/enrichmcp/context.py,EnrichContext,1,1.1032560311263802e-09,"The method 'ask_llm' is a well-defined asynchronous function that interacts with a language model (LLM) through a client session. It includes parameters for messages, system prompts, token limits, temperature, model preferences, tool permissions, and stop sequences, which are all relevant for LLM operations. The method is likely part of a larger system that requires dynamic interaction with LLMs, a common requirement in modern applications. Given the increasing reliance on AI and LLMs, this method is likely to be retained and possibly even expanded upon in the future."
survived,"        def predict(self, x: int) -> int:
            return x
",tests/trace/test_objs_query.py,MyModel,0,0.9999962733608834,"The method 'predict' is a simple function that takes an integer input and returns the same integer. This method is straightforward and does not perform any complex operations or transformations. It is likely to be considered too simplistic or not useful in a real-world scenario where prediction typically involves some form of computation or logic. Therefore, it is likely to be deleted unless it serves a specific purpose in a larger context that requires returning the input as is."
survived,"def test_adk_client_import(monkeypatch):
    dummy = types.ModuleType(""google_adk"")
    class Client:
        pass
    dummy.Client = Client
    monkeypatch.setitem(sys.modules, ""google_adk"", dummy)
    if MODULE in sys.modules:
        del sys.modules[MODULE]
    mod = importlib.import_module(MODULE)
    assert mod.ADKClient is Client
",tests/test_alpha_agi_business_3_v1.py,,1,4.1399375473943306e-08,"The method 'test_adk_client_import' is a unit test function that uses the 'monkeypatch' fixture to simulate the presence of a module named 'google_adk'. It creates a dummy module with a 'Client' class and injects it into 'sys.modules'. The test then ensures that the 'ADKClient' in the imported module is the same as the 'Client' class defined in the dummy module. This is a valid and useful test for ensuring that the module import mechanism works correctly with the expected class. Since it serves a clear purpose in testing module imports, it is likely to be retained in the codebase."
survived,"def test_execute_and_collect_success(monkeypatch, tmp_path):
    fake_exec = MagicMock()
    fake_exec.run_tests.return_value = ExecutionResult(0, ""out"", ""err"")
    module = ResultCollectionModule(fake_exec)
    result = module.execute_and_collect(tmp_path, timeout=5)
    assert isinstance(result, CollectionResult)
    assert result.exit_code == 0
    assert result.stdout == ""out""
    assert result.stderr == ""err""
    assert result.duration >= 0
    fake_exec.run_tests.assert_called_with(tmp_path, timeout=5)
",tests/unit/test_result_collection_module.py,,1,2.998960815863541e-09,"The method 'test_execute_and_collect_success' is a unit test function that verifies the behavior of the 'execute_and_collect' method in the 'ResultCollectionModule' class. It uses mocking to simulate the behavior of dependencies and checks the correctness of the method's output. Unit tests are crucial for ensuring code reliability and are typically retained in codebases to facilitate ongoing testing and development. Therefore, this method is likely to be retained."
survived,"def test_summarize_creates_report():
    module = ReportingModule()
    result = make_result()
    report = module.summarize(result)
    assert isinstance(report, SummaryReport)
    assert report.exit_code == 0
    assert report.passed is True
    assert report.duration == 1.23
    assert report.stdout == ""out""
    assert report.stderr == ""err""
",tests/unit/test_reporting_module.py,,1,3.581747929000289e-10,"The method 'test_summarize_creates_report' is a unit test function that verifies the behavior of the 'summarize' method in the 'ReportingModule'. It checks if the 'summarize' method returns an object of type 'SummaryReport' with specific attributes. Unit tests are crucial for ensuring code reliability and are typically retained in codebases to maintain software quality. Therefore, it is likely that this method will be Survived."
survived,"def test_generate_html_report():
    module = ReportingModule()
    result = make_result()
    html_report = module.generate_report(result, output_format=""html"")
    assert html_report.startswith(""<html>"")
    assert ""PASSED"" in html_report
",tests/unit/test_reporting_module.py,,1,5.60279640614594e-09,"The method 'test_generate_html_report' is a unit test for the 'generate_report' function of a 'ReportingModule' class. It checks if the generated report is in HTML format and contains the word 'PASSED'. This is a typical test case to ensure that the report generation functionality works as expected. Since testing is a crucial part of software development to maintain code quality and functionality, this method is likely to be retained."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/enumerations-3.py,,1,1.955568070542584e-08,"The method '_now' is a utility function that generates a pseudo-random number based on a seed if '_now_seeded' is True, or returns the current time in nanoseconds if not. This function is useful for generating consistent pseudo-random numbers for testing or other purposes when seeded, and for getting the current time otherwise. It is a simple and effective utility function that serves a clear purpose, making it unlikely to be deleted unless the entire approach to time or random number generation changes in the codebase."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/elliptic-curve-digital-signature-algorithm.py,,1,9.237449576640118e-09,"The method '_now' is a utility function that generates a pseudo-random number based on a global seed if '_now_seeded' is True, otherwise it returns the current time in nanoseconds. This function is useful for generating consistent pseudo-random numbers for testing or other purposes when seeded, and for getting the current time when not seeded. The function is simple, serves a clear purpose, and does not have any apparent issues or redundancies that would necessitate its deletion. Therefore, it is likely to be retained in the codebase."
survived,"def pow2(n):
    p = 1
    i = 0
    while i < n:
        p = p * 2
        i = i + 1
    return p
",tests/rosetta/transpiler/Python/elementary-cellular-automaton-infinite-length.py,,1,1.0129988107056774e-05,"The method 'pow2' calculates 2 raised to the power of 'n' using a simple loop. This is a basic implementation of exponentiation by iterating and multiplying by 2. While this method works correctly, it is not the most efficient way to calculate powers of 2, especially for large 'n'. In Python, the built-in operator '**' or the 'math.pow' function can achieve the same result more efficiently. However, the method is straightforward and serves as a good educational example of loops and basic arithmetic operations. Given that it is functional and correct, it is likely to survive unless there is a specific need for optimization or if the context requires using more efficient built-in functions."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    dividend = 580
    divisor = 34
    res = egyptianDivide(dividend, divisor)
    print(str(dividend) + "" divided by "" + str(divisor) + "" is "" + str(res.q) + "" with remainder "" + str(res.r))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/egyptian-division.py,,1,8.76424914819242e-08,"The method 'main' is a typical entry point for a Python script, and it includes functionality to perform a division operation using a custom method 'egyptianDivide'. It also benchmarks the execution time and memory usage, which can be useful for performance analysis. Unless there is a specific reason to remove this functionality, such as it being replaced by a more efficient or necessary method, it is likely to be retained. Additionally, the method is self-contained and does not appear to have any errors or deprecated practices that would necessitate its removal."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/elliptic-curve-arithmetic.py,,1,1.0677030767166749e-06,"The method _now() is a utility function that generates a pseudo-random number based on a seed if _now_seeded is True, or returns the current time in nanoseconds if not. This function is useful for testing or scenarios where deterministic behavior is needed. It is unlikely to be deleted because it serves a specific purpose in providing a controlled random number generation mechanism, which can be crucial for debugging or testing purposes."
survived,"def isPrime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    d = 3
    while d * d <= n:
        if n % d == 0:
            return False
        d = d + 2
    return True
",tests/rosetta/transpiler/Python/emirp-primes.py,,1,4.363462233903899e-09,"The method is a standard implementation of a prime-checking algorithm, which is a common utility function in many programming tasks. It efficiently checks if a number is prime by first handling small cases and then iterating through potential divisors up to the square root of the number. This method is likely to be useful in various contexts where prime number checks are needed, and it is implemented in a straightforward and efficient manner. Therefore, it is likely to be retained in the codebase."
survived,"def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())
",tests/rosetta/transpiler/Python/enumerations-1.py,,1,1.3440409770490404e-08,"The method '_now' is a utility function that generates a pseudo-random number based on a seed or returns the current time in nanoseconds. Such utility functions are often useful in various applications, especially for testing or when a consistent time value is needed. The use of a global seed allows for reproducibility in tests, which is a common requirement in software development. Therefore, the method is likely to be retained as it serves a practical purpose."
survived,"def show(s, p):
    if isZero(p):
        print(s + ""Zero"")
    else:
        print(s + ""("" + str(p.x) + "", "" + str(p.y) + "")"")
",tests/rosetta/transpiler/Python/elliptic-curve-arithmetic.py,,1,2.5109990926928157e-08,"The method 'show' is a simple utility function that prints a string followed by either 'Zero' or a tuple of coordinates based on the condition. It is a straightforward and potentially useful function for debugging or logging purposes, especially in contexts where 'p' represents a point or similar object. The function is not overly complex, does not have any apparent bugs, and serves a clear purpose. Therefore, it is likely to be retained in the codebase."
survived,"def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print(""Source file entropy: "" + str(entropy(source)))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({""duration_us"": (_bench_end - _bench_start)//1000, ""memory_bytes"": _bench_mem_end*1024, ""name"": ""main""}, indent=2))
",tests/rosetta/transpiler/Python/entropy-narcissist.py,,1,3.850741907939403e-09,"The method is likely to be Survived (1) because it contains functionality that measures and prints the entropy of a source file, as well as benchmarks the memory usage and execution time of this operation. These are useful diagnostics that can help in performance tuning and understanding resource consumption, which are valuable in many applications."
survived,"def isZero(p):
    return p.inf
",tests/rosetta/transpiler/Python/elliptic-curve-arithmetic.py,,0,0.9999999715466527,"The method is likely to be deleted because it attempts to access an attribute 'inf' on the parameter 'p', which is not a standard attribute for common data types in Python. This suggests a misunderstanding or error in the code, as 'inf' is typically used in the context of floating-point numbers to represent infinity, but it is not an attribute of a number or any standard object. Without additional context or a specific object that 'p' is supposed to be, this method does not perform a meaningful or correct operation."
survived,"def log2(x):
    k = 0.0
    v = x
    while v >= 2.0:
        v = v / 2.0
        k = k + 1.0
    while v < 1.0:
        v = v * 2.0
        k = k - 1.0
    z = (v - 1.0) / (v + 1.0)
    zpow = z
    sum = z
    i = 3
    while i <= 9:
        zpow = zpow * z * z
        sum = sum + zpow / (float(i))
        i = i + 2
    ln2 = 0.6931471805599453
    return k + 2.0 * sum / ln2
",tests/rosetta/transpiler/Python/entropy-1.py,,1,3.0590235908148916e-07,"The method implements a custom algorithm to calculate the base-2 logarithm of a number. While it may not be the most efficient or accurate method compared to built-in functions, it is a valid implementation. The method is likely to survive because it provides a unique approach to solving the problem, which could be useful for educational purposes or in environments where built-in functions are not available."
survived,"def main(argv: Optional[list[str]] = None) -> None:
    print_disclaimer()
    args = _parse_args(argv)

    if args.allow_local_code:
        os.environ[""ALPHA_FACTORY_ALLOW_LOCAL_CODE""] = ""1""

    agent = build_core_agent(
        name=""Repo‚ÄëDoctor"",
        instructions=(
            ""You are Repo‚ÄëDoctor, an elite senior software engineer. ""
            ""Your goal: make *all* pytest tests pass. ""
            ""Workflow: 1) run_pytest 2) if failures ‚Üí open the failing file, ""
            ""edit code, save, 3) rerun tests. Repeat until exit status¬†0. ""
            ""Finally stage & commit the patch (or simulate if git is missing).""
        ),
    )

    task_prompt = (
        f""Our CI is red.  The repository is located at {args.repo}. ""
        ""Bring the suite back to green, produce a concise diff summary, and ""
        ""commit to branch *auto‚Äëfix*.""
    )

    if not SDK_AVAILABLE:
        # Fully offline / stub mode
        print(""[warning] OpenAI Agents¬†SDK not available ‚Äë running stub agent\n"")
        print(agent.run(task_prompt))
        sys.exit(0)

    # ‚îÄ‚îÄ Live run via Agents¬†SDK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    result = Runner.run_sync(
        agent,
        task_prompt,
        max_turns=args.max_turns,
    )

    # Print reasoning trace for visibility
    transcript_path = Path.cwd() / ""self_healing_transcript.md""
    transcript_path.write_text(result.transcript_markdown)
    print(f""\nüìÑ  Full agent transcript saved to {transcript_path}\n"")

    # Commit when tests are green
    if ""üéâ"" in result.final_output or ""all tests passed"" in result.final_output.lower():
        commit_msg = _commit_patch(args.repo)
        print(commit_msg)
    else:
        print(""Agent did not report success ‚Äì manual review recommended."")

    # Final console output
    print(""\n‚ïê‚ïê‚ïê FINAL AGENT OUTPUT ‚ïê‚ïê‚ïê\n"")
    print(result.final_output)
    print(""\nDone."")
",alpha_factory_v1/demos/self_healing_repo_cli.py,,1,6.825604231969389e-08,"The method is a main function that orchestrates a series of operations to ensure that all pytest tests pass in a given repository. It includes setting environment variables, building an agent, running tasks, and handling results. This function is crucial for automating the process of fixing test failures and committing changes, which is a valuable feature in continuous integration and deployment pipelines. The functionality it provides is essential for maintaining code quality and efficiency in software development workflows, making it unlikely to be deleted."
survived,"def uvicorn_server() -> Iterator[str]:
    from src.interface import api_server

    port = _free_port()
    config = uvicorn.Config(api_server.app, host=""127.0.0.1"", port=port, log_level=""warning"")
    server = uvicorn.Server(config)
    thread = threading.Thread(target=server.run, daemon=True)
    thread.start()
    for _ in range(50):
        if server.started:
            break
        time.sleep(0.1)
    yield f""http://127.0.0.1:{port}""
    server.should_exit = True
    thread.join(timeout=5)
",tests/test_api_server_uvicorn.py,,1,9.736200303530205e-10,"The method 'uvicorn_server' is likely to survive because it provides a useful functionality of starting a Uvicorn server in a separate thread and yielding the server URL. This is a common requirement in web development and testing environments where a server needs to be run in the background. The method is well-structured, uses threading to avoid blocking the main thread, and includes a mechanism to stop the server gracefully. These characteristics make it a practical and reusable piece of code."
survived,"def test_simulation_endpoints() -> None:
    port = _free_port()
    env = os.environ.copy()
    env[""PYTHONPATH""] = str(REPO_ROOT)
    cmd = [
        sys.executable,
        ""-m"",
        ""alpha_factory_v1.demos.alpha_agi_insight_v1.src.interface.api_server"",
        ""--host"",
        ""127.0.0.1"",
        ""--port"",
        str(port),
    ]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    url = f""http://127.0.0.1:{port}""
    headers = {""Authorization"": ""Bearer test-token""}
    try:
        for _ in range(50):
            try:
                r = httpx.get(url + ""/runs"", headers=headers)
                if r.status_code == 200:
                    break
            except Exception:
                pass
            time.sleep(0.1)
        else:
            raise AssertionError(""server failed to start"")

        progress: list[str] = []

        def _listen() -> None:
            ws_url = f""ws://127.0.0.1:{port}/ws/progress""
            with websockets.connect(ws_url, additional_headers=headers) as ws:
                try:
                    while True:
                        msg = ws.recv()
                        progress.append(msg)
                        if progress:
                            break
                except Exception:
                    pass

        th = threading.Thread(target=_listen, daemon=True)
        th.start()

        r = httpx.post(
            url + ""/simulate"",
            json={""horizon"": 1, ""pop_size"": 2, ""generations"": 1},
            headers=headers,
        )
        assert r.status_code == 200
        sim_id = r.json()[""id""]

        for _ in range(100):
            r = httpx.get(f""{url}/results/{sim_id}"", headers=headers)
            if r.status_code == 200:
                data = r.json()
                break
            time.sleep(0.05)
        else:
            raise AssertionError(""Timed out waiting for results"")

        th.join(timeout=5)
        assert progress
        assert ""forecast"" in data
        r_runs = httpx.get(url + ""/runs"", headers=headers)
        assert r_runs.status_code == 200
        assert sim_id in r_runs.json().get(""ids"", [])
    finally:
        proc.terminate()
        try:
            proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            proc.kill()",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_api_server_subprocess.py,,1,2.2159489282323004e-08,"The method `test_simulation_endpoints` is a comprehensive test function that sets up a server, makes HTTP requests to test various endpoints, and checks the responses. It uses subprocesses, threading, and HTTP requests to ensure the server behaves as expected. This kind of test is crucial for verifying the functionality of an API server, especially in a development or CI/CD environment. Given its importance in ensuring the reliability and correctness of the server's endpoints, it is unlikely to be deleted unless the entire testing strategy is overhauled or the server is deprecated."
survived,"    def test_outer_iterations_minimum(self):
        class DummyWallet:
            def passwords_per_seconds(self, seconds):
                return 0
            def return_verified_password_or_false(self, pw_list):
                pass
        wallet = DummyWallet()
        CHUNKSIZE_SECONDS = 1.0 / 100.0
        measure_performance_iterations = wallet.passwords_per_seconds(0.5)
        inner_iterations = int(round(2 * measure_performance_iterations * CHUNKSIZE_SECONDS)) or 1
        outer_iterations = max(1, int(round(measure_performance_iterations / inner_iterations)))
        self.assertEqual(outer_iterations, 1)
",btcrecover/test/test_passwords.py,TestOuterIterations,1,2.2159489282323004e-08,"The method 'test_outer_iterations_minimum' is a unit test that checks the behavior of the 'outer_iterations' calculation. It uses a dummy class 'DummyWallet' to simulate the behavior of a wallet with a method 'passwords_per_seconds' that returns 0. This test ensures that when the performance measurement is zero, the 'outer_iterations' defaults to 1. This is a valid test case to ensure the robustness of the code when dealing with edge cases, such as zero performance. Therefore, it is likely to be retained as it serves a purpose in verifying the correctness of the code under specific conditions."
survived,"    def test_reset_batch_invalid_size(self):
        env = ce.CurriculumEnv(genome=ce.EnvGenome(max_steps=10), size=6)
        with self.assertRaises(ValueError):
            env.reset_batch(0)
",alpha_factory_v1/tests/test_aiga_meta_evolution.py,CurriculumEnvTest,1,4.944450477491054e-09,"The method `test_reset_batch_invalid_size` is a unit test designed to verify that the `reset_batch` method in the `CurriculumEnv` class raises a `ValueError` when called with an invalid size (in this case, 0). This is a valid and useful test case to ensure that the `reset_batch` method handles invalid input correctly by raising the appropriate exception. Such tests are crucial for maintaining robust and error-resistant code, especially in environments where input validation is critical. Therefore, this method is likely to be retained as part of the test suite."
survived,"def test_foresight_evaluate_nonzero_metrics() -> None:
    repo = Path(__file__).resolve().parents[1]
    scores = foresight_evaluate(repo)
    assert scores[""rmse""] > 0
    assert scores[""lead_time""] != 0",tests/test_demo_cli.py,,1,1.522997951276035e-08,"The method `test_foresight_evaluate_nonzero_metrics` is a unit test function that checks the output of the `foresight_evaluate` function. It ensures that the 'rmse' (root mean square error) is greater than zero and that the 'lead_time' is not zero. These assertions are important to verify that the evaluation metrics are meaningful and not default or erroneous values. The test is simple but serves a crucial role in validating the functionality of the `foresight_evaluate` function. Therefore, it is likely to be retained as part of the test suite to ensure the reliability of the code."
survived,"    def __init__(self) -> None:
        if MetaEvolver and CurriculumEnv:
            self.evolver = MetaEvolver(env_cls=CurriculumEnv, parallel=False)
        else:  # pragma: no cover - offline stub
            self.evolver = None
            logger.warning(""MetaEvolver unavailable ‚Äì AIGAEvolverAgent disabled"")
",alpha_factory_v1/backend/agents/aiga_evolver_agent.py,AIGAEvolverAgent,1,5.3157849718487075e-08,"The method is a constructor for a class, likely initializing an instance of a class that uses MetaEvolver and CurriculumEnv. It includes a conditional check to ensure these components are available before initializing the evolver attribute. If they are not available, it sets the evolver to None and logs a warning. This is a common pattern to handle optional dependencies or features that may not be available in all environments. The method is functional and provides a fallback mechanism, which is a good practice in software development. Therefore, it is likely to be retained in the codebase."
survived,"            def __init__(self, url: str) -> None:
                captured[""url""] = url
",tests/test_ledger_broadcast.py,DummyClient,1,4.1399375473943306e-08,"The method is a constructor for a class, indicated by the name `__init__`, which is a special method in Python used to initialize new objects. The method takes a URL as a parameter and assigns it to a dictionary called `captured`. This suggests that the method is part of a class that is designed to capture or store URLs, possibly for further processing or tracking. Since constructors are essential for creating instances of classes, it is unlikely that this method will be deleted unless the entire class is refactored or removed. Therefore, the method will likely survive."
survived,"    def visit_FunctionDef(self, node):
        args = "","".join(a.arg for a in node.args.args)
        self.emit(f""fun {node.name}({args}): any {{"")
        self.indent += 1
        for s in node.body:
            self.visit(s)
        self.indent -= 1
        self.emit(""}"")
",tools/any2mochi/py_simple.py,Conv,1,1.955568070542584e-08,"The method 'visit_FunctionDef' is a part of a visitor pattern implementation, which is commonly used in compilers or interpreters to traverse and process abstract syntax trees (ASTs). This method specifically handles function definitions, converting them into a specific format. The method is well-structured, performs a clear task, and is likely part of a larger system that relies on this functionality. Therefore, it is unlikely to be deleted unless the entire system undergoes a significant redesign or the language being processed changes drastically."
survived,"    def emit(self, line):
        self.lines.append(""  "" * self.indent + line)
",tools/any2mochi/py_simple.py,Conv,1,7.582560422162384e-10,"The method 'emit' is a simple utility function that appends a formatted string to a list. It is likely part of a larger class that deals with text processing or code generation. Such methods are generally useful for maintaining structured output and are unlikely to be removed unless the entire class or its functionality is deprecated. Therefore, it is more likely to survive."
survived,"    def as_proxy(
        cls,
        backend: Client
        | ClientTransport
        | FastMCP[Any]
        | AnyUrl
        | Path
        | dict[str, Any]
        | str,
        **settings: Any,
    ) -> FastMCPProxy:
        """"""Create a FastMCP proxy server for the given backend.

        The ``backend`` argument can be either an existing :class:`~fastmcp.client.Client`
        instance or any value accepted as the ``transport`` argument of
        :class:`~fastmcp.client.Client`. This mirrors the convenience of the
        ``Client`` constructor.
        """"""
        from fastmcp.server.proxy import FastMCPProxy

        if isinstance(backend, Client):
            client = backend
        else:
            client = Client(backend)

        return FastMCPProxy(client=client, **settings)
",src/fastmcp/server/server.py,FastMCP,1,1.1861120010657661e-08,"The method 'as_proxy' is a utility function designed to create a FastMCP proxy server for a given backend. It provides a convenient way to instantiate a FastMCPProxy object by accepting various types of backends, including existing Client instances or other acceptable transport values. This flexibility and utility make it a valuable part of the codebase, especially if FastMCP proxies are a common requirement in the application. Unless there is a significant change in the architecture or the method becomes redundant due to new features, it is likely to be retained."
survived,"    def update(
        self,
        func: Callable[..., Any] | None = None,
        *,
        name: str | None = None,
        description: str | None = None,
    ) -> Callable[..., Any] | DecoratorCallable:
        """"""Register an update operation.""""""

        def decorator(fn: Callable[..., Any]) -> Callable[..., Any]:
            return self.resource(fn, name=name, description=description)

        if func is not None:
            return decorator(func)
        return cast(""DecoratorCallable"", decorator)
",src/enrichmcp/app.py,EnrichMCP,1,1.6918979223288786e-10,"The method 'update' is a decorator function that allows for the registration of an update operation with optional parameters for name and description. This kind of functionality is common in frameworks that deal with resource management or API endpoint registration, where decorators are used to add metadata or modify behavior of functions. The method is flexible, allowing for both direct and decorator-style usage, which is a desirable feature in many programming contexts. Given its utility and the lack of any deprecated or obsolete patterns, it is likely to be retained in the codebase."
survived,"def main() -> None:
    app.run()
",examples/mutable_crud/app.py,,1,2.0611536181902033e-09,"The method 'main' is a simple function that calls 'app.run()'. Without additional context, it's difficult to determine its utility. However, 'app.run()' is a common pattern in web frameworks like Flask to start a web server. If this is part of a web application, this method is essential for running the server and is likely to be retained. Therefore, it is more likely to survive."
survived,"async def test_patch_model_generation_and_mutable_fields():
    app = EnrichMCP(""Test API"", description=""desc"")

    @app.entity
    class Customer(EnrichModel):
        """"""Customer entity.""""""

        id: int = Field(description=""id"")
        email: str = Field(description=""email"", mutable=True)
        status: str = Field(description=""status"", mutable=True)

    # mutable fields detected
    assert Customer.mutable_fields() == {""email"", ""status""}
    assert hasattr(Customer, ""PatchModel"")
    patch_fields = set(Customer.PatchModel.model_fields.keys())
    assert patch_fields == {""email"", ""status""}
",tests/test_mutability.py,,1,2.0611536181902033e-09,"The method is testing a specific functionality related to the creation of a patch model for an entity with mutable fields. It verifies that the mutable fields are correctly identified and that a PatchModel is generated with the appropriate fields. This is a useful test to ensure that the framework or library being used correctly handles mutable fields in models. Since it serves a clear purpose in validating a feature, it is likely to be retained."
survived,"        def decorator(f: T) -> T:
            return f
",alpha_factory_v1/demos/alpha_agi_insight_v1/src/agents/codegen_agent.py,,1,5.043472052266442e-07,"The method 'decorator' is a simple identity function that takes a function 'f' as an argument and returns it unchanged. This is a common pattern used in Python to create decorators, which are functions that modify the behavior of other functions. Although this specific implementation does not modify the function, it serves as a valid placeholder or base for more complex decorators. Therefore, it is likely to be retained as it can be useful in various contexts where a no-op decorator is needed."
survived,"    def list(self, project: str, page: int, page_size: int) -> list[MemoryNoteSummary]:
        p = self._project_dir(project)
        files = sorted(p.glob(""*.md""))
        start = (page - 1) * page_size
        end = start + page_size
        notes: list[MemoryNoteSummary] = []
        for file in files[start:end]:
            note = self.load(project, file.stem)
            if note:
                notes.append(MemoryNoteSummary(id=note.id, title=note.title))
        return notes
",examples/basic_memory/memory.py,FileMemoryStore,1,2.3355930333443423e-09,"The method 'list' is a typical implementation for paginating through a collection of files, which is a common requirement in many applications. It is well-structured, uses clear logic to determine the range of files to process, and returns a list of summaries, which is a useful abstraction. There is no indication that this method is redundant or poorly implemented, so it is likely to be retained."
survived,"    def list_notes(self, page: int = 1, page_size: int = 10) -> list[MemoryNoteSummary]:
        return self.store.list(self.name, page, page_size)
",examples/basic_memory/memory.py,MemoryProject,1,7.582560422162384e-10,"The method 'list_notes' is a straightforward implementation that provides a paginated list of notes from a store. It is likely to be a core part of the functionality for accessing notes, which is a common requirement in applications dealing with data storage and retrieval. The method is simple, clear, and serves a specific purpose without any apparent issues or redundancies. Therefore, it is likely to be retained in the codebase."
survived,"        def _fake_import(name: str, *args: Any, **kwargs: Any) -> object:
            if name == module_name:
                return fake_mod
            return orig_import_module(name, *args, **kwargs)
",tests/test_check_env_openai_agents_version.py,TestCheckEnvOpenAIAgentsVersion,1,6.348800075736417e-09,"The method '_fake_import' is a utility function that overrides the default import mechanism to return a fake module when a specific module name is requested. This is often used in testing environments to mock dependencies. Such methods are typically retained as they are useful for testing purposes, allowing developers to simulate different scenarios without relying on actual modules. Therefore, it is likely to survive."
survived,"        def load_censor_words(self) -> None:
            pass
",alpha_factory_v1/backend/governance.py,_StubProfanity,1,0.1192029095059074,"The method `load_censor_words` is currently a placeholder with no implementation (indicated by the `pass` statement). If this method is part of a larger class or module that requires loading censor words, it is likely intended to be implemented in the future. However, if there is no plan to implement it or if it is not needed, it might be deleted. Without additional context, it's difficult to determine its necessity, but generally, placeholder methods are kept for future development unless deemed unnecessary."
survived,"        def contains_profanity(self, _text: str) -> bool:
            return False
",alpha_factory_v1/backend/governance.py,_StubProfanity,0,0.9999756997690634,"The method `contains_profanity` is designed to check if a given text contains profanity. However, it currently returns `False` for any input, which means it does not perform any actual check for profanity. This makes the method ineffective for its intended purpose. Unless there is a specific reason to have a placeholder method that always returns `False`, it is likely to be deleted or replaced with a functional implementation that actually checks for profanity."
survived,"    def fake_resolve(pkgs):
        return [], {""badpkg"": ""GPL""}, None
",tests/test_template_validator.py,,0,0.9999999943972036,"The method 'fake_resolve' is likely to be deleted because it returns a hardcoded response that doesn't seem to provide any meaningful or dynamic functionality. The name 'fake_resolve' suggests it might be a placeholder or a mock function used for testing purposes, which is often removed or replaced with actual implementation in production code."
survived,"def test_flynt_skip(state: State):
    s_in = """"""a = 'my string {}, but also {} and {}'.format(var, f, cada_bra)  # flynt: skip""""""
    s_expected = """"""a = 'my string {}, but also {} and {}'.format(var, f, cada_bra)  # flynt: skip""""""

    s_out, count = code_editor.fstringify_code_by_line(s_in, state)
    assert s_out == s_expected
",test/test_edits.py,,1,3.3982678079468468e-09,"The method `test_flynt_skip` is a test function that checks if a specific line of code is correctly skipped by the `fstringify_code_by_line` function due to the presence of the comment `# flynt: skip`. This is a valid and useful test case to ensure that the `flynt` tool respects skip directives, which is important for maintaining code that should not be automatically converted to f-strings. Therefore, the method is likely to be retained as it serves a specific purpose in testing the functionality of the `flynt` tool."
survived,"def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(""--docs"", default=""docs"", help=""Documentation directory"")
    args = parser.parse_args()
    docs_dir = Path(args.docs)
    assets = gather_assets(docs_dir)
    sw_path = docs_dir / ""assets"" / ""service-worker.js""
    lines = [HEADER]
    for asset in assets:
        lines.append(f""          '{asset}',"")
    lines.append(FOOTER)
    sw_path.write_text(""\n"".join(lines))
    print(f""Wrote {sw_path}"")
",scripts/build_service_worker.py,,1,8.152020648014727e-09,"The method is a main function that sets up an argument parser, processes a directory of documentation assets, and writes a service worker JavaScript file. This is a typical utility function that is likely to be used in a build or deployment process for web applications. It is functional, clear, and serves a specific purpose, which makes it unlikely to be deleted unless the entire approach to handling service workers or documentation changes significantly."
survived,"def load_json(path):
    return json.load(open(path)) if os.path.exists(path) else []
",convert_missing.py,,1,1.522997951276035e-08,"The method 'load_json' is a utility function that attempts to load a JSON file from a given path. It first checks if the file exists using 'os.path.exists(path)'. If the file exists, it opens the file and loads the JSON content using 'json.load'. If the file does not exist, it returns an empty list. This method is straightforward and useful for handling JSON file loading with a basic existence check, which is a common requirement in many applications. Therefore, it is likely to be retained as it serves a practical purpose without any apparent issues."
survived,"def test_healthz() -> None:
    resp = client.get(""/healthz"")
    assert resp.status_code == 200
    assert resp.text == ""ok""
",tests/test_insight_health.py,,1,1.0467401685178159e-08,"The method 'test_healthz' is a simple test function that checks the health endpoint of a web service. It verifies that the endpoint returns a status code of 200 and the text 'ok', which are common indicators of a healthy service. Such health check tests are crucial for monitoring the availability and proper functioning of services, especially in production environments. Therefore, this method is likely to be retained as it serves an important role in ensuring system reliability."
survived,"    def __init__(self) -> None:
        self.logged: list[messaging.Envelope] = []
",tests/test_agent_handle_methods.py,DummyLedger,1,2.1024340680345882e-07,"The method is a constructor (__init__) for a class, which is a fundamental part of class instantiation in Python. Constructors are essential for initializing new objects and setting initial values for instance variables. Therefore, it is unlikely that this method will be deleted as it serves a critical role in object-oriented programming."
survived,"    def subscribe(self, topic: str, handler):
        pass
",tests/test_agent_handle_methods.py,DummyBus,0,0.9999982396568657,"The method 'subscribe' is a placeholder with no implementation (indicated by 'pass'). Without any functionality, it doesn't contribute to the codebase. Unless there is a plan to implement it soon, such methods are often removed to keep the code clean and maintainable."
survived,"def test_market_agent_emits_codegen() -> None:
    cfg = config.Settings(bus_port=0)
    bus = DummyBus(cfg)
    led = DummyLedger()
    agent = market_agent.MarketAgent(bus, led)
    env = messaging.Envelope(""strategy"", ""market"", {""strategy"": ""foo""}, 0.0)
    asyncio.run(agent.handle(env))
    assert bus.published[-1][0] == ""codegen""
",tests/test_agent_handle_methods.py,,1,1.725782769012759e-08,"The method 'test_market_agent_emits_codegen' is a unit test function that checks if the 'MarketAgent' correctly publishes a 'codegen' message when handling a specific envelope. Unit tests are crucial for ensuring code reliability and are typically retained in the codebase to maintain software quality. Therefore, this method is likely to be retained."
survived,"        def from_model_data(cls, id: str, model: FinalModelData):
            return cls(
                id=id,
                created=int(datetime.datetime.combine(model.release_date, datetime.time(0, 0)).timestamp()),
                owned_by=model.provider_name,
                display_name=model.display_name,
                icon_url=model.icon_url,
                supports={
                    k.removeprefix(""supports_""): v
                    for k, v in model.model_dump(
                        mode=""json"",
                        include=set(ModelDataSupports.model_fields.keys()),
                    ).items()
                },
            )
",api/api/main.py,StandardModelResponse.ModelItem,1,5.211412485172657e-10,"The method 'from_model_data' is a class method that converts a 'FinalModelData' object into an instance of the class it belongs to. It is a utility function that simplifies the creation of class instances from model data, which is a common pattern in object-oriented programming. This method is likely to be useful for initializing objects with data from a model, making it a valuable part of the class's functionality. Therefore, it is unlikely to be deleted unless the class itself is being refactored or removed."
survived,"def test_bus_tls_accept(tmp_path: Path) -> None:
    """"""Envelope with valid token is accepted over TLS.""""""
    port = _free_port()
    cert, key, ca = _make_cert(tmp_path)
    cfg = config.Settings(bus_port=port, bus_cert=cert, bus_key=key, bus_token=""tok"")
    bus = messaging.A2ABus(cfg)
    received: list[messaging.Envelope] = []

    async def run() -> None:
        bus.subscribe(""b"", lambda e: received.append(e))
        await bus.start()
        try:
            creds = grpc.ssl_channel_credentials(root_certificates=ca)
            async with grpc.aio.secure_channel(f""localhost:{port}"", creds) as ch:
                stub = ch.unary_unary(""/bus.Bus/Send"")
                payload = {
                    ""sender"": ""a"",
                    ""recipient"": ""b"",
                    ""payload"": {""v"": 1},
                    ""ts"": 0.0,
                    ""token"": ""tok"",
                }
                await stub(json.dumps(payload).encode())
            await asyncio.sleep(0.05)
        finally:
            await bus.stop()

    asyncio.run(run())
    assert received and received[0].payload[""v""] == 1
",tests/test_bus_tls.py,,1,1.955568070542584e-08,"The method `test_bus_tls_accept` is a test function that verifies the functionality of a messaging system over TLS. It is well-structured, uses asynchronous programming, and includes assertions to ensure the expected behavior. Such test functions are crucial for maintaining the integrity and security of the system, especially when dealing with secure communications. Therefore, it is likely to be retained as part of the test suite to ensure ongoing reliability and correctness of the system."
survived,"    def test_cli_help(self) -> None:
        result = subprocess.run(
            [sys.executable, '-m', 'alpha_factory_v1.demos.alpha_agi_insight_v1', '--help'],
            capture_output=True,
            text=True,
        )
        self.assertEqual(result.returncode, 0, result.stderr)
        self.assertIn('Insight command line interface', result.stdout)
",tests/test_alpha_agi_insight_v1_main.py,TestAlphaAgiInsightMainV1,1,9.237449576640118e-09,"The method 'test_cli_help' is a unit test designed to verify that the command line interface (CLI) help command for a specific module executes successfully and returns the expected help message. This is a common practice in software development to ensure that the CLI is functioning as intended. The method is straightforward, uses subprocess to run the CLI command, and checks the output for expected results. There is no indication of redundancy, inefficiency, or obsolescence in the method. Therefore, it is likely to be retained as part of the test suite to ensure ongoing functionality of the CLI."
survived,"def test_capability_growth_dispatch() -> None:
    """"""Capability growth should dispatch to the appropriate curve.""""""
    t = 0.3
    assert forecast.capability_growth(t, curve=""linear"") == pytest.approx(forecast.linear_curve(t))
    assert forecast.capability_growth(t, curve=""exponential"") == pytest.approx(forecast.exponential_curve(t))
    assert forecast.capability_growth(t, curve=""logistic"") == pytest.approx(forecast.logistic_curve(10 * t))
    assert forecast.capability_growth(t) == pytest.approx(forecast.logistic_curve(10 * t))",alpha_factory_v1/demos/alpha_agi_insight_v1/tests/test_capability_growth.py,,1,3.3982678079468468e-09,"The method `test_capability_growth_dispatch` is a unit test function that verifies the behavior of the `capability_growth` function from the `forecast` module. It checks if the function correctly dispatches to different growth curves (linear, exponential, logistic) based on the input parameters. This is a typical and necessary test to ensure the correctness of the `capability_growth` function, especially if it is a part of a larger forecasting or modeling system. Unit tests are crucial for maintaining code quality and reliability, and there is no indication that this test is redundant or incorrect. Therefore, it is likely to be retained."
survived,"    def analyze_memory_growth(self, interval_seconds: int = 300) -> Dict[str, float]:
        """"""
        ÂàÜÊûêÂÜÖÂ≠òÂ¢ûÈïøË∂ãÂäø
        :param interval_seconds: ÂàÜÊûêÈó¥ÈöîÔºàÁßíÔºâ
        :return: ÂÜÖÂ≠òÂ¢ûÈïø‰ø°ÊÅØ
        """"""
        try:
            # Ëé∑ÂèñÂΩìÂâçÂÜÖÂ≠ò‰ΩøÁî®
            current_summary = self.get_memory_summary()
            
            # Á≠âÂæÖÊåáÂÆöÊó∂Èó¥
            time.sleep(interval_seconds)
            
            # Ëé∑ÂèñÊñ∞ÁöÑÂÜÖÂ≠ò‰ΩøÁî®
            new_summary = self.get_memory_summary()
            
            if current_summary and new_summary:
                growth_info = {
                    'total_growth_mb': new_summary['total_memory_mb'] - current_summary['total_memory_mb'],
                    'python_growth_mb': new_summary['python_objects_mb'] - current_summary['python_objects_mb'],
                    'unaccounted_growth_mb': new_summary['unaccounted_mb'] - current_summary['unaccounted_mb'],
                    'growth_rate_mb_per_hour': (new_summary['total_memory_mb'] - current_summary['total_memory_mb']) * 3600 / interval_seconds
                }
                
                logger.info(f""ÂÜÖÂ≠òÂ¢ûÈïøÂàÜÊûê: ÊÄªÂ¢ûÈïø {growth_info['total_growth_mb']:.2f} MB, ""
                           f""PythonÂØπË±°Â¢ûÈïø {growth_info['python_growth_mb']:.2f} MB, ""
                           f""Êú™ÁªüËÆ°Â¢ûÈïø {growth_info['unaccounted_growth_mb']:.2f} MB"")
                
                return growth_info
            
            return {}
            
        except Exception as e:
            logger.error(f""ÂàÜÊûêÂÜÖÂ≠òÂ¢ûÈïøÂ§±Ë¥•: {e}"")
            return {}
",app/helper/memory.py,MemoryHelper,1,2.0611536181902033e-09,"The method 'analyze_memory_growth' is likely to survive because it provides a useful functionality for monitoring memory usage over time, which is crucial for performance optimization and debugging in software applications. The method is well-structured, includes error handling, and logs important information, making it a valuable tool for developers to understand memory consumption patterns."
survived,"def special_case(import_id: str, logger: Logger) -> str | None:
    homepage: str | None = None

    # if no slashes, then pkgx used the homepage as the name
    # if two slashes, then probably github / gitlab
    if not re.search(r""/"", import_id) or re.search(r""/.+/"", import_id):
        homepage = import_id

    # if it's a crates.io package, then we can use the crates URL
    elif re.search(r""^crates.io"", import_id):
        if ""/"" in import_id:
            name = import_id.split(""/"")[1]
            homepage = f""https://crates.io/crates/{name}""
        else:
            logger.warn(f""Invalid format for crates.io import_id: {import_id}"")

    # if it's part of the x.org family
    elif re.search(r""^x.org"", import_id):
        homepage = ""https://x.org""

    # if it's part of the pkgx family
    elif re.search(""^pkgx.sh"", import_id):
        tool = import_id.split(""/"")[1]
        homepage = f""https://github.com/pkgxdev/{tool}""

    # python.org/typing_extensions
    elif re.search(""^python.org/typing_extensions"", import_id):
        homepage = ""https://github.com/python/typing_extensions""

    # thrysoee.dk/editline
    elif re.search(""^thrysoee.dk/editline"", import_id):
        homepage = ""https://thrysoee.dk/editline""

    else:
        logger.warn(f""no homepage in pkgx for {import_id}"")

    return homepage
",package_managers/pkgx/url.py,,1,9.237449576640118e-09,"The method 'special_case' is likely to survive because it serves a specific purpose of determining the homepage URL based on the format of the 'import_id'. It handles various cases for different domains and provides a structured way to log warnings when the format is not recognized. This functionality is useful for applications that need to resolve URLs from identifiers, and the method is well-structured to handle different cases, making it a valuable utility function."
survived,"    def test_completely_new_package(self, mock_config, mock_logger):
        """"""Test scenario 4: Package was completely new to the database""""""

        # Create empty cache (no existing packages)
        cache = Cache(package_map={}, url_map={}, package_urls={}, dependencies={})

        # Create new package data
        new_pkg_data = create_pkgx_package(
            distributables=[""https://github.com/example/new-pkg/archive/v1.0.tar.gz""],
            dependencies=[""some-dep""],
            build_deps=[""build-tool""],
        )

        # Test the diff
        diff = PkgxDiff(mock_config, cache, mock_logger)
        pkg_id, pkg_obj, update_payload = diff.diff_pkg(""new-pkg"", new_pkg_data)

        # Assertions
        assert pkg_obj is not None  # New package should be created
        assert pkg_obj.derived_id == ""pkgx/new-pkg""
        assert pkg_obj.name == ""new-pkg""
        assert pkg_obj.import_id == ""new-pkg""
        assert pkg_obj.package_manager_id == mock_config.pm_config.pm_id
        assert update_payload == {}  # No updates for new package

        # Test URL creation
        new_urls = {}
        with (
            patch.object(diff, ""_canonicalize_url"", side_effect=lambda x: x),
            patch.object(
                diff,
                ""_get_homepage_url"",
                return_value=""https://github.com/example/new-pkg"",
            ),
            patch.object(diff, ""_is_github_url"", return_value=True),
        ):
            resolved_urls = diff.diff_url(""new-pkg"", new_pkg_data, new_urls)
            new_links, updated_links = diff.diff_pkg_url(pkg_id, resolved_urls)

        # Should create URLs for homepage, source, and repository (GitHub)
        assert len(new_urls) >= 2  # At least source and homepage
        assert len(new_links) >= 2  # At least source and homepage links
        assert len(updated_links) == 0  # No existing links to update
",tests/package_managers/pkgx/test_pkgx_diff.py,TestPkgxDifferentialLoading,1,9.237449576640118e-09,"The method 'test_completely_new_package' is a unit test designed to verify the behavior of a system when a completely new package is introduced. Unit tests are crucial for ensuring code reliability and are typically maintained as long as the functionality they test is relevant. Since this test checks the creation of a new package in a cache, which is a fundamental operation in package management systems, it is likely to remain relevant and necessary for regression testing. Therefore, it is unlikely to be deleted unless the entire functionality it tests is removed or significantly altered."
survived,"    def set_current_urls(self) -> None:
        """"""Getting all the URLs and Package URLs from the database""""""
        self.urls: CurrentURLs | None = None
        url_map: dict[URLKey, URL] = {}
        package_urls: dict[UUID, set[PackageURL]] = {}

        stmt = (
            select(Package, PackageURL, URL)
            .select_from(URL)
            .join(PackageURL, PackageURL.url_id == URL.id, isouter=True)
            .join(Package, Package.id == PackageURL.package_id, isouter=True)
        )
        with self.session() as session:
            result: Result[tuple[Package, PackageURL, URL]] = session.execute(stmt)

            for pkg, pkg_url, url in result:
                url_key = URLKey(url.url, url.url_type_id)
                url_map[url_key] = url

                # since it's a left join, we need to check if pkg is None
                if pkg is not None:
                    if pkg.id not in package_urls:
                        package_urls[pkg.id] = set()
                    package_urls[pkg.id].add(pkg_url)

        self.urls = CurrentURLs(url_map=url_map, package_urls=package_urls)
",package_managers/pkgx/db.py,PkgxDB,1,6.69158608681505e-10,"The method 'set_current_urls' is well-defined and serves a clear purpose of fetching and organizing URL data from a database. It uses SQLAlchemy to perform a query that joins multiple tables and processes the results into a structured format. This functionality is essential for applications that need to manage and utilize URL data efficiently. The method is also type-annotated, which improves code readability and maintainability. There is no indication that this method is redundant or obsolete, and it appears to be a crucial part of the system's data handling logic. Therefore, it is likely to be retained in the codebase."
survived,"    def test_package_exists_url_update(self, mock_config, mock_logger):
        """"""Test scenario 2: Package existed in database and needed a URL update""""""

        # Setup existing package and URL
        existing_pkg_id = uuid4()
        existing_url_id = uuid4()
        existing_package_url_id = uuid4()

        existing_package = Package(
            id=existing_pkg_id,
            derived_id=""pkgx/url-pkg"",
            name=""url-pkg"",
            package_manager_id=mock_config.pm_config.pm_id,
            import_id=""url-pkg"",
            readme=""Test package"",
        )

        existing_url = URL(
            id=existing_url_id,
            url=""https://old-source.com/file.tar.gz"",
            url_type_id=mock_config.url_types.source,
        )

        existing_package_url = PackageURL(
            id=existing_package_url_id,
            package_id=existing_pkg_id,
            url_id=existing_url_id,
        )

        # Create cache
        cache = Cache(
            package_map={""url-pkg"": existing_package},
            url_map={
                URLKey(
                    ""https://old-source.com/file.tar.gz"", mock_config.url_types.source
                ): existing_url
            },
            package_urls={existing_pkg_id: {existing_package_url}},
            dependencies={},
        )

        # Create package data with new URL
        new_pkg_data = create_pkgx_package(
            distributables=[""https://new-source.com/file.tar.gz""],
        )

        # Test the diff
        diff = PkgxDiff(mock_config, cache, mock_logger)
        new_urls = {}

        # Mock the URL canonicalization and homepage methods
        with (
            patch.object(diff, ""_canonicalize_url"", side_effect=lambda x: x),
            patch.object(diff, ""_get_homepage_url"", return_value=None),
            patch.object(diff, ""_is_github_url"", return_value=False),
        ):
            resolved_urls = diff.diff_url(""url-pkg"", new_pkg_data, new_urls)
            new_links, updated_links = diff.diff_pkg_url(existing_pkg_id, resolved_urls)

        # Assertions
        assert len(new_urls) == 1  # New URL should be created
        new_url = next(iter(new_urls.values()))
        assert new_url.url == ""https://new-source.com/file.tar.gz""
        assert new_url.url_type_id == mock_config.url_types.source

        assert len(new_links) == 1  # New package URL link should be created
        assert new_links[0].package_id == existing_pkg_id
        assert new_links[0].url_id == new_url.id
",tests/package_managers/pkgx/test_pkgx_diff.py,TestPkgxDifferentialLoading,1,5.715002851580502e-07,"The method `test_package_exists_url_update` is a unit test designed to verify the functionality of updating a package's URL in a database. It sets up mock data, simulates a URL update, and asserts the expected outcomes. This is a typical and necessary part of software testing to ensure code reliability and correctness. Since it is a test method, it is unlikely to be deleted unless the functionality it tests is removed or significantly changed, which is not indicated here."
survived,"    def diff_url(
        self, import_id: str, pkg: PkgxPackage, new_urls: dict[tuple[str, UUID], URL]
    ) -> dict[UUID, UUID]:
        """"""Given a package's URLs, returns the resolved URL for this specific package""""""
        resolved_urls: dict[UUID, UUID] = {}

        # Collect all URLs from the package
        urls_to_process = []

        # Add homepage URL if it exists
        homepage = self._get_homepage_url(import_id, pkg)
        if homepage:
            urls_to_process.append((homepage, self.config.url_types.homepage))

        # Add source URLs from distributables
        for distributable in pkg.distributable:
            if distributable.url:
                clean_url = self._canonicalize_url(distributable.url)
                if clean_url:
                    urls_to_process.append((clean_url, self.config.url_types.source))

                    # If it's a GitHub URL, also add as repository
                    if self._is_github_url(clean_url):
                        urls_to_process.append(
                            (clean_url, self.config.url_types.repository)
                        )

        # Process each URL
        for url, url_type in urls_to_process:
            url_key = URLKey(url, url_type)
            resolved_url_id: UUID

            if url_key in new_urls:
                resolved_url_id = new_urls[url_key].id
            elif url_key in self.caches.url_map:
                resolved_url_id = self.caches.url_map[url_key].id
            else:
                self.logger.debug(f""URL {url} for {url_type} is entirely new"")
                new_url = URL(
                    id=uuid4(),
                    url=url,
                    url_type_id=url_type,
                    created_at=self.now,
                    updated_at=self.now,
                )
                resolved_url_id = new_url.id
                new_urls[url_key] = new_url

            resolved_urls[url_type] = resolved_url_id

        return resolved_urls
",package_managers/pkgx/diff.py,PkgxDiff,1,6.69158608681505e-10,"The method 'diff_url' is well-structured and serves a clear purpose of resolving URLs for a package by checking against new URLs and a cache. It handles different types of URLs, including homepage and source URLs, and even considers special cases like GitHub URLs. The method is likely part of a larger system that manages package metadata, and its functionality is essential for ensuring that the correct URLs are associated with packages. Given its utility and the fact that it doesn't have any apparent issues or redundancies, it is likely to be retained in the codebase."
survived,"    def test_sort_by_release_date_asc(self):
        """"""Test sorting by release date (oldest first).""""""
        models: list[ConciseModelResponse | ConciseLatestModelResponse] = [
            create_test_model(""model1"", release_date=""2024-01-01""),
            create_test_model(""model2"", release_date=""2024-03-01""),
            create_test_model(""model3"", release_date=""2024-02-01""),
        ]

        sorted_models = sort_models(models, ""release_date"", ""asc"")

        assert [m.id for m in sorted_models] == [""model1"", ""model3"", ""model2""]
",api/api/routers/mcp/_utils/model_sorting_test.py,TestSortModels,1,3.653482080241728e-08,"The method `test_sort_by_release_date_asc` is a unit test designed to verify the functionality of sorting models by their release date in ascending order. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with sorting algorithms that can have significant impacts on data presentation and processing. This test is well-defined, checks a specific functionality, and is likely part of a larger test suite. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality."
survived,"    def test_sort_by_run_count_asc(self):
        """"""Test sorting by run count ascending (lowest first).""""""
        agents = [
            create_test_agent(""agent1"", run_count=5),
            create_test_agent(""agent2"", run_count=100),
            create_test_agent(""agent3"", run_count=50),
            create_test_agent(""agent4"", run_count=100),  # Same count as agent2
        ]

        sorted_agents = sort_agents(agents, ""run_count"", ""asc"")

        # Lowest count first
        assert [a.agent_id for a in sorted_agents] == [""agent1"", ""agent3"", ""agent2"", ""agent4""]
",api/api/routers/mcp/_utils/agent_sorting_test.py,TestSortAgents,1,1.3440409770490404e-08,"The method `test_sort_by_run_count_asc` is a unit test that verifies the functionality of sorting agents by their run count in ascending order. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with sorting algorithms that can have subtle bugs. This test checks that the sorting function correctly orders agents by their run count, including handling ties (as seen with agent2 and agent4). Since testing is an essential part of software development to maintain code quality, this method is likely to be retained."
survived,"    def test_sort_by_speed_index_desc(self):
        """"""Test sorting by speed index (highest first).""""""
        models: list[ConciseModelResponse | ConciseLatestModelResponse] = [
            create_test_model(""model1"", speed_index=300),
            create_test_model(""model2"", speed_index=800),
            create_test_model(""model3"", speed_index=600),
        ]

        sorted_models = sort_models(models, ""speed_index"", ""desc"")

        assert [m.id for m in sorted_models] == [""model2"", ""model3"", ""model1""]
",api/api/routers/mcp/_utils/model_sorting_test.py,TestSortModels,1,2.646573631904765e-09,"The method `test_sort_by_speed_index_desc` is a unit test designed to verify the functionality of sorting models by their speed index in descending order. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with sorting algorithms or data manipulation. This test checks that the `sort_models` function correctly orders the models based on the specified criteria. Since testing is an integral part of software development and maintenance, this method is likely to be retained to ensure the continued accuracy and reliability of the sorting functionality."
survived,"        def _return_pydantic_obj(*args, **kwargs):
            new_response = MagicMock()
            new_response.headers = {""content-type"": ""application/json""}
            new_response.parse.return_value = pydantic_obj
            return new_response
",tests/llm_translation/test_perplexity_reasoning.py,TestPerplexityReasoning,1,1.955568070542584e-08,"The method '_return_pydantic_obj' is a utility function that creates a mock response object with specific attributes, such as headers and a parse method that returns a 'pydantic_obj'. This kind of function is useful for testing purposes, especially when dealing with HTTP responses in a controlled environment. Since testing is a crucial part of software development, and this function provides a clear utility in that context, it is likely to be retained in the codebase."
survived,"    def column_visibility(self) -> Dict[str, bool]:
        """"""Get column visibility configuration from preset options""""""
        config = [
            option
            for option in self.options
            if option.get(""label"", """").lower() == ""column_visibility""
        ]
        if not config:
            return {}
        return config[0].get(""value"", {})
",keep/api/models/db/preset.py,PresetDto,1,4.0586521248284276e-10,"The method 'column_visibility' is a utility function that retrieves a specific configuration from a list of options. It is likely to be useful in contexts where dynamic configuration of column visibility is needed, such as in data tables or UI components. The method is straightforward, performs a clear task, and does not have any apparent issues or redundancies that would warrant its removal. Therefore, it is likely to be retained in the codebase."
survived,"def test_semantic_split_token(sample_df):
    """"""Test semantic split operation with token count method.""""""
    result = sample_df.semantic.split(
        split_key=""text"",
        method=""token_count"",
        method_kwargs={""num_tokens"": 10}
    )
    
    assert isinstance(result, pd.DataFrame)
    assert len(result) >= len(sample_df)  # Should create more rows
    assert ""text_chunk"" in result.columns
    assert f""semantic_split_0_id"" in result.columns
    assert f""semantic_split_0_chunk_num"" in result.columns
    
    # Check that all chunks have sequential numbering
    for doc_id in result[f""semantic_split_0_id""].unique():
        doc_chunks = result[result[f""semantic_split_0_id""] == doc_id]
        chunk_nums = sorted(doc_chunks[f""semantic_split_0_chunk_num""].tolist())
        assert chunk_nums == list(range(1, len(chunk_nums) + 1))
",tests/test_pandas_accessors.py,,1,2.8453347280241004e-08,"The method is a test function for a specific feature of a DataFrame operation, which is a common practice in software development to ensure code reliability and correctness. It is well-structured, uses assertions to validate the expected behavior, and is likely part of a test suite. Such methods are typically retained as they are crucial for maintaining code quality and catching regressions."
survived,"    def test_cost_report_none_days(self):
        """"""Test cost_report with None days parameter.""""""
        with mock.patch('sky.global_user_state.get_clusters_from_history') as mock_get_history:
            mock_get_history.return_value = []
            
            result = core.cost_report(days=None)
            
            # Should call with default 30 days when None is passed
            mock_get_history.assert_called_once_with(days=30)
            self.assertEqual(result, [])
",tests/unit_tests/test_sky_cost_report.py,TestCostReportCore,1,8.152020648014727e-09,"The method `test_cost_report_none_days` is a unit test designed to verify the behavior of the `cost_report` function when `None` is passed as the `days` parameter. It ensures that the function defaults to using 30 days in such cases. This is a valid and useful test case to ensure the robustness of the `cost_report` function, especially in handling edge cases where input parameters might be `None`. Therefore, the method is likely to be retained as it contributes to the overall test coverage and reliability of the code."
survived,"    def _create_alert(**properties):
        alert_data = {
            ""id"": ""test-alert-1"",
            ""source"": [""prometheus""],
            ""name"": ""test-alert"",
            ""status"": AlertStatus.FIRING,
            ""severity"": AlertSeverity.INFO,
            ""lastReceived"": datetime.datetime.now().isoformat(),
            ""fingerprint"": f""test-fingerprint-{datetime.datetime.now().timestamp()}"",
        }
        alert_data.update(properties)
        return AlertDto(**alert_data)
",tests/test_workflow_severity_comparisons.py,,1,1.2501528648238603e-09,"The method '_create_alert' is a utility function designed to create an alert object with default values, which can be overridden by passing additional properties. This kind of method is useful for testing or initializing objects with default configurations. It is likely to survive because it provides a convenient way to create alert objects with minimal code repetition, enhancing code maintainability and readability."
survived,"def test_complex_severity_expressions(
    db_session, workflow_manager, create_workflow, create_alert
):
    """"""Test complex CEL expressions involving severity comparisons""""""
    workflow = create_workflow(
        ""test-complex-severity"",
        ""(severity >= 'warning' && source.contains('prometheus')) || (severity == 'critical' && source.contains('grafana'))""
    )

    # Should match: prometheus with warning+, grafana with critical
    prometheus_critical = create_alert(
        severity=AlertSeverity.CRITICAL, source=[""prometheus""], fingerprint=""fp1""
    )
    prometheus_high = create_alert(
        severity=AlertSeverity.HIGH, source=[""prometheus""], fingerprint=""fp2""
    )
    prometheus_warning = create_alert(
        severity=AlertSeverity.WARNING, source=[""prometheus""], fingerprint=""fp3""
    )
    grafana_critical = create_alert(
        severity=AlertSeverity.CRITICAL, source=[""grafana""], fingerprint=""fp4""
    )

    # Should NOT match: prometheus with info/low, grafana with non-critical
    prometheus_info = create_alert(
        severity=AlertSeverity.INFO, source=[""prometheus""], fingerprint=""fp5""
    )
    grafana_high = create_alert(
        severity=AlertSeverity.HIGH, source=[""grafana""], fingerprint=""fp6""
    )

    # Test matching alerts
    for alert in [prometheus_critical, prometheus_high, prometheus_warning, grafana_critical]:
        workflows_to_run_before = len(workflow_manager.scheduler.workflows_to_run)
        workflow_manager.insert_events(SINGLE_TENANT_UUID, [alert])
        assert len(workflow_manager.scheduler.workflows_to_run) == workflows_to_run_before + 1

    # Test non-matching alerts
    for alert in [prometheus_info, grafana_high]:
        workflows_to_run_before = len(workflow_manager.scheduler.workflows_to_run)
        workflow_manager.insert_events(SINGLE_TENANT_UUID, [alert])
        assert len(workflow_manager.scheduler.workflows_to_run) == workflows_to_run_before
",tests/test_workflow_severity_comparisons.py,,1,1.725782769012759e-08,"The method `test_complex_severity_expressions` is a unit test function that verifies the behavior of a workflow system when processing alerts with different severity levels and sources. It is well-structured, uses assertions to validate expected outcomes, and is crucial for ensuring the correctness of the workflow logic. Such test functions are essential for maintaining software quality and are unlikely to be deleted unless the functionality they test is removed or significantly changed."
survived,"def create_alert():
    """"""Fixture to create an alert DTO with specified properties""""""

    def _create_alert(**properties):
        alert_data = {
            ""id"": ""test-alert-1"",
            ""source"": [""prometheus""],
            ""name"": ""test-alert"",
            ""status"": AlertStatus.FIRING,
            ""severity"": AlertSeverity.INFO,
            ""lastReceived"": datetime.datetime.now().isoformat(),
            ""fingerprint"": f""test-fingerprint-{datetime.datetime.now().timestamp()}"",
        }
        alert_data.update(properties)
        return AlertDto(**alert_data)

    return _create_alert
",tests/test_workflow_severity_comparisons.py,,1,1.8189616842444243e-09,"The method 'create_alert' is a fixture function designed to generate alert data transfer objects (DTOs) with customizable properties. This is a common pattern in testing to create mock objects with default values that can be overridden as needed. Such utility functions are often retained in codebases because they facilitate testing by providing a simple way to create consistent test data. Additionally, the method is well-defined, uses current best practices (like using datetime for timestamps), and is likely to be useful in a variety of test scenarios. Therefore, it is likely to survive."
survived,"    def set_current_graph(self) -> None:
        """"""Get the debian packages and dependencies""""""
        self.graph: CurrentGraph = self.current_graph(self.config.pm_config.pm_id)
",package_managers/debian/db.py,DebianDB,1,6.348800075736417e-09,"The method 'set_current_graph' is a simple setter method that assigns a value to the 'graph' attribute of the class. It is likely part of a larger system that manages package dependencies, possibly in a package manager context. The method is straightforward, has a clear purpose, and does not contain any apparent issues or redundancies that would warrant its removal. Additionally, the method's functionality seems essential for setting up the current state of the graph based on the configuration, which is a common requirement in systems dealing with package management or dependency graphs. Therefore, it is likely to be retained."
survived,"    def test_enrich_package_preserves_existing_fields(self, mock_logger):
        """"""Test that existing package fields are not overwritten""""""
        # Create package data with existing homepage
        package_data = create_debian_package(
            package=""pkg-with-homepage"",
            homepage=""pkg-homepage.com"",  # Normalized format
        )

        # Create source data with different homepage
        source_data = create_debian_package(
            package=""pkg-with-homepage"",
            homepage=""source-homepage.com"",  # Normalized format
            vcs_git=""github.com/test/pkg"",  # Normalized format
        )
        source_mapping = {""pkg-with-homepage"": source_data}

        # Enrich package
        enriched = enrich_package_with_source(package_data, source_mapping, mock_logger)

        # Verify package homepage is preserved, but source info is added
        assert enriched.homepage == ""pkg-homepage.com""  # Package value preserved
        assert enriched.vcs_git == ""github.com/test/pkg""  # Source value added",tests/package_managers/debian/test_debian_sources.py,TestPackageSourceMapping,1,4.363462233903899e-09,"The method 'test_enrich_package_preserves_existing_fields' is a unit test that verifies the functionality of preserving existing fields in a package while enriching it with additional source data. This is a common and important test to ensure that data integrity is maintained during data enrichment processes. Such tests are crucial for validating that the software behaves as expected and do not typically get deleted unless the functionality they test is removed or significantly altered. Therefore, the method is likely to be retained as long as the functionality it tests remains relevant."
survived,"    def test_missing_dependency_handling(self, mock_config, mock_logger, mock_db):
        """"""Tests the case that we DON'T add dependencies for new packages""""""

        existing_pkg_id = uuid4()
        existing_package = Package(
            id=existing_pkg_id,
            derived_id=""debian/missing-dep-pkg"",
            name=""missing-dep-pkg"",
            import_id=""missing-dep-pkg"",
        )

        cache = Cache(
            package_map={""missing-dep-pkg"": existing_package},
            url_map={},
            package_urls={},
            dependencies={},
        )

        # Create package with dependency that doesn't exist in cache
        pkg_data = create_debian_package(
            package=""missing-dep-pkg"", depends=[""non-existent-dep""]
        )

        diff = DebianDiff(mock_config, cache, mock_db, mock_logger)
        new_deps, removed_deps = diff.diff_deps(""missing-dep-pkg"", pkg_data)

        # Should handle gracefully - no deps added for missing packages
        assert len(new_deps) == 0
        assert len(removed_deps) == 0
",tests/package_managers/debian/test_debian_diff.py,TestDebianDifferentialLoading,1,1.522997951276035e-08,"The method 'test_missing_dependency_handling' is a unit test designed to verify the behavior of a system when handling packages with missing dependencies. Unit tests are crucial for ensuring code reliability and correctness, especially in complex systems. This test checks that no new dependencies are added when they are not present, which is an important aspect of dependency management. Given its role in maintaining code quality and preventing regressions, it is likely to be retained."
survived,"    def diff_pkg(
        self, import_id: str, debian_data: DebianData
    ) -> tuple[UUID, Package | None, dict | None]:
        """"""
        Checks if the given package is in the package_cache.

        Returns:
          - pkg_id: the id of the package
          - package: If new, returns a new package object. If existing, returns None
          - changes: a dictionary of changes (description updates)
        """"""
        self.logger.debug(f""Diffing package: {import_id}"")

        if import_id not in self.caches.package_map:
            # new package
            name = import_id.split(""/"")[1]
            p = Package(
                id=uuid4(),
                derived_id=import_id,
                name=name,
                package_manager_id=self.config.pm_config.pm_id,
                import_id=import_id,
                readme=debian_data.description,
                created_at=self.now,
                updated_at=self.now,
            )
            pkg_id: UUID = p.id
            return pkg_id, p, {}
        else:
            # the package exists, check if description has changed
            existing_pkg = self.caches.package_map[import_id]
            pkg_id = existing_pkg.id

            # Check if description (readme) has changed
            if existing_pkg.readme != debian_data.description:
                update_payload = {
                    ""id"": pkg_id,
                    ""readme"": debian_data.description,
                    ""updated_at"": self.now,
                }
                return pkg_id, None, update_payload
            else:
                return pkg_id, None, None
",package_managers/debian/diff.py,DebianDiff,1,6.69158608681505e-10,"The method 'diff_pkg' is well-structured and serves a clear purpose in the codebase. It checks if a package is new or existing, and if existing, it checks for changes in the package description. This functionality is essential for maintaining an up-to-date package cache, which is a common requirement in package management systems. The method is also well-documented, making it easy to understand and maintain. There is no indication that this method is redundant or obsolete, so it is likely to be retained in the codebase."
survived,"    def test_multiline_binary(self, multiline_binary):
        """"""Test handling of multiline binaries.""""""
        parser = DebianParser(multiline_binary)
        sources = list(parser.parse())
        assert len(sources) == 1
        source = sources[0]
        assert source.package == ""binutils""
        assert source.binary == [
            ""binutils-for-host"",
            ""binutils-for-build"",
            ""binutils-ia64-linux-gnu-dbg"",
            ""binutils-m68k-linux-gnu"",
            ""binutils-mips64el-linux-gnuabin32-dbg"",
            ""binutils-mipsisa64r6-linux-gnuabin32"",
            ""binutils-mipsisa64r6el-linux-gnuabi64-dbg"",
        ]
",tests/package_managers/debian/test_debian_parser.py,TestDebianParser,1,4.944450477491054e-09,"The method 'test_multiline_binary' is a unit test designed to verify the functionality of the 'DebianParser' class when handling multiline binary data. It checks that the parser correctly identifies and processes a list of binary packages. This is a typical and necessary test in software development to ensure that the parser behaves as expected. Since testing is a crucial part of maintaining code quality and reliability, this method is likely to be retained in the codebase."
survived,"    def __init__(self, logger_name: str, config: Config):
        super().__init__(logger_name)
        self.config = config
",package_managers/debian/db.py,DebianDB,1,3.653482080241728e-08,"The method is a constructor (__init__) for a class, which is a fundamental part of class definition in Python. Constructors are essential for initializing new objects with specific attributes, and they are unlikely to be deleted unless the entire class is being refactored or removed. Additionally, the method is using parameters to initialize the object, which suggests it is actively used in the class design."
survived,"def not_found(error):
    return jsonify({'error': 'Not found'}), 404
",server/main.py,,1,3.3982678079468468e-09,"The method 'not_found' is a simple utility function that returns a JSON response with a 404 status code, indicating that a resource was not found. This is a common pattern in web applications to handle cases where a requested resource does not exist. Such utility functions are often kept in codebases to standardize error handling and improve code readability. Therefore, it is likely to be retained in the codebase."
survived,"    def add_chat_message(task_id: int, user_id: str, role: str, content: str) -> Optional[Dict]:
        """"""Add a chat message to a task""""""
        try:
            # Get current task
            task = DatabaseOperations.get_task_by_id(task_id, user_id)
            if not task:
                return None
            
            # Add new message
            chat_messages = task.get('chat_messages', [])
            new_message = {
                'role': role,
                'content': content,
                'timestamp': datetime.utcnow().isoformat()
            }
            chat_messages.append(new_message)
            
            # Update task
            return DatabaseOperations.update_task(task_id, user_id, {'chat_messages': chat_messages})
        except Exception as e:
            logger.error(f""Error adding chat message to task {task_id}: {e}"")
            raise
",server/database.py,DatabaseOperations,1,2.4616969512093895e-10,"The method 'add_chat_message' is likely to survive because it performs a useful function of adding chat messages to a task, which is a common requirement in applications that involve task management and communication. The method is well-structured, handles exceptions, and logs errors, which are good practices in software development. Additionally, it interacts with a database, suggesting it is part of a larger system where such functionality is necessary."
survived,"    def get_task_by_legacy_id(legacy_id: str) -> Optional[Dict]:
        """"""Get a task by its legacy UUID (for migration purposes)""""""
        try:
            result = supabase.table('tasks').select('*').eq('execution_metadata->>legacy_id', legacy_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f""Error fetching task by legacy ID {legacy_id}: {e}"")
            raise
",server/database.py,DatabaseOperations,0,0.9999999928058669,"The method 'get_task_by_legacy_id' is likely to be deleted because it is specifically designed for migration purposes, as indicated by the comment in the code. Once the migration process is complete, such methods are often removed to clean up the codebase and reduce maintenance overhead. Additionally, the use of a 'legacy_id' suggests that this method is dealing with outdated or deprecated data structures, further supporting the likelihood of its eventual removal."
survived,"    def delete_project(project_id: int, user_id: str) -> bool:
        """"""Delete a project""""""
        try:
            result = supabase.table('projects').delete().eq('id', project_id).eq('user_id', user_id).execute()
            return len(result.data) > 0
        except Exception as e:
            logger.error(f""Error deleting project {project_id}: {e}"")
            raise
",server/database.py,DatabaseOperations,1,3.3982678079468468e-09,"The method 'delete_project' is a straightforward function that performs a specific task: deleting a project from a database. It includes error handling and logging, which are good practices for maintaining robust code. The method is likely to be useful in applications where project management is required, and it aligns with common operations in database management. Therefore, it is likely to be retained in the codebase."
survived,"def sanitize_filename(filename: str) -> str:
    """"""Sanitize filename to prevent path traversal attacks""""""
    # Remove directory separators and other dangerous characters
    filename = os.path.basename(filename)
    # Remove any remaining path separators that might exist
    filename = filename.replace("".."", """").replace(""/"", """").replace(""\\"", """")
    # Ensure the filename is not empty after sanitization
    if not filename or filename.startswith('.'):
        filename = ""uploaded_file""
    return filename
",server/utils/file.py,,1,8.152020648014727e-09,"The method 'sanitize_filename' is designed to prevent path traversal attacks by sanitizing filenames. This is a crucial security measure, especially in web applications where user input can be used to access files. The method effectively removes directory separators and other potentially dangerous characters, ensuring that the filename is safe to use. Additionally, it provides a fallback name if the filename becomes empty or starts with a dot after sanitization. Given its importance in maintaining security and its correct implementation, this method is likely to be retained in the codebase."
survived,"def save_combined_file(data: Dict, output_path: str) -> None:
    """"""
    Save combined metadata to a JSON file.
    
    Args:
        data: Dictionary to save
        output_path: Path where to save the file
    """"""
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    print(f""Saved combined metadata to {output_path}"")
",combine_metadata.py,,1,1.522997951276035e-08,"The method 'save_combined_file' is a utility function that performs a common task of saving a dictionary to a JSON file. This is a fundamental operation in many applications that deal with data processing, configuration management, or any form of data serialization. The method is well-defined, with clear arguments and functionality, and it includes error handling for directory creation. Such utility functions are often reused across different projects and are unlikely to be deleted unless they are replaced by a more efficient or standardized library function. However, given its simplicity and direct use of Python's built-in libraries, it is more likely to be retained as is."
survived,"    def test_mcp_vs_rest_api_mode_exclusive(self, runner, temp_python_script):
        """"""Test that MCP and REST API modes are mutually exclusive in terms of requirements.""""""
        # Test that --mcp skips API key validation
        with patch.dict(""os.environ"", {}, clear=True):
            with patch(""langflow.cli.commands.run_mcp_server"") as mock_run_mcp:
                mock_run_mcp.side_effect = KeyboardInterrupt(""Test interrupt"")
                
                # MCP mode should work without API key
                result_mcp = runner.invoke(app, [
                    ""serve"", str(temp_python_script),
                    ""--mcp"", ""--verbose""
                ])
                assert ""MCP mode enabled"" in result_mcp.output
                
                # REST API mode should fail without API key
                result_rest = runner.invoke(app, [
                    ""serve"", str(temp_python_script),
                    ""--no-mcp"", ""--verbose""
                ])
                assert result_rest.exit_code == 1
                assert ""LANGFLOW_API_KEY"" in result_rest.output
",src/backend/tests/unit/test_cli.py,TestMCPServeCommand,1,2.5109990926928157e-08,"The method is a test function that verifies the mutual exclusivity of MCP and REST API modes in a command-line application. It uses mocking and assertions to ensure that MCP mode can run without an API key, while REST API mode requires one. This is a typical and necessary test to ensure the correct behavior of the application, especially in environments where different modes have different requirements. Such tests are crucial for maintaining software quality and are unlikely to be deleted unless the functionality they test is removed or significantly altered."
survived,"    def test_mcp_no_api_key_required(self, runner, temp_python_script):
        """"""Test that MCP mode doesn't require LANGFLOW_API_KEY.""""""
        # Ensure no API key is set
        with patch.dict(""os.environ"", {}, clear=True):
            result = runner.invoke(app, [
                ""serve"", str(temp_python_script),
                ""--mcp"", ""--verbose""
            ])
            
            # Should not fail due to missing API key
            # The validation message should show MCP is enabled
            assert ""MCP mode enabled"" in result.output or result.exit_code in [0, 1]
            # Should not show API key validation error
            assert ""LANGFLOW_API_KEY"" not in result.output
",src/backend/tests/unit/test_cli.py,TestMCPServeCommand,1,1.725782769012759e-08,"The method is a test function that verifies a specific behavior of the application, ensuring that the MCP mode does not require an API key. Test functions are generally crucial for maintaining code quality and ensuring that features work as expected. This particular test checks for the absence of an API key requirement, which is likely an important feature for the application. Therefore, it is unlikely to be deleted as it serves a critical role in validating the application's functionality."
survived,"    def test_run_mcp_server_invalid_transport(self):
        """"""Test running MCP server with invalid transport.""""""
        mock_mcp_instance = MagicMock()

        with pytest.raises(ValueError) as exc_info:
            run_mcp_server(
                mcp_server=mock_mcp_instance,
                transport=""invalid""
            )

        assert ""Unsupported transport: invalid"" in str(exc_info.value)
        assert ""Use 'stdio', 'sse', or 'websocket'"" in str(exc_info.value)
",src/backend/tests/unit/test_mcp_server.py,TestMCPServerRuntime,1,4.0586521248284276e-10,"The method `test_run_mcp_server_invalid_transport` is a unit test designed to verify that the `run_mcp_server` function raises a `ValueError` when an invalid transport type is provided. This is a common and necessary test to ensure that the function handles invalid inputs correctly. The test is well-structured, using mocking and assertions to check for specific error messages, which are crucial for maintaining code quality and robustness. Therefore, this method is likely to be retained as it serves an important role in the testing suite."
survived,"    def test_create_mcp_server_empty_graphs(self, mock_fastmcp):
        """"""Test MCP server creation with empty graphs.""""""
        mock_mcp_instance = MagicMock()
        mock_fastmcp.return_value = mock_mcp_instance

        server = create_mcp_server(
            graphs={},
            metas={},
            server_name=""Empty Server""
        )

        # Should still create server but with no tools
        mock_fastmcp.assert_called_once_with(""Empty Server"")
        assert server == mock_mcp_instance

        # No tools should be registered
        assert mock_mcp_instance.tool.call_count == 0

        # Resources and prompts should still be registered
        assert mock_mcp_instance.resource.call_count >= 3
        assert mock_mcp_instance.prompt.call_count >= 2
",src/backend/tests/unit/test_mcp_server.py,TestMCPServerCreation,1,6.348800075736417e-09,"The method `test_create_mcp_server_empty_graphs` is a unit test designed to verify the behavior of the `create_mcp_server` function when provided with empty graphs. It uses mocking to simulate the behavior of the `create_mcp_server` function and checks that the server is created correctly even when no tools are registered. The test ensures that resources and prompts are still registered, which is a valid scenario to test. Unit tests are generally not deleted unless they are redundant, incorrect, or replaced by more comprehensive tests. This test appears to be well-defined and serves a purpose in ensuring the robustness of the `create_mcp_server` function, so it is likely to be retained."
survived,"    def test_mcp_server_error_handling(self, runner, temp_python_script):
        """"""Test error handling in MCP server creation.""""""
        with patch(""langflow.cli.commands.create_mcp_server"") as mock_create_mcp:
            # Mock an error during MCP server creation
            mock_create_mcp.side_effect = ImportError(""fastmcp not available"")
            
            result = runner.invoke(app, [
                ""serve"", str(temp_python_script),
                ""--mcp"", ""--verbose""
            ])
            
            assert result.exit_code == 1
            assert ""Failed to start MCP server"" in result.output
",src/backend/tests/unit/test_cli.py,TestMCPServeCommand,1,2.3355930333443423e-09,"The method is a unit test designed to ensure that the application correctly handles errors when attempting to create an MCP server. It uses mocking to simulate an ImportError and checks that the application responds appropriately. This is a valuable test for maintaining robust error handling in the application, especially if the MCP server functionality is critical. Therefore, it is likely to be retained to ensure the reliability of the software."
survived,"    def to_dict(self) -> dict[str, Any]:
        """"""Convert the registry entry to a dictionary for Supabase upload.""""""
        return self.model_dump(exclude_none=True, mode=""json"")
",terminal_bench/cli/tb/admin.py,SupabaseRegistry,1,1.1032560311263802e-09,"The method 'to_dict' is a utility function that converts an object to a dictionary format, which is a common requirement for data serialization, especially when interfacing with databases or APIs like Supabase. The use of 'model_dump' suggests that this method is part of a larger framework or library that supports model serialization. Given the increasing need for data interchange formats like JSON, this method is likely to be useful and relevant, thus it will survive."
deleted,"    def test_transform_request_handles_tool_choice_required(self):
        """"""Test that tool_choice 'required' is removed""""""
        config = MoonshotChatConfig()
        
        optional_params = {
            ""tool_choice"": ""required"",
            ""tools"": [{""type"": ""function"", ""function"": {""name"": ""test""}}],
            ""temperature"": 0.7
        }
        
        result = config.transform_request(
            model=""moonshot-v1-8k"",
            messages=[{""role"": ""user"", ""content"": ""test""}],
            optional_params=optional_params,
            litellm_params={},
            headers={}
        )
        
        # tool_choice should be removed when it's ""required""
        assert ""tool_choice"" not in result
        # Tools should remain
        assert result.get(""tools"") is not None
        assert result.get(""temperature"") == 0.7
",tests/test_litellm/llms/moonshot/test_moonshot_chat_transformation.py,TestMoonshotConfig,1,1.725782769012759e-08,"The method is a unit test that verifies the behavior of the `transform_request` function in the `MoonshotChatConfig` class. It checks that the 'tool_choice' parameter is removed when its value is 'required', while other parameters remain unchanged. This is a specific and useful test to ensure the function behaves correctly under certain conditions. Unit tests are generally important for maintaining code quality and ensuring that changes do not introduce bugs. Therefore, it is likely to be retained."
deleted,"    def test_transform_request_removes_functions(self):
        """"""Test that functions parameter is removed from optional_params""""""
        config = MoonshotChatConfig()
        
        optional_params = {
            ""functions"": [{""name"": ""test_function"", ""description"": ""Test function""}],
            ""temperature"": 0.7,
            ""max_tokens"": 1000
        }
        
        result = config.transform_request(
            model=""moonshot-v1-8k"",
            messages=[{""role"": ""user"", ""content"": ""test""}],
            optional_params=optional_params,
            litellm_params={},
            headers={}
        )
        
        # Functions should be removed
        assert ""functions"" not in result
        # Other params should remain
        assert result.get(""temperature"") == 0.7
        assert result.get(""max_tokens"") == 1000
",tests/test_litellm/llms/moonshot/test_moonshot_chat_transformation.py,TestMoonshotConfig,1,1.725782769012759e-08,"The method `test_transform_request_removes_functions` is a unit test that verifies the behavior of the `transform_request` method in the `MoonshotChatConfig` class. It checks that the 'functions' parameter is correctly removed from the `optional_params` dictionary, while other parameters remain unchanged. This is a valid and useful test to ensure the method's functionality, especially if the removal of 'functions' is a critical part of the method's logic. Therefore, the method is likely to be retained as it serves an important role in testing the code's correctness."
survived,"    def transform_request(
        self,
        model: str,
        messages: List[AllMessageValues],
        optional_params: dict,
        litellm_params: dict,
        headers: dict,
    ) -> dict:
        """"""
        Transform the request to handle Moonshot AI specific limitations:
        - tool_choice doesn't support ""required""
        - functions isn't supported at all
        """"""
        # Remove unsupported parameters
        if ""functions"" in optional_params:
            optional_params.pop(""functions"")
        
        # Handle tool_choice limitation - remove ""required"" if present
        if ""tool_choice"" in optional_params and optional_params[""tool_choice""] == ""required"":
            optional_params.pop(""tool_choice"")
            
        # Handle temperature limitation (close to 0 <0.3 can only produce n=1 results)
        if ""temperature"" in optional_params and ""n"" in optional_params:
            temp = optional_params.get(""temperature"", 1.0)
            if temp < 0.3 and optional_params.get(""n"", 1) > 1:
                optional_params[""n""] = 1
        
        return super().transform_request(
            model=model,
            messages=messages,
            optional_params=optional_params,
            litellm_params=litellm_params,
            headers=headers,
        )",litellm/llms/moonshot/chat/transformation.py,MoonshotChatConfig,1,7.582560422162384e-10,"The method 'transform_request' is likely to survive because it contains specific logic to handle limitations of Moonshot AI, which suggests it is tailored for a particular use case. The method includes checks and modifications to the 'optional_params' dictionary to ensure compatibility with Moonshot AI's constraints, such as removing unsupported parameters and adjusting values based on certain conditions. This indicates that the method serves a necessary function in adapting requests to meet specific requirements, making it valuable and less likely to be removed."
survived,"async def trace_transfer_fixture(db: DbSessionFactory) -> dict[str, int]:
    async with db() as session:
        source_project_id = await session.scalar(
            insert(models.Project).values(name=""source-project"").returning(models.Project.id)
        )
        assert source_project_id is not None

        dest_project_id = await session.scalar(
            insert(models.Project).values(name=""dest-project"").returning(models.Project.id)
        )
        assert dest_project_id is not None

        other_project_id = await session.scalar(
            insert(models.Project).values(name=""other-project"").returning(models.Project.id)
        )
        assert other_project_id is not None

        session_id = await session.scalar(
            insert(models.ProjectSession)
            .values(
                session_id=""test-session-1"",
                project_id=source_project_id,
                start_time=datetime.fromisoformat(""2021-01-01T00:00:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:02:00.000+00:00""),
            )
            .returning(models.ProjectSession.id)
        )
        assert session_id is not None

        trace1_id = await session.scalar(
            insert(models.Trace)
            .values(
                trace_id=""test-trace-id-1"",
                project_rowid=source_project_id,
                project_session_rowid=session_id,
                start_time=datetime.fromisoformat(""2021-01-01T00:00:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
            )
            .returning(models.Trace.id)
        )
        assert trace1_id is not None

        span1_id = await session.scalar(
            insert(models.Span)
            .values(
                trace_rowid=trace1_id,
                span_id=""test-span-id-1"",
                parent_id=None,
                name=""test span 1"",
                span_kind=""CHAIN"",
                start_time=datetime.fromisoformat(""2021-01-01T00:00:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
                attributes={
                    ""input"": {""value"": ""test-input"", ""mime_type"": ""text/plain""},
                    ""output"": {""value"": ""test-output"", ""mime_type"": ""text/plain""},
                },
                events=[],
                status_code=""OK"",
                status_message=""okay"",
                cumulative_error_count=0,
                cumulative_llm_token_count_prompt=0,
                cumulative_llm_token_count_completion=0,
            )
            .returning(models.Span.id)
        )
        assert span1_id is not None

        span_cost1_id = await session.scalar(
            insert(models.SpanCost)
            .values(
                span_rowid=span1_id,
                trace_rowid=trace1_id,
                span_start_time=datetime.fromisoformat(""2021-01-01T00:00:00.000+00:00""),
                total_cost=1.50,
                total_tokens=100,
                prompt_cost=1.00,
                prompt_tokens=80,
                completion_cost=0.50,
                completion_tokens=20,
            )
            .returning(models.SpanCost.id)
        )
        assert span_cost1_id is not None

        trace_annotation1_id = await session.scalar(
            insert(models.TraceAnnotation)
            .values(
                trace_rowid=trace1_id,
                name=""test-annotation-1"",
                label=""good"",
                score=0.9,
                explanation=""This is a good trace"",
                metadata_={},
                annotator_kind=""HUMAN"",
                identifier=""test-1"",
                source=""APP"",
            )
            .returning(models.TraceAnnotation.id)
        )
        assert trace_annotation1_id is not None

        trace2_id = await session.scalar(
            insert(models.Trace)
            .values(
                trace_id=""test-trace-id-2"",
                project_rowid=source_project_id,
                project_session_rowid=session_id,
                start_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:02:00.000+00:00""),
            )
            .returning(models.Trace.id)
        )
        assert trace2_id is not None

        span2_id = await session.scalar(
            insert(models.Span)
            .values(
                trace_rowid=trace2_id,
                span_id=""test-span-id-2"",
                parent_id=None,
                name=""test span 2"",
                span_kind=""CHAIN"",
                start_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:02:00.000+00:00""),
                attributes={
                    ""input"": {""value"": ""test-input-2"", ""mime_type"": ""text/plain""},
                    ""output"": {""value"": ""test-output-2"", ""mime_type"": ""text/plain""},
                },
                events=[],
                status_code=""OK"",
                status_message=""okay"",
                cumulative_error_count=0,
                cumulative_llm_token_count_prompt=0,
                cumulative_llm_token_count_completion=0,
            )
            .returning(models.Span.id)
        )
        assert span2_id is not None

        span_cost2_id = await session.scalar(
            insert(models.SpanCost)
            .values(
                span_rowid=span2_id,
                trace_rowid=trace2_id,
                span_start_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
                total_cost=2.00,
                total_tokens=150,
                prompt_cost=1.50,
                prompt_tokens=120,
                completion_cost=0.50,
                completion_tokens=30,
            )
            .returning(models.SpanCost.id)
        )
        assert span_cost2_id is not None

        trace_annotation2_id = await session.scalar(
            insert(models.TraceAnnotation)
            .values(
                trace_rowid=trace2_id,
                name=""test-annotation-2"",
                label=""excellent"",
                score=0.95,
                explanation=""This is an excellent trace"",
                metadata_={},
                annotator_kind=""HUMAN"",
                identifier=""test-2"",
                source=""APP"",
            )
            .returning(models.TraceAnnotation.id)
        )
        assert trace_annotation2_id is not None

        other_trace_id = await session.scalar(
            insert(models.Trace)
            .values(
                trace_id=""test-trace-id-other"",
                project_rowid=other_project_id,
                start_time=datetime.fromisoformat(""2021-01-01T00:00:00.000+00:00""),
                end_time=datetime.fromisoformat(""2021-01-01T00:01:00.000+00:00""),
            )
            .returning(models.Trace.id)
        )
        assert other_trace_id is not None

        return {
            ""source_project_id"": source_project_id,
            ""dest_project_id"": dest_project_id,
            ""other_project_id"": other_project_id,
            ""trace1_id"": trace1_id,
            ""trace2_id"": trace2_id,
            ""other_trace_id"": other_trace_id,
        }",tests/unit/server/api/mutations/test_trace_transfer_mutations.py,,1,2.646573631904765e-09,"The method `trace_transfer_fixture` is a utility function designed to set up a database state for testing purposes. It creates several entries in the database, such as projects, sessions, traces, spans, and annotations, and returns their IDs. This kind of function is typically used in test suites to ensure that the database is in a known state before running tests. Such utility functions are crucial for automated testing and are unlikely to be deleted unless the entire testing strategy changes or the database schema is significantly altered. Therefore, the method is likely to survive."
deleted,"		def current_state_property(self) -> AgentBrain:
			""""""For backward compatibility - returns an AgentBrain with the flattened properties""""""
			return AgentBrain(
				thinking=None,
				evaluation_previous_goal=self.evaluation_previous_goal,
				memory=self.memory,
				next_goal=self.next_goal,
			)
",browser_use/agent/views.py,AgentOutput,0,0.9999999981810384,"The method `current_state_property` is likely to be deleted (0) in the future. The reason is that it is marked as being for ""backward compatibility,"" which suggests that it is a temporary solution to maintain compatibility with older code. As the codebase evolves and older versions are phased out, such backward compatibility methods are often removed to simplify the code and reduce maintenance overhead."
survived,"    async def test_env_group_rubric_unknown_task(self, mock_openai_client):
        """"""Test scoring with unknown task returns zeros.""""""
        env1 = SingleTurnEnv(
            client=mock_openai_client,
            model=""test-model"",
            eval_dataset=Dataset.from_dict({""question"": [""q1""], ""answer"": [""a1""]}),
            rubric=Rubric()
        )
        
        env_map = {""known_task"": env1}
        rubric = EnvGroupRubric(env_map)
        
        result = await rubric.score_rollout(
            prompt=""Test"",
            completion=""Test"",
            task=""unknown_task""
        )
        
        assert result[""reward""] == 0.0
",tests/test_env_group.py,TestEnvGroupRubric,1,4.6911638017642294e-08,The method is a unit test designed to verify that the scoring system correctly returns a zero reward for an unknown task. This is a valid and necessary test case to ensure the robustness of the system when encountering unexpected input. It is unlikely to be deleted as it serves a clear purpose in maintaining the integrity of the scoring logic.
survived,"        def func1(completion, **kwargs):
            return 0.8
",tests/test_env_group.py,TestEnvGroupRubric,0,0.9999989322969233,"The method 'func1' is very simple and returns a constant value (0.8) regardless of the input parameters. This suggests that it might not be very useful or flexible in its current form. Without additional context or usage, it seems like a placeholder or a stub for a more complex function that hasn't been implemented yet. Therefore, it is likely to be deleted or replaced with a more functional implementation in the future."
survived,"    def supported_invocation_parameters(cls) -> list[InvocationParameter]:
        # For Azure OpenAI, we need to handle o1 and o3 models differently
        # They use max_completion_tokens instead of max_tokens
        return [
            BoundedFloatInvocationParameter(
                invocation_name=""temperature"",
                canonical_name=CanonicalParameterName.TEMPERATURE,
                label=""Temperature"",
                default_value=1.0,
                min_value=0.0,
                max_value=2.0,
            ),
            IntInvocationParameter(
                invocation_name=""max_tokens"",
                canonical_name=CanonicalParameterName.MAX_COMPLETION_TOKENS,
                label=""Max Tokens"",
            ),
            BoundedFloatInvocationParameter(
                invocation_name=""frequency_penalty"",
                label=""Frequency Penalty"",
                default_value=0.0,
                min_value=-2.0,
                max_value=2.0,
            ),
            BoundedFloatInvocationParameter(
                invocation_name=""presence_penalty"",
                label=""Presence Penalty"",
                default_value=0.0,
                min_value=-2.0,
                max_value=2.0,
            ),
            StringListInvocationParameter(
                invocation_name=""stop"",
                canonical_name=CanonicalParameterName.STOP_SEQUENCES,
                label=""Stop Sequences"",
            ),
            BoundedFloatInvocationParameter(
                invocation_name=""top_p"",
                canonical_name=CanonicalParameterName.TOP_P,
                label=""Top P"",
                default_value=1.0,
                min_value=0.0,
                max_value=1.0,
            ),
            IntInvocationParameter(
                invocation_name=""seed"",
                canonical_name=CanonicalParameterName.RANDOM_SEED,
                label=""Seed"",
            ),
            JSONInvocationParameter(
                invocation_name=""tool_choice"",
                label=""Tool Choice"",
                canonical_name=CanonicalParameterName.TOOL_CHOICE,
            ),
            JSONInvocationParameter(
                invocation_name=""response_format"",
                label=""Response Format"",
                canonical_name=CanonicalParameterName.RESPONSE_FORMAT,
            ),
        ]
",src/phoenix/server/api/helpers/playground_clients.py,AzureOpenAIStreamingClient,1,5.905303995456778e-10,"The method `supported_invocation_parameters` is likely to survive because it provides a structured way to define and return a list of parameters that are essential for configuring the behavior of an AI model. These parameters, such as temperature, max tokens, and penalties, are commonly used in AI and machine learning applications to control the output of models. The method is well-organized, uses clear naming conventions, and includes a variety of parameter types, indicating it is a well-thought-out and necessary part of the codebase."
deleted,"    def _make_structured_output_call(
        self, 
        model: str, 
        messages: List[Dict[str, str]], 
        output_schema: Dict[str, Any], 
        scratchpad: Optional[str],
        extra_kwargs: Dict[str, Any]
    ) -> Any:
        """"""Make a structured output call.""""""
        schema = OutputSchemaBuilder.build_structured_output_schema(output_schema, scratchpad)
        
        try:
            return completion(
                model=model,
                messages=messages,
                response_format=schema,
                **extra_kwargs,
            )
        except Exception as e:
            self._handle_model_error(model, e)
",docetl/operations/utils/api.py,LLMCallHandler,1,1.1032560311263802e-09,"The method '_make_structured_output_call' is likely to survive because it is a well-defined function that serves a specific purpose in the codebase. It constructs a structured output schema and makes a call to a completion function, handling exceptions appropriately. The method is modular, making it easy to maintain and update, and it uses parameters and error handling effectively, which are good coding practices. Unless there is a significant change in the requirements or architecture that renders this functionality obsolete, it is likely to be retained."
survived,"        def error_func(completion, **kwargs):
            raise ValueError(""Test error"")
",tests/test_rubric.py,TestRubric,1,9.237449576640118e-09,"The method `error_func` is designed to raise a `ValueError` with a specific message whenever it is called. This kind of function is typically used for testing error handling in other parts of the code. Since it serves a specific purpose in testing scenarios, it is likely to be retained in the codebase for those purposes. Therefore, the method will likely survive."
survived,"    def test_environment_with_eval_dataset_only(self, mock_openai_client, sample_dataset):
        """"""Test Environment with only eval_dataset.""""""
        env = TestEnvironment(
            client=mock_openai_client,
            model=""test-model"",
            eval_dataset=sample_dataset,
            parser=Parser(),
            rubric=Rubric()
        )
        assert env.dataset is None
        assert env.eval_dataset is not None
",tests/test_environment.py,TestEnvironmentBase,1,8.76424914819242e-08,"The method `test_environment_with_eval_dataset_only` is a unit test designed to verify the behavior of the `TestEnvironment` class when only an evaluation dataset is provided. Unit tests are crucial for ensuring code reliability and correctness, especially in complex systems. This test checks that the `eval_dataset` is correctly assigned and that the `dataset` is `None`, which are important aspects of the class's functionality. Therefore, it is unlikely that this method will be deleted as it serves a specific purpose in maintaining code quality."
survived,"    def test_format_method_missing_field(self, xml_parser):
        """"""Test format method with missing required field.""""""
        with pytest.raises(ValueError, match=""Missing value for field""):
            xml_parser.format(reasoning=""Only reasoning"")
",tests/test_xml_parser.py,TestXMLParser,1,5.60279640614594e-09,"The method 'test_format_method_missing_field' is a unit test designed to ensure that the 'format' method of 'xml_parser' raises a ValueError when a required field is missing. This is a valid and necessary test case to ensure the robustness of the 'format' method, especially in handling erroneous or incomplete input. Such tests are crucial for maintaining code quality and preventing runtime errors. Therefore, this method is likely to be retained as part of the test suite."
survived,"    async def test_rollout_chat_format(self, mock_singleturn_env):
        """"""Test rollout with chat format.""""""
        prompt = [{""role"": ""user"", ""content"": ""What is 2+2?""}]
        answer = ""4""
        
        completion, state = await mock_singleturn_env.rollout(
            client=mock_singleturn_env.client,
            model=""test-model"",
            prompt=prompt,
            answer=answer
        )
        
        # Should return list format for chat
        assert isinstance(completion, list)
        assert len(completion) == 1
        assert completion[0][""role""] == ""assistant""
        assert completion[0][""content""] == ""This is a test response""
        assert state == {}
        
        # Verify the client was called
        mock_singleturn_env.client.chat.completions.create.assert_called_once()
",tests/test_singleturn_env.py,TestSingleTurnEnv,1,1.3440409770490404e-08,"The method is a test function that verifies the behavior of a chat format rollout in a mock environment. It includes assertions to check the format and content of the response, as well as ensuring that the client method is called. Test methods like this are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained as part of the test suite."
survived,"    def test_get_fields(self, xml_parser, xml_parser_with_alternatives):
        """"""Test getting field names.""""""
        fields1 = xml_parser.get_fields()
        assert fields1 == [""reasoning"", ""answer""]
        
        fields2 = xml_parser_with_alternatives.get_fields()
        assert fields2 == [""reasoning"", ""code""]
",tests/test_xml_parser.py,TestXMLParser,1,1.4166087846364157e-09,"The method 'test_get_fields' is a unit test designed to verify the functionality of the 'get_fields' method in two different XML parser instances. Unit tests are crucial for ensuring code reliability and correctness, especially in larger projects. They help catch bugs early and ensure that changes in the codebase do not break existing functionality. Given the importance of testing in software development, it is unlikely that this method will be deleted unless the functionality it tests is removed or significantly altered. Therefore, the method is likely to survive."
survived,"    def test_rubric_group_add_reward_func(self):
        """"""Test adding reward function to RubricGroup (should add to first rubric).""""""
        def func1(completion, **kwargs):
            return 1.0
        
        def new_func(completion, **kwargs):
            return 0.9
        
        rubric1 = Rubric(funcs=[func1], weights=[1.0])
        rubric2 = Rubric()
        
        group = RubricGroup(rubrics=[rubric1, rubric2])
        
        # Should add to first rubric
        group.add_reward_func(new_func, weight=0.6)
        
        assert len(rubric1.reward_funcs) == 2
        assert len(rubric2.reward_funcs) == 0
        assert rubric1.reward_funcs[1] == new_func
        assert rubric1.reward_weights[1] == 0.6
",tests/test_rubric_group.py,TestRubricGroup,1,1.8553915987649156e-07,"The method is a unit test for a specific functionality of the RubricGroup class, ensuring that a new reward function is added to the first rubric in the group. Unit tests are crucial for verifying that code behaves as expected and are generally not deleted unless the functionality they test is removed or significantly changed. Since this test is specific, clear, and directly related to the functionality of the RubricGroup class, it is likely to be maintained as long as the class and its methods remain relevant."
survived,"def mock_multiturn_env(mock_openai_client, sample_chat_dataset):
    """"""Return a MultiTurnEnv for basic testing.""""""
    return SimpleMultiTurnEnv(
        client=mock_openai_client,
        model=""test-model"",
        dataset=sample_chat_dataset,
        max_turns=3,
        completion_condition=""answer"",
        parser=Parser(),
        rubric=Rubric()
    )
",tests/conftest.py,,1,3.3982678079468468e-09,"The method 'mock_multiturn_env' is a utility function designed for testing purposes. It creates and returns an instance of 'SimpleMultiTurnEnv', which is likely a mock or simplified environment for testing multi-turn interactions with a model. Such utility functions are common in testing frameworks to facilitate the setup of test cases. Since testing is a crucial part of software development, especially for ensuring the reliability of complex systems, this method is likely to be retained as it aids in the testing process. Therefore, it is predicted to survive."
survived,"    def test_think_parser_initialization(self, think_parser):
        """"""Test that ThinkParser initializes correctly.""""""
        assert isinstance(think_parser, ThinkParser)
        assert hasattr(think_parser, 'extract_fn')
",tests/test_think_parser.py,TestThinkParser,1,6.348800075736417e-09,"The method is a unit test for the initialization of a class, which is a common and necessary practice in software development to ensure that objects are created correctly. It checks that the object is an instance of the expected class and that it has a specific attribute, which are both valid and useful tests. Therefore, it is likely to be retained."
survived,"    def test_sanitize_sampling_args_remote_server(self, mock_openai_client):
        """"""Test sampling args sanitization for remote servers.""""""
        mock_openai_client.base_url = ""https://api.openai.com/v1/""
        
        env = TestEnvironment(
            client=mock_openai_client,
            model=""test-model"",
            eval_dataset=Dataset.from_dict({""question"": [""test""], ""answer"": [""test""]}),
            parser=Parser(),
            rubric=Rubric()
        )
        
        sampling_args = {
            ""temperature"": 0.7,
            ""extra_body"": {""skip_special_tokens"": True}
        }
        
        sanitized = env.sanitize_sampling_args(mock_openai_client, sampling_args)
        
        assert ""temperature"" in sanitized
        assert ""extra_body"" not in sanitized
",tests/test_environment.py,TestEnvironmentBase,1,3.927863699585036e-07,"The method 'test_sanitize_sampling_args_remote_server' is a unit test designed to verify the functionality of the 'sanitize_sampling_args' method. Unit tests are crucial for ensuring code reliability and correctness, especially when dealing with external APIs or complex logic. The presence of this test indicates that the 'sanitize_sampling_args' method is important for the application's functionality, and the test itself helps maintain the integrity of this method. Therefore, it is unlikely that this test method will be deleted as it serves a critical role in the development and maintenance process."
survived,"def sample_dataset():
    """"""Return a sample dataset for testing.""""""
    return Dataset.from_dict({
        ""question"": [""What is 2+2?"", ""What is the capital of France?""],
        ""answer"": [""4"", ""Paris""]
    })
",tests/conftest.py,,1,8.592166611791576e-10,"The method 'sample_dataset' is a utility function that provides a sample dataset for testing purposes. Such methods are often useful in development and testing environments to quickly generate data without needing to manually create it each time. This can be particularly helpful in unit tests or when demonstrating functionality. Since it serves a clear purpose and can be reused across different parts of a codebase, it is likely to be retained. Therefore, the method will likely survive."
survived,"    def test_parse_without_think_tags(self, think_parser):
        """"""Test parsing text without think tags.""""""
        text = ""Just a simple answer without thinking tags.""
        result = think_parser.parse(text)
        assert result == text
",tests/test_think_parser.py,TestThinkParser,1,3.3982678079468468e-09,"The method `test_parse_without_think_tags` is a unit test designed to verify that the `think_parser` correctly handles text that does not contain 'think tags'. This is a straightforward and useful test case to ensure the parser behaves as expected in this scenario. Unit tests are crucial for maintaining code quality and ensuring that changes do not introduce regressions. Therefore, this method is likely to be retained as part of the test suite."
survived,"    def test_parse_answer_integration(self, think_parser):
        """"""Test parse_answer method inherited from Parser.""""""
        completion = [
            {""role"": ""user"", ""content"": ""What is 2+2?""},
            {""role"": ""assistant"", ""content"": ""<think>Let me calculate</think>The answer is 4""}
        ]
        result = think_parser.parse_answer(completion)
        assert result == ""The answer is 4""
",tests/test_think_parser.py,TestThinkParser,1,2.646573631904765e-09,"The method `test_parse_answer_integration` is a unit test for the `parse_answer` method of the `think_parser` object. Unit tests are crucial for ensuring that code behaves as expected, especially when changes are made. This test checks if the `parse_answer` method correctly extracts the answer from a structured input. Since testing is an essential part of software development and maintenance, this method is likely to be retained to ensure the reliability of the `parse_answer` functionality."
survived,"    def test_parse_answer_with_string(self, basic_parser):
        """"""Test parse_answer with string input.""""""
        text = ""This is an answer""
        result = basic_parser.parse_answer(text)
        assert result == text
",tests/test_parser.py,TestParser,1,3.160881453314576e-10,"The method `test_parse_answer_with_string` is a unit test designed to verify the functionality of the `parse_answer` method in the `basic_parser` object. It checks if the method correctly returns the input string as expected. Unit tests are crucial for ensuring code reliability and are typically retained to maintain code quality. Therefore, this method is likely to be Survived."
survived,"def mock_singleturn_env(mock_openai_client, sample_dataset):
    """"""Return a SingleTurnEnv with mocked client and dataset.""""""
    return SingleTurnEnv(
        client=mock_openai_client,
        model=""test-model"",
        dataset=sample_dataset,
        system_prompt=""You are a helpful assistant."",
        parser=Parser(),
        rubric=Rubric()
    )
",tests/conftest.py,,1,1.522997951276035e-08,"The method 'mock_singleturn_env' is a utility function designed to create a mock environment for testing purposes. Such methods are typically retained in codebases because they facilitate testing by providing a controlled environment to simulate interactions with external systems or components. This is especially useful in development and testing phases to ensure that the main functionality works as expected without relying on actual external dependencies. Therefore, it is likely to be retained."
survived,"def diff_instance(mock_config):
    """"""
    Factory fixture to create Diff instances with specific cache configurations.

    Returns a function that creates Diff instances.
    """"""

    def create_diff(package_map, dependencies=None, url_map=None, package_urls=None):
        cache = Cache(
            package_map=package_map,
            url_map=url_map or {},
            package_urls=package_urls or {},
            dependencies=dependencies or {},
        )
        return Diff(mock_config, cache)

    return create_diff
",tests/package_managers/homebrew/test_diff_dep.py,,1,4.944450477491054e-09,"The method 'diff_instance' is a factory fixture designed to create instances of the 'Diff' class with specific cache configurations. This is a common pattern in testing and configuration management, where flexibility and reusability are important. The method is likely to be useful in various testing scenarios where different configurations of 'Diff' instances are needed. Therefore, it is likely to be retained in the codebase."
survived,"def package_ids():
    """"""Fixture providing consistent package IDs for testing.""""""
    return {
        ""main"": uuid4(),
        ""dep"": uuid4(),
    }
",tests/package_managers/crates/test_diff_deps.py,,1,8.152020648014727e-09,"The method `package_ids` is a fixture function that provides consistent package IDs for testing purposes. It is likely part of a test suite, possibly using a framework like pytest. Such functions are crucial for ensuring that tests have predictable and repeatable inputs, which is a fundamental aspect of reliable testing. Since testing is an essential part of software development, especially in maintaining code quality and reliability, this method is likely to be retained. It provides a clear utility by generating unique identifiers for packages, which can be used to simulate different scenarios in tests. Therefore, the method is expected to survive."
survived,"def ids():
    """"""Fixture providing consistent IDs for testing.""""""
    return {
        ""homepage_url_type"": uuid4(),
        ""package_manager"": uuid4(),
        ""pkg1"": uuid4(),
        ""pkg2"": uuid4(),
        ""pkg3"": uuid4(),
        ""canon1"": uuid4(),
        ""canon2"": uuid4(),
        ""canon3"": uuid4(),
        ""url1"": uuid4(),
        ""url2"": uuid4(),
        ""url3"": uuid4(),
    }
",tests/ranker/test_dedupe.py,,1,2.3355930333443423e-09,"The method 'ids' is a fixture function that provides a set of unique identifiers (UUIDs) for testing purposes. This is a common practice in software development to ensure that tests have consistent and unique data to work with. The use of UUIDs helps in avoiding collisions and ensures that each test run is isolated from others. Such utility functions are crucial for maintaining reliable and repeatable tests, especially in larger codebases. Therefore, the method is likely to be retained as it serves a valuable purpose in the testing framework."
survived,"def mock_dependency_types():
    """"""
    Mock dependency types for testing.

    Returns a mock DependencyTypes object with common dependency types.
    """"""
    dep_types = MagicMock(spec=DependencyTypes)

    # Set up dependency type attributes directly
    dep_types.runtime = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000010""))
    dep_types.build = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000011""))
    dep_types.dev = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000012""))
    dep_types.test = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000013""))
    dep_types.development = dep_types.dev  # Alias for development
    dep_types.recommended = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000014""))
    dep_types.optional = Mock(id=uuid.UUID(""00000000-0000-0000-0000-000000000015""))

    return dep_types
",tests/conftest.py,,1,4.944450477491054e-09,"The method `mock_dependency_types` is a utility function designed to create a mock object for testing purposes. It sets up a mock `DependencyTypes` object with various common dependency types, each represented by a unique UUID. This kind of function is typically used in unit tests to simulate and test the behavior of code that depends on `DependencyTypes` without requiring the actual implementation. Such utility functions are often retained in codebases because they facilitate testing and improve code reliability. Therefore, it is likely to survive."
survived,"def mock_pm_config(mock_package_managers):
    """"""
    Mock PMConf (Package Manager Configuration) for testing.

    Returns a mock PMConf object with a default package manager ID.
    """"""
    pm_config = MagicMock(spec=PMConf)
    pm_config.pm_id = mock_package_managers.crates.id
    return pm_config
",tests/conftest.py,,1,6.348800075736417e-09,"The method 'mock_pm_config' is a utility function designed for testing purposes. It creates a mock object for a package manager configuration, which is a common practice in software testing to simulate and control the behavior of complex systems. Such methods are typically retained in codebases because they facilitate unit testing by allowing developers to test components in isolation without relying on actual implementations. Therefore, it is likely to survive as it serves a useful purpose in the testing framework."
survived,"def parallel_map_sample_data():
    return [
        {""text"": ""This is a positive sentence.""},
        {""text"": ""This is a negative sentence.""},
        {""text"": ""This is a neutral sentence.""},
    ]
",tests/basic/test_basic_parallel_map.py,,1,8.152020648014727e-09,"The method `parallel_map_sample_data` is a simple function that returns a list of dictionaries, each containing a text string. This function is straightforward and serves a clear purpose of providing sample data, likely for testing or demonstration purposes. Such utility functions are often kept in codebases for ease of testing and development, especially if they are used in examples or documentation. Therefore, it is likely to be retained in the codebase."
survived,"    def test_send_email_to_multiple_recipients(self, mock_smtp_class, smtp_provider):
        """"""Test sending an email to multiple recipients.""""""
        # Setup mock SMTP instance
        mock_smtp = MagicMock()
        mock_smtp_class.return_value = mock_smtp

        recipients = [""recipient1@example.com"", ""recipient2@example.com""]
        
        # Send HTML email to multiple recipients
        result = smtp_provider._notify(
            from_email=""sender@example.com"",
            from_name=""Test Sender"",
            to_email=recipients,
            subject=""Test Multi-recipient"",
            html=""<p>Email to multiple recipients</p>"",
        )

        # Verify email was sent
        mock_smtp.sendmail.assert_called_once()
        call_args = mock_smtp.sendmail.call_args
        assert call_args[0][0] == ""sender@example.com""
        assert call_args[0][1] == recipients
        
        # Verify the To header contains all recipients
        email_content = call_args[0][2]
        assert ""To: recipient1@example.com, recipient2@example.com"" in email_content
        
        # Verify return value
        assert result == {
            ""from"": ""sender@example.com"",
            ""to"": recipients,
            ""subject"": ""Test Multi-recipient"",
            ""html"": ""<p>Email to multiple recipients</p>"",
        }
",tests/test_smtp_provider.py,TestSmtpProvider,1,1.0467401685178159e-08,"The method `test_send_email_to_multiple_recipients` is a unit test designed to verify the functionality of sending an email to multiple recipients using a mock SMTP provider. Unit tests are crucial for ensuring code reliability and are typically retained in the codebase to maintain test coverage and facilitate future development. The method is well-structured, uses mock objects effectively, and includes assertions to verify the expected behavior, making it a valuable part of the test suite."
survived,"def save_results(python_results: List[BenchmarkResult], rust_results: List[BenchmarkResult], 
                output_file: str):
    """"""Save benchmark results to a JSON file.""""""
    results = {
        ""timestamp"": datetime.now().isoformat(),
        ""python"": [r.to_dict() for r in python_results],
        ""rust"": [r.to_dict() for r in rust_results]
    }
    
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    console.print(f""Results saved to [bold]{output_file}[/bold]"")
",benchmarks/benchmark.py,,1,4.599055376537186e-10,"The method 'save_results' is well-defined and serves a clear purpose of saving benchmark results to a JSON file. It uses standard libraries and practices, such as converting objects to dictionaries and writing to a file in JSON format. Additionally, it provides user feedback by printing a confirmation message. There are no apparent issues or redundancies that would necessitate its deletion. Therefore, it is likely to be retained in the codebase."
survived,"def make_request(url: str, method: str, path: str, data: Optional[Dict] = None,
                headers: Optional[Dict] = None) -> Tuple[float, bool]:
    """"""Make a single HTTP request and return the latency and success status.""""""
    full_url = f""{url}{path}""
    headers = headers or {}
    
    start_time = time.time()
    try:
        if method.upper() == ""GET"":
            response = requests.get(full_url, headers=headers, timeout=5)
        elif method.upper() == ""POST"":
            response = requests.post(full_url, json=data, headers=headers, timeout=5)
        else:
            raise ValueError(f""Unsupported HTTP method: {method}"")
        
        success = 200 <= response.status_code < 300
    except Exception:
        success = False
    
    end_time = time.time()
    latency = (end_time - start_time) * 1000  # Convert to ms
    
    return latency, success
",benchmarks/benchmark.py,,1,5.905303995456778e-10,"The method 'make_request' is a utility function for making HTTP requests, which is a common requirement in many applications. It is well-structured, handles both GET and POST requests, and includes error handling for unsupported methods and exceptions during the request. Additionally, it returns useful information: the latency and success status of the request. These features make it a versatile and reusable function, increasing its likelihood of being retained in the codebase."
survived,"    async def get_aggregated_balances(self, parameters: dict):
        """"""Get token balances and allowances for a wallet address on a specific chain.""""""
        wallet_address = parameters.get(""wallet_address"")
        if not wallet_address:
            raise ValueError(""wallet_address is required"")
            
        chain_id = parameters.get(""chain_id"", 1)  # Default to Ethereum mainnet

        url = f""{self.base_url}/balance/v1.2/{chain_id}/balances/{wallet_address}""

        headers = {
            ""Accept"": ""application/json""
        }
        if self.api_key:
            headers[""Authorization""] = f""Bearer {self.api_key}""

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if not response.ok:
                    raise Exception(f""Failed to fetch balances: {response.status} {await response.text()}"")
                return await response.json()",python/src/plugins/1inch/goat_plugins/oneinch/service.py,OneInchService,1,4.0586521248284276e-10,"The method 'get_aggregated_balances' is well-defined and serves a clear purpose of fetching token balances and allowances for a wallet address on a specific blockchain. It includes error handling for missing parameters and unsuccessful API responses, making it robust. Additionally, it uses asynchronous programming, which is beneficial for I/O-bound operations like network requests. These factors suggest that the method is useful and likely to be retained."
survived,"    def __init__(self, options: DexscreenerPluginOptions):
        super().__init__(""dexscreener"", [DexscreenerService()])
",python/src/plugins/dexscreener/goat_plugins/dexscreener/__init__.py,DexscreenerPlugin,1,1.1253518384332553e-07,"The method is a constructor for a class that initializes an instance with a specific plugin name and a service. This is a fundamental part of object-oriented programming, especially in frameworks or systems that rely on plugins or services. Such methods are essential for setting up the initial state of an object and are unlikely to be removed unless the entire class or its purpose is deprecated."
survived,"    def supports_chain(self, chain) -> bool:
        # farcaster is chain-agnostic
        return True
",python/src/plugins/farcaster/goat_plugins/farcaster/__init__.py,FarcasterPlugin,1,5.211412485172657e-10,"The method 'supports_chain' is simple and straightforward, returning a constant value of True. This suggests that the method is designed to indicate that the system is chain-agnostic, meaning it supports any chain. Such a method is likely to be retained because it provides a clear and consistent response that aligns with the system's design philosophy. Unless there is a change in the system's requirements or design that necessitates specifying supported chains, this method will likely survive."
survived,"    async def search_casts(self, parameters: dict):
        url = f""{self.base_url}/cast/search""
        return await self._make_request(""GET"", url, params={
            ""q"": parameters['query'],
            ""limit"": parameters.get('limit', 20)
        })
",python/src/plugins/farcaster/goat_plugins/farcaster/service.py,FarcasterService,1,1.6918979223288786e-10,"The method 'search_casts' is likely to survive because it is a well-defined asynchronous function that performs a specific task: searching for casts using a query parameter. It uses a base URL and makes a GET request with optional parameters, which is a common pattern in API interaction. The method is useful for applications that need to search and retrieve cast information, and there is no indication of redundancy or obsolescence in its functionality."
survived,"    def __init__(self, options: FarcasterPluginOptions):
        super().__init__(""farcaster"", [FarcasterService(options.api_key, options.base_url)])
",python/src/plugins/farcaster/goat_plugins/farcaster/__init__.py,FarcasterPlugin,1,3.653482080241728e-08,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects and setting up initial states. This particular constructor is initializing a superclass and setting up a service with provided options, which is a common pattern in plugin or service-based architectures. There is no indication that this method is redundant or unnecessary, so it is likely to be retained."
deleted,"def retrieve_stock_data(ticker: str, days: int = 30) -> tuple[float, float]:
    end_date = datetime.today()
    start_date = end_date - timedelta(days=days)
    data = yf.download(ticker, start=start_date, end=end_date)
    current_price = data['Close'].iloc[-1]
    start_price = data['Close'].iloc[0]
    percent_change = ((current_price - start_price) / start_price) * 100
    return current_price, percent_change
",financial_analysis/functions.py,,1,4.0586521248284276e-10,"The method 'retrieve_stock_data' is likely to survive because it provides a useful functionality of fetching stock data for a given ticker symbol over a specified number of days. It calculates the percentage change in stock price, which is a common requirement in financial analysis. The use of the 'yfinance' library to download stock data is a standard approach, and the method is well-structured with clear input parameters and a meaningful return value. Additionally, the method is concise and leverages Python's datetime and timedelta for date calculations, which are appropriate for this context."
survived,"    def __init__(self, jwt_token: str = """"):
        self.jwt_token = jwt_token
        self.base_url = ""https://api.rugcheck.xyz/v1""
",python/src/plugins/rugcheck/goat_plugins/rugcheck/service.py,RugCheckService,1,1.8189616842444243e-09,"The method is a constructor for a class, initializing important attributes like 'jwt_token' and 'base_url'. These attributes are likely essential for the functionality of the class, especially if it interacts with an API. Constructors are fundamental to class design, and unless there's a significant change in the class's purpose or structure, they are rarely deleted. Therefore, it is likely to survive."
survived,"    async def _make_request(self, endpoint: str):
        headers = {
            ""Content-Type"": ""application/json"",
        }
        if self.jwt_token:
            headers[""Authorization""] = f""Bearer {self.jwt_token}""
        async with aiohttp.ClientSession() as session:
            url = f""{self.base_url}{endpoint}""
            async with session.get(url, headers=headers) as response:
                if not response.ok:
                    if response.status == 429:
                        raise Exception(""RugCheck API rate limit exceeded"")
                    raise Exception(f""RugCheck API request failed: {response.status}"")
                return await response.json()
",python/src/plugins/rugcheck/goat_plugins/rugcheck/service.py,RugCheckService,1,2.1724399346070676e-10,"The method '_make_request' is likely to survive because it is a well-structured asynchronous function that handles HTTP GET requests using the aiohttp library. It includes essential features such as setting headers, including authorization if a JWT token is present, and error handling for unsuccessful responses, including specific handling for rate limiting. These are common and necessary functionalities for making API requests in modern applications, suggesting that the method is useful and likely to be retained."
survived,"    def _get_master_metadata(self, connector: Connector) -> Optional[Dict[str, Any]]:
        """"""Get the metadata from the master branch.""""""
        response = requests.get(self._get_github_master_metadata_url(connector))
        
        if not response.ok:
            return None
        return yaml.safe_load(response.text)
",airbyte-ci/connectors/connectors_qa/src/connectors_qa/checks/version.py,VersionCheck,1,1.2501528648238603e-09,"The method '_get_master_metadata' is likely to survive because it performs a specific and useful function: fetching metadata from a master branch using a connector. It handles HTTP requests and processes the response, which is a common and necessary operation in many applications. Additionally, it includes error handling by checking if the response is not okay, returning None in such cases. This makes the method robust and reliable, increasing its chances of being retained in the codebase."
survived,"    def _messages_into(self, messages: List[common.Message]) -> List[Dict[str, Any]]:
        ollama_messages = []
        for message in messages:
            content_parts = []
            tool_calls = []
            
            for block in message.content:
                if isinstance(block, common.TextRaw):
                    content_parts.append(block.text)
                elif isinstance(block, common.ToolUse):
                    tool_calls.append({
                        ""type"": ""function"",
                        ""function"": {
                            ""name"": block.name,
                            ""arguments"": block.input
                        }
                    })
                elif isinstance(block, common.ToolResult):
                    content_parts.append(f""Tool result: {block.content}"")
            
            ollama_message: Dict[str, Any] = {
                ""role"": message.role,
                ""content"": "" "".join(content_parts) if content_parts else """"
            }
            
            if tool_calls:
                ollama_message[""tool_calls""] = tool_calls
                
            ollama_messages.append(ollama_message)
        
        return ollama_messages
",agent/llm/ollama_client.py,OllamaLLM,1,5.211412485172657e-10,"The method '_messages_into' is a utility function that processes a list of 'Message' objects and converts them into a specific dictionary format. This kind of transformation is often necessary when preparing data for further processing or for interfacing with other systems. The method is well-structured, handles different types of message content, and constructs a clear output format. There is no indication that this method is redundant or poorly implemented, and it seems to serve a clear purpose in the context of data transformation. Therefore, it is likely to be retained in the codebase."
deleted,"def test_scrape_options_with_parse_pdf():
    if TEST_API_KEY:
        from firecrawl.firecrawl import ScrapeOptions
        app = FirecrawlApp(api_url=API_URL, api_key=TEST_API_KEY)
        scrape_options = ScrapeOptions(parsePDF=False, formats=['markdown'])
        response = app.search(""firecrawl"", limit=1, scrape_options=scrape_options)
        assert response is not None
        assert 'data' in response
",apps/python-sdk/firecrawl/__tests__/v1/e2e_withAuth/test.py,,1,1.0467401685178159e-08,"The method `test_scrape_options_with_parse_pdf` is a test function that checks the functionality of the `ScrapeOptions` class and the `search` method of the `FirecrawlApp` class. It is likely to survive because it serves as a unit test to ensure that the `ScrapeOptions` with `parsePDF` set to `False` and `formats` set to `['markdown']` works correctly. Test functions are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Unless the functionality being tested is deprecated or the testing framework is changed, this method is likely to be retained."
survived,"    def forward(self, x):
        x = self.conv1(x)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.maxpool(x)

        x = self.layer1(x)
        x = self.layer2(x)
        x = self.layer3(x)
        x = self.layer4(x)

        x = self.avgpool(x)
        x = x.view(x.size(0), -1)

        x = self.linear_reg(x)        
        out = utils.compute_rotation_matrix_from_ortho6d(x)

        return out
",face_recognition/6d_repnet_360/convert_to_onnx.py,SixDRepNet360,1,1.2501528648238603e-09,"The method appears to be a part of a neural network model, likely a convolutional neural network (CNN) used for tasks such as image classification or feature extraction. The method includes standard layers such as convolution, batch normalization, ReLU activation, and pooling, followed by a linear regression layer and a utility function to compute a rotation matrix. This suggests that the method is functional and serves a specific purpose in the model's architecture. There is no indication of redundancy or obsolescence, so it is likely to be retained."
survived,"def parse_det(det):
    landmarks = det[5:].reshape(5, 2)
    box = det[:4]
    score = det[4]
    return box, landmarks, score",face_recognition/6d_repnet_360/utils_6d_repnet_360/functions.py,,1,2.646573631904765e-09,"The method 'parse_det' is a utility function that extracts and reshapes data from a detection result. It is concise, performs a clear task, and is likely used in a larger context where detection results need to be parsed into bounding boxes, landmarks, and scores. Such utility functions are common in image processing and machine learning pipelines, and unless there is a change in the data structure or a more efficient method is introduced, this function is likely to be retained."
survived,"    def forward(self):
        anchors = []
        for k, f in enumerate(self.feature_maps):
            min_sizes = self.min_sizes[k]
            for i, j in product(range(f[0]), range(f[1])):
                for min_size in min_sizes:
                    s_kx = min_size / self.image_size[1]
                    s_ky = min_size / self.image_size[0]
                    dense_cx = [
                        x * self.steps[k] / self.image_size[1] for x in [j + 0.5]
                    ]
                    dense_cy = [
                        y * self.steps[k] / self.image_size[0] for y in [i + 0.5]
                    ]
                    for cy, cx in product(dense_cy, dense_cx):
                        anchors += [cx, cy, s_kx, s_ky]

        output = np.array(anchors).reshape(-1, 4)
        if self.clip:
            output.clamp_(max=1, min=0)
        return output
",face_recognition/6d_repnet_360/utils_6d_repnet_360/functions.py,PriorBox,1,9.237449576640118e-09,"The method 'forward' is a crucial part of a neural network model, likely related to object detection or similar tasks, where it generates anchor boxes based on feature maps. This is a common operation in models like SSD (Single Shot MultiBox Detector) or similar architectures. The method is well-structured and performs a necessary function for the model's operation, indicating it is unlikely to be removed unless the entire model architecture is changed. Therefore, it is more likely to survive."
survived,"    def __init__(self, block, layers, fc_layers=1):
        self.inplanes = 64
        super(SixDRepNet360, self).__init__()
        self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3,
                               bias=False)
        self.bn1 = nn.BatchNorm2d(64)
        self.relu = nn.ReLU(inplace=True)
        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
        self.layer1 = self._make_layer(block, 64, layers[0])
        self.layer2 = self._make_layer(block, 128, layers[1], stride=2)
        self.layer3 = self._make_layer(block, 256, layers[2], stride=2)
        self.layer4 = self._make_layer(block, 512, layers[3], stride=2)
        self.avgpool = nn.AvgPool2d(7)

        self.linear_reg = nn.Linear(512*block.expansion,6)
      
        for m in self.modules():
            if isinstance(m, nn.Conv2d):
                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
                m.weight.data.normal_(0, (2. / n) ** 0.5)
            elif isinstance(m, nn.BatchNorm2d):
                m.weight.data.fill_(1)
                m.bias.data.zero_()
",face_recognition/6d_repnet_360/convert_to_onnx.py,SixDRepNet360,1,1.8553915987649156e-07,"The method is a constructor for a neural network class, initializing layers and setting up the architecture. It is essential for the class to function correctly, as it defines the structure of the network, including convolutional layers, batch normalization, activation functions, and pooling layers. Such constructors are fundamental in defining models in deep learning frameworks like PyTorch, and there is no indication that this method is redundant or unnecessary. Therefore, it is unlikely to be deleted."
survived,"def convert_to_onnx():
    model_path = download_model()
    
    model = SixDRepNet360(torchvision.models.resnet.Bottleneck, [3, 4, 6, 3], 6)
    
    saved_state_dict = torch.load(model_path, map_location='cpu')
    if 'model_state_dict' in saved_state_dict:
        model.load_state_dict(saved_state_dict['model_state_dict'])
    else:
        model.load_state_dict(saved_state_dict)
    
    model.eval()
    
    dummy_input = torch.randn(1, 3, 224, 224)
    
    onnx_path = ""6DRepNet360.onnx""
    torch.onnx.export(
        model,
        dummy_input,
        onnx_path,
        export_params=True,
        opset_version=11,
        do_constant_folding=True,
        input_names=['input'],
        output_names=['output'],
        dynamic_axes={
            'input': {0: 'batch_size'},
            'output': {0: 'batch_size'}
        }
    )
    
    print(f""Model converted to ONNX: {onnx_path}"")
    
    import onnx
    onnx_model = onnx.load(onnx_path)
    onnx.checker.check_model(onnx_model)
    print(""ONNX model validation passed"")
    
    return onnx_path
",face_recognition/6d_repnet_360/convert_to_onnx.py,,1,8.152020648014727e-09,"The method 'convert_to_onnx' is a complete and functional implementation for converting a PyTorch model to the ONNX format. It includes downloading the model, loading the state dictionary, setting the model to evaluation mode, creating a dummy input, exporting the model to ONNX, and validating the ONNX model. This functionality is essential for deploying models in environments that support ONNX, making it a valuable utility function. Therefore, it is likely to be retained in the codebase."
survived,"    def __init__(self):
        """"""Initializes the docling document converter with forced OCR enabled for macOS.""""""
        try:
            # --- Converter WITHOUT OCR (fast path) ---
            pipeline_no_ocr = PdfPipelineOptions()
            pipeline_no_ocr.do_ocr = False
            format_no_ocr = {
                InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_no_ocr)
            }
            self.converter_no_ocr = DoclingConverter(format_options=format_no_ocr)

            # --- Converter WITH OCR (fallback) ---
            pipeline_ocr = PdfPipelineOptions()
            pipeline_ocr.do_ocr = True
            ocr_options = OcrMacOptions(force_full_page_ocr=True)
            pipeline_ocr.ocr_options = ocr_options
            format_ocr = {
                InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_ocr)
            }
            self.converter_ocr = DoclingConverter(format_options=format_ocr)
            
            self.converter_general = DoclingConverter()

            print(""docling DocumentConverter(s) initialized (OCR + no-OCR + general)."")
        except Exception as e:
            print(f""Error initializing docling DocumentConverter(s): {e}"")
            self.converter_no_ocr = None
            self.converter_ocr = None
            self.converter_general = None
",rag_system/ingestion/document_converter.py,DocumentConverter,1,3.0590235908148916e-07,"The method is an initializer for a class, which is a fundamental part of object-oriented programming. It sets up the necessary components for the class to function correctly, including handling exceptions to ensure robustness. Initializers are rarely deleted unless the class itself is being removed or significantly refactored, which is not indicated here. The method is well-structured, providing both OCR and non-OCR conversion options, which suggests it is a necessary part of the class's functionality."
survived,"        def _pdf_has_text(path: str) -> bool:
            try:
                doc = fitz.open(path)
                for page in doc:
                    if page.get_text(""text"").strip():
                        return True
            except Exception:
                pass
            return False
",rag_system/ingestion/document_converter.py,DocumentConverter,1,2.0611536181902033e-09,"The method `_pdf_has_text` is a utility function that checks if a PDF file contains any text. It uses the `fitz` library (PyMuPDF) to open the PDF and iterate through its pages, checking for text content. This is a useful function for many applications that need to process or filter PDFs based on their content. The method is simple, effective, and handles exceptions gracefully, making it robust for various use cases. Therefore, it is likely to be retained in the codebase."
survived,"def test_mistral_integration():
    """"""Integration test demonstrating all four Mistral call patterns:
    1. Sync (non-streaming)
    2. Sync (streaming)
    3. Async (non-streaming)
    4. Async (streaming)

    Verifies that AgentOps correctly tracks all LLM calls via analytics.
    """"""
    # Initialize AgentOps without auto-starting session
    agentops.init(auto_start_session=False)
    session = agentops.start_session()

    # Initialize client and provider
    client = MistralClient(api_key=os.getenv(""MISTRAL_API_KEY""))
    from agentops.llms.providers.mistral import MistralProvider
    provider = MistralProvider(client)
    provider.override()
    
    # Pass session to provider
    provider.client = session

    def sync_no_stream():
        client.chat(
            model=""mistral-tiny"",
            messages=[ChatMessage(role=""user"", content=""Hello from sync no stream"")]
        )

    async def sync_stream():
        stream_response = await client.chat_stream(
            model=""mistral-tiny"",
            messages=[ChatMessage(role=""user"", content=""Hello from sync streaming"")]
        )
        async for chunk in stream_response:
            _ = chunk.delta.content if hasattr(chunk.delta, 'content') else ''

    async def async_no_stream():
        # Mistral doesn't have async methods, use sync
        client.chat(
            model=""mistral-tiny"",
            messages=[ChatMessage(role=""user"", content=""Hello from async no stream"")]
        )

    async def async_stream():
        stream_response = await client.chat_stream(
            model=""mistral-tiny"",
            messages=[ChatMessage(role=""user"", content=""Hello from async streaming"")]
        )
        async for chunk in stream_response:
            _ = chunk.delta.content if hasattr(chunk.delta, 'content') else ''

    async def run_async_tests():
        await async_no_stream()
        await async_stream()

    # Call each function with proper error handling
    try:
        sync_no_stream()
        asyncio.run(sync_stream())
        asyncio.run(run_async_tests())
    except Exception as e:
        print(f""Error during Mistral test: {str(e)}"")
        raise

    session.end_session(""Success"")
    analytics = session.get_analytics()
    print(analytics)
    # Verify that all LLM calls were tracked
    assert analytics[""LLM calls""] >= 4, f""Expected at least 4 LLM calls, but got {analytics['LLM calls']}""
",tests/core_manual_tests/providers/mistral_canary.py,,1,1.522997951276035e-08,"The method `test_mistral_integration` is a comprehensive integration test that demonstrates the use of different call patterns with the Mistral API. It is well-structured, includes error handling, and verifies the functionality of the system by checking analytics. Such tests are crucial for ensuring the reliability and correctness of integrations with external services. Therefore, it is unlikely to be deleted as it serves an important purpose in the codebase."
survived,"    async def async_no_stream():
        await async_anthropic_client.messages.create(
            max_tokens=1024,
            model=""claude-3-5-sonnet-20240620"",
            messages=[
                {
                    ""role"": ""user"",
                    ""content"": ""Hello from async no stream"",
                }
            ],
            session=session
        )
",tests/core_manual_tests/providers/anthropic_canary.py,,0,0.9999999981810384,"The method `async_no_stream` is likely to be deleted (0) because it contains a call to `async_anthropic_client.messages.create` with a specific model version `claude-3-5-sonnet-20240620`. This suggests that the method is tied to a specific version of a model, which may become outdated or deprecated over time. Additionally, the method does not return any value or perform any operations with the response, indicating it might be a placeholder or incomplete implementation. Without further context or usage, it seems like a candidate for deletion."
survived,"    async def get_token_balance_by_mint_address(self, wallet_client: SolanaWalletClient, parameters: dict):
        """"""Get token balance for a specific mint address.""""""
        try:
            mint_pubkey = Pubkey.from_string(parameters[""mintAddress""])
            wallet_pubkey = Pubkey.from_string(parameters[""walletAddress""])
            
            token_account = get_associated_token_address(
                wallet_pubkey,
                mint_pubkey
            )
            
            # Check if account exists
            account_info = wallet_client.client.get_account_info(token_account)
            if not account_info.value:
                return 0
            
            # Get balance
            balance = wallet_client.client.get_token_account_balance(
                token_account,
                commitment=Confirmed
            )
            
            return balance.value
        except Exception as error:
            raise Exception(f""Failed to get token balance: {error}"")
",python/src/plugins/spl_token/goat_plugins/spl_token/service.py,SplTokenService,1,8.592166611791576e-10,"The method 'get_token_balance_by_mint_address' is likely to survive because it provides a useful functionality of retrieving the token balance for a specific mint address, which is a common requirement in blockchain applications. The method is well-structured, handles exceptions, and uses asynchronous programming, which is suitable for network operations. Additionally, it uses clear and descriptive variable names, making the code easy to understand and maintain."
survived,"    def test_resume_live_updates_when_paused(self):
        """"""Test resuming when paused.""""""
        formatter = ConsoleFormatter()
        
        formatter._live_paused = True
        
        formatter.resume_live_updates()
        
        assert not formatter._live_paused
",tests/utilities/test_console_formatter_pause_resume.py,TestConsoleFormatterPauseResume,1,1.3440409770490404e-08,"The method 'test_resume_live_updates_when_paused' is a unit test that checks the functionality of the 'resume_live_updates' method in the 'ConsoleFormatter' class. It is a simple and clear test that verifies if the '_live_paused' attribute is set to False after calling 'resume_live_updates'. This is a basic and necessary test to ensure that the 'resume_live_updates' method works as expected. Unit tests are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, this method is likely to be retained as part of the test suite."
survived,"    def test_human_input_pauses_flow_updates(self, mock_input):
        """"""Test that human input pauses Flow status updates.""""""
        from crewai.agents.agent_builder.base_agent_executor_mixin import CrewAgentExecutorMixin
        
        executor = CrewAgentExecutorMixin()
        executor.crew = MagicMock()
        executor.crew._train = False
        executor._printer = MagicMock()
        
        formatter = event_listener.formatter
        
        original_paused_state = formatter._live_paused
        
        try:
            formatter._live_paused = False
            
            with patch.object(formatter, 'pause_live_updates') as mock_pause, \
                 patch.object(formatter, 'resume_live_updates') as mock_resume:
                
                result = executor._ask_human_input(""Test result"")
                
                mock_pause.assert_called_once()
                mock_resume.assert_called_once()
                mock_input.assert_called_once()
                assert result == ''
        finally:
            formatter._live_paused = original_paused_state
",tests/test_flow_human_input_integration.py,TestFlowHumanInputIntegration,1,1.725782769012759e-08,"The method is a unit test that verifies the behavior of a specific functionality, which is important for ensuring the reliability and correctness of the code. Unit tests are generally not deleted unless the functionality they test is removed or significantly changed. Since this test checks the interaction with human input and the pausing of updates, it is likely to remain relevant as long as the feature exists."
deleted,"    async def invoke_embeddings(
        self,
        query: core_entities.Query,
        model: RuntimeEmbeddingsModel,
        input_text: str,
        extra_args: dict[str, typing.Any] = {},
    ) -> list[float]:
        """"""Ë∞ÉÁî® Embeddings API

        Args:
            query (core_entities.Query): ËØ∑Ê±Ç‰∏ä‰∏ãÊñá
            model (RuntimeEmbeddingsModel): ‰ΩøÁî®ÁöÑÊ®°Âûã‰ø°ÊÅØ
            input_text (str): ËæìÂÖ•ÊñáÊú¨
            extra_args (dict[str, typing.Any], optional): È¢ùÂ§ñÁöÑÂèÇÊï∞. Defaults to {}.

        Returns:
            list[float]: ËøîÂõûÁöÑ embedding ÂêëÈáè
        """"""
        pass",pkg/provider/modelmgr/requester.py,LLMAPIRequester,1,8.31527990378713e-07,"The method 'invoke_embeddings' is defined with a clear purpose and structure, including detailed docstrings explaining its parameters and return type. However, it currently lacks an implementation (indicated by the 'pass' statement). If this method is part of a larger codebase where the implementation is planned or pending, it is likely to survive as it serves a specific function related to invoking an Embeddings API. The presence of detailed docstrings suggests that there is an intention to implement this method in the future. Therefore, without further context indicating that this method is obsolete or unnecessary, it is reasonable to predict that it will survive."
deleted,"    async def load_embeddings_model(
        self,
        model_info: persistence_model.EmbeddingsModel | sqlalchemy.Row[persistence_model.EmbeddingsModel] | dict,
    ):
        """"""Âä†ËΩΩ Embeddings Ê®°Âûã""""""
        runtime_embeddings_model = await self.init_runtime_embeddings_model(model_info)
        self.embeddings_models.append(runtime_embeddings_model)
",pkg/provider/modelmgr/modelmgr.py,ModelManager,1,5.211412485172657e-10,"The method 'load_embeddings_model' is likely to survive because it is an asynchronous function that loads an embeddings model, which is a common and necessary operation in machine learning and data processing applications. The method is designed to handle different types of input (EmbeddingsModel, Row, or dict), making it versatile and useful in various contexts. Additionally, it appends the loaded model to a list, suggesting it is part of a larger system for managing multiple models, which is a typical requirement in scalable applications."
survived,"def create_sink_connection(config: Mapping[str, Any]) -> PipelineDataSink:
    pipeline_id = config.get(""pipeline_id"")
    pipeline_access_token = config.get(""pipeline_access_token"")

    return PipelineDataSink(pipeline_id=pipeline_id, pipeline_access_token=pipeline_access_token)
",airbyte-integrations/connectors/destination-glassflow/destination_glassflow/destination.py,,1,1.1032560311263802e-09,"The method 'create_sink_connection' is a straightforward utility function that creates and returns an instance of 'PipelineDataSink' using configuration data. It is likely to be a core part of setting up data pipelines, which is a common task in data processing and ETL (Extract, Transform, Load) operations. Such utility functions are generally useful and reusable, making them less likely to be deleted unless there is a significant change in the architecture or design that renders this specific method obsolete. Therefore, it is more likely to survive."
survived,"def _init_mocks(client):
    pipeline = Mock()
    client.return_value = pipeline
    return pipeline
",airbyte-integrations/connectors/destination-glassflow/unit_tests/unit_test.py,,1,7.582560422162384e-10,"The method _init_mocks is a utility function that initializes and returns a mock object for testing purposes. Such methods are typically used in unit tests to simulate and control the behavior of dependencies. Since testing is a crucial part of software development, especially in maintaining code quality and reliability, this method is likely to be retained as part of the test suite. Therefore, it is predicted to survive."
survived,"def test_source_init_with_different_override_combinations(
    cursor_overrides, primary_key_overrides
):
    """"""Test that the Source initializes correctly with different combinations of overrides.""""""
    with patch.object(Source, ""_discover"", return_value=Mock()):
        source = Source(
            executor=Mock(),
            name=""test-source"",
            cursor_key_overrides=cursor_overrides,
            primary_key_overrides=primary_key_overrides,
        )

        if cursor_overrides:
            assert source._cursor_key_overrides == cursor_overrides
        else:
            assert source._cursor_key_overrides == {}

        if primary_key_overrides:
            expected_pk_overrides = {
                k: v if isinstance(v, list) else [v]
                for k, v in primary_key_overrides.items()
            }
            assert source._primary_key_overrides == expected_pk_overrides
        else:
            assert source._primary_key_overrides == {}
",tests/unit_tests/sources/test_source_key_overrides.py,,1,1.637377179507321e-07,"The method is a unit test function that verifies the initialization of a 'Source' object with different combinations of cursor and primary key overrides. It uses mocking to isolate the test from dependencies and checks the internal state of the object to ensure it matches expected values. This is a typical and necessary part of software testing to ensure code reliability and correctness. Therefore, it is unlikely to be deleted as it serves a crucial role in maintaining code quality."
survived,"def mock_catalog(mock_stream):
    """"""Create a mock AirbyteCatalog for testing.""""""
    catalog = Mock(spec=AirbyteCatalog)
    catalog.streams = [mock_stream]
    return catalog
",tests/unit_tests/sources/test_source_key_overrides.py,,1,1.522997951276035e-08,"The method 'mock_catalog' is a utility function designed to create a mock object for testing purposes. Such functions are generally useful in unit testing to simulate and test the behavior of components without relying on actual implementations. This method is likely to be retained as it provides a convenient way to create mock objects, which is a common practice in software development to ensure code reliability and correctness. Additionally, the method is simple, clear, and serves a specific purpose, making it unlikely to be removed unless the testing framework or requirements change significantly."
survived,"def test_set_cursor_key():
    """"""Test that set_cursor_key properly updates a single cursor key override.""""""
    with patch.object(Source, ""_discover"", return_value=Mock()):
        source = Source(executor=Mock(), name=""test-source"")

        source.set_cursor_key(""stream1"", ""cursor1"")
        assert source._cursor_key_overrides == {""stream1"": ""cursor1""}

        source.set_cursor_key(""stream2"", ""cursor2"")
        assert source._cursor_key_overrides == {
            ""stream1"": ""cursor1"",
            ""stream2"": ""cursor2"",
        }

        source.set_cursor_key(""stream1"", ""new_cursor1"")
        assert source._cursor_key_overrides == {
            ""stream1"": ""new_cursor1"",
            ""stream2"": ""cursor2"",
        }
",tests/unit_tests/sources/test_source_key_overrides.py,,1,2.8453347280241004e-08,"The method `test_set_cursor_key` is a unit test function that verifies the behavior of the `set_cursor_key` method in the `Source` class. It uses assertions to check if the cursor key overrides are updated correctly. This is a typical and necessary part of software development to ensure code reliability and correctness. Since it is a test function, it is unlikely to be deleted unless the functionality it tests is removed or significantly changed. Therefore, it is predicted to survive."
survived,"    def __init__(self, name: str, save_path: str) -> None:
        super().__init__(name, ""mock"", save_path)
        self.saved_caches: Dict[str, Cache] = {}
",tests/_save/loaders/test_loader.py,MockPersistenceLoader,1,2.998960815863541e-09,"The method is a constructor (__init__) for a class, which is a fundamental part of class instantiation in Python. Constructors are essential for initializing object state and are unlikely to be removed unless the class itself is being deprecated or significantly refactored. Since this method is performing necessary initialization tasks, it is expected to survive."
survived,"    def test_build_path(self) -> None:
        """"""Test building the path for a cache file.""""""
        loader = PickleLoader(""test"", self.save_path)
        path = loader.build_path(""hash1"", ""Pure"")
        assert str(path).endswith(""P_hash1.pickle"")
        
        path = loader.build_path(""hash2"", ""Deferred"")
        assert str(path).endswith(""D_hash2.pickle"")
",tests/_save/loaders/test_pickle_loader.py,TestPickleLoader,1,4.944450477491054e-09,"The method 'test_build_path' is a unit test designed to verify the functionality of the 'build_path' method in the 'PickleLoader' class. Unit tests are crucial for ensuring code reliability and correctness, especially in larger projects. This test checks that the 'build_path' method correctly constructs file paths based on given parameters. Since testing is an essential part of software development and maintenance, this method is likely to be retained to ensure the 'build_path' method continues to function as expected. Therefore, it will survive."
deleted,"def test_mem0_storage_uses_local_config(mem0_storage_with_local_config):
    """"""Test that Mem0Storage correctly uses local_mem0_config when initializing Memory""""""
    _, mock_from_config, local_config = mem0_storage_with_local_config
    mock_from_config.assert_called_once_with(local_config)",tests/storage/test_mem0_storage.py,,1,2.5109990926928157e-08,"The method `test_mem0_storage_uses_local_config` is a unit test function that verifies the behavior of a component (likely a storage or memory component) in a software system. Unit tests are crucial for ensuring code reliability and are typically maintained as part of the codebase to prevent regressions. The function is well-defined, uses a mock to assert expected behavior, and is likely part of a test suite that ensures the correct configuration is used during initialization. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality."
survived,"    def balance_of(self, address: str) -> Balance:
        """"""Get the SOL balance of an address.""""""
        pubkey = PublicKey(address)
        balance_lamports = self.client.get_balance(pubkey)[""result""][""value""]
        # Convert lamports (1e9 lamports in 1 SOL)
        return {
            ""decimals"": 9,
            ""symbol"": ""SOL"",
            ""name"": ""Solana"",
            ""value"": str(balance_lamports / 10**9),
            ""in_base_units"": str(balance_lamports),
        }
",python/src/wallets/solana/goat_wallets/solana/wallet.py,SolanaKeypairWalletClient,1,2.1724399346070676e-10,"The method 'balance_of' is a useful utility function for retrieving the balance of a given address in the Solana blockchain. It converts the balance from lamports to SOL, which is a common requirement for users interacting with the blockchain. The method is straightforward, performs a necessary conversion, and provides the balance in a structured format. There is no indication of redundancy or obsolescence in the code, and it serves a clear purpose. Therefore, it is likely to be retained."
survived,"    def get_address(self) -> str:
        """"""Get the wallet's public address.""""""
        return str(self.keypair.public_key)
",python/src/wallets/solana/goat_wallets/solana/wallet.py,SolanaKeypairWalletClient,1,1.1032560311263802e-09,"The method 'get_address' is a simple and clear utility function that returns the public address of a wallet. It is likely to be a fundamental part of any class dealing with cryptographic key pairs, as accessing the public address is a common requirement. The method is straightforward, has a clear purpose, and is unlikely to be redundant or unnecessary in the context of a class managing key pairs. Therefore, it is likely to be retained."
survived,"def mock_driver_with_html(html_content):
    driver = MagicMock()
    mock_element = MagicMock()
    mock_element.get_attribute.return_value = html_content
    bs = BeautifulSoup(html_content, ""html.parser"")
    mock_element.text = bs.get_text()

    driver.find_elements.return_value = [mock_element]
    driver.find_element.return_value = mock_element

    return driver
",tests/tools/selenium_scraping_tool_test.py,,1,1.0467401685178159e-08,"The method 'mock_driver_with_html' is a utility function that creates a mock web driver object for testing purposes. It uses the 'MagicMock' class to simulate a web driver and its elements, allowing developers to test their code without needing a real browser or web page. This is a common practice in unit testing to isolate the code being tested from external dependencies. Given its utility in testing environments, it is likely to be retained in the codebase."
survived,"    def _get_content(self, driver, css_element, return_html):
        content = []

        if self._is_css_element_empty(css_element):
            content.append(self._get_body_content(driver, return_html))
        else:
            content.extend(self._get_elements_content(driver, css_element, return_html))

        return content
",crewai_tools/tools/selenium_scraping_tool/selenium_scraping_tool.py,SeleniumScrapingTool,1,1.1628233028868813e-10,"The method '_get_content' is a utility function that checks if a CSS element is empty and retrieves content accordingly. It is likely part of a larger system that deals with web scraping or automated browser interactions. The method is well-structured, serves a clear purpose, and is likely to be useful in its context. There is no indication that it is obsolete or redundant, so it is likely to survive."
deleted,"    def test_sanitize_collection_name_bad_ends(self):
        """"""Test sanitizing a name with non-alphanumeric start/end.""""""
        bad_ends = ""_Agent_""
        sanitized = sanitize_collection_name(bad_ends)
        self.assertTrue(sanitized[0].isalnum())
        self.assertTrue(sanitized[-1].isalnum())
",tests/utilities/test_string_utils.py,TestStringUtils,1,4.944450477491054e-09,"The method `test_sanitize_collection_name_bad_ends` is a unit test designed to verify the functionality of the `sanitize_collection_name` function. It checks that the function correctly sanitizes a string by ensuring that the resulting string starts and ends with an alphanumeric character. This is a valid and useful test case for ensuring the robustness of the `sanitize_collection_name` function, especially if the function is part of a larger system that requires sanitized collection names. Therefore, the method is likely to be retained as it serves a clear purpose in testing the functionality of the code."
survived,"def test_telemetry_disable_with_multiple_instances():
    """"""Test that multiple telemetry instances respect dynamically changed env vars.""""""
    Telemetry._instance = None
    
    with patch.dict(os.environ, {}, clear=True):
        with patch(""crewai.telemetry.telemetry.TracerProvider""):
            telemetry1 = Telemetry()
            assert telemetry1.ready is True
            
            os.environ['CREWAI_DISABLE_TELEMETRY'] = 'true'
            
            telemetry2 = Telemetry()
            assert telemetry2 is telemetry1
            assert telemetry2.ready is True
            
            mock_operation = MagicMock()
            telemetry2._safe_telemetry_operation(mock_operation)
            mock_operation.assert_not_called()
",tests/telemetry/test_telemetry_disable.py,,1,8.152020648014727e-09,"The method is a test function that verifies the behavior of telemetry instances when environment variables are dynamically changed. It ensures that the telemetry system respects the 'CREWAI_DISABLE_TELEMETRY' environment variable and does not perform operations when telemetry is disabled. This is a crucial test for maintaining the integrity and expected behavior of the telemetry system, especially in environments where telemetry data collection needs to be controlled or disabled. Therefore, it is likely to be retained as part of the test suite to ensure the reliability and correctness of the telemetry feature."
survived,"    def test_call_tool_use(
        self, mock_anthropic_class: MagicMock, mock_require_api_key: MagicMock
    ) -> None:
        """"""Test calling the anthropic class with tool use response.""""""
        mock_require_api_key.return_value = ""test-key""
        mock_client = MagicMock()
        mock_anthropic_class.return_value = mock_client
        mock_response = MagicMock()
        mock_content = MagicMock()
        mock_content.type = ""tool_use""
        mock_response.content = [mock_content]
        mock_client.messages.create.return_value = mock_response

        model = anthropic(""claude-3-opus-20240229"")
        messages = [ChatMessage(role=""user"", content=""Test prompt"")]
        config = ChatModelConfig()

        result = model(messages, config)
        assert result == [mock_content]
",tests/_ai/llm/_impl.py,TestAnthropic,1,5.715002851580502e-07,"The method is a unit test for a specific functionality, which is to test the interaction with a mocked version of the 'anthropic' class. Unit tests are crucial for ensuring code reliability and are typically not deleted unless the functionality they test is removed or significantly altered. Since this test is specific to a tool use response and uses mock objects to simulate behavior, it is likely to be retained to ensure that the 'anthropic' class behaves as expected when integrated with other components."
survived,"    def test_require_api_key_missing(self, mock_get_context: MagicMock) -> None:
        """"""Test _require_api_key with missing key.""""""
        mock_context = MagicMock()
        mock_context.marimo_config = {""ai"": {""open_ai"": {""api_key"": """"}}}
        mock_get_context.return_value = mock_context

        model = openai(""gpt-4"")
        with pytest.raises(ValueError):
            _ = model._require_api_key
",tests/_ai/llm/_impl.py,TestOpenAI,1,6.023574641292144e-08,"The method 'test_require_api_key_missing' is a unit test designed to verify the behavior of the '_require_api_key' method when the API key is missing. It uses mocking to simulate the context and checks if a 'ValueError' is raised, which is a valid and necessary test case to ensure robustness of the code. Such test methods are typically retained to maintain code quality and reliability."
survived,"    def test_call(
        self, mock_anthropic_class: MagicMock, mock_require_api_key: MagicMock
    ) -> None:
        """"""Test calling the anthropic class.""""""
        mock_require_api_key.return_value = ""test-key""
        mock_client = MagicMock()
        mock_anthropic_class.return_value = mock_client
        mock_response = MagicMock()
        mock_content = MagicMock()
        mock_content.type = ""text""
        mock_content.text = ""Test response""
        mock_response.content = [mock_content]
        mock_client.messages.create.return_value = mock_response

        model = anthropic(""claude-3-opus-20240229"")
        # Patch the _require_api_key property to return the test key directly
        with patch.object(model, ""_require_api_key"", ""test-key""):
            messages = [ChatMessage(role=""user"", content=""Test prompt"")]
            config = ChatModelConfig(
                max_tokens=100,
                temperature=0.7,
                top_p=0.9,
                top_k=10,
            )

            result = model(messages, config)
            assert result == ""Test response""

            mock_anthropic_class.assert_called_once_with(
                api_key=""test-key"", base_url=None
            )
        mock_client.messages.create.assert_called_once()
        call_args = mock_client.messages.create.call_args[1]
        assert call_args[""model""] == ""claude-3-opus-20240229""
        assert call_args[""system""] == DEFAULT_SYSTEM_MESSAGE
        assert call_args[""max_tokens""] == 100
        assert call_args[""temperature""] == 0.7
        assert call_args[""top_p""] == 0.9
        assert call_args[""top_k""] == 10
        assert call_args[""stream""] is False
",tests/_ai/llm/_impl.py,TestAnthropic,1,5.3157849718487075e-08,"The method `test_call` is a unit test designed to verify the behavior of a function or class method. Unit tests are crucial for ensuring code reliability and correctness, especially in larger codebases. This test method uses mocking to simulate the behavior of external dependencies, which is a common practice in testing. The presence of assertions to check the expected behavior further indicates its importance in maintaining code quality. Therefore, it is unlikely to be deleted as it serves a critical role in the development process."
survived,"    def test_require_api_key_env(self) -> None:
        """"""Test _require_api_key with environment variable.""""""
        model = google(""gemini-pro"")
        assert model._require_api_key == ""env-key""
",tests/_ai/llm/_impl.py,TestGoogle,1,3.2241866333029355e-08,"The method `test_require_api_key_env` is a unit test that checks if the `_require_api_key` attribute of a `model` object is correctly set to ""env-key"". This is a straightforward test that verifies a specific functionality, which is important for ensuring the code behaves as expected. Unit tests are generally not deleted unless they are redundant or the functionality they test is removed. Since this test is simple and directly checks a specific feature, it is likely to be retained."
survived,"def test_anthropic_require() -> None:
    """"""Test that anthropic.require raises ModuleNotFoundError.""""""
    model = anthropic(""claude-3-opus-20240229"")
    messages = [ChatMessage(role=""user"", content=""Test prompt"")]
    config = ChatModelConfig()
    with pytest.raises(ModuleNotFoundError):
        model(messages, config)
",tests/_ai/llm/_impl.py,,1,1.444980317078884e-07,"The method `test_anthropic_require` is a unit test designed to ensure that the `anthropic.require` function raises a `ModuleNotFoundError`. This is a typical pattern in testing to verify that certain conditions or errors are correctly handled by the code. The method is useful for maintaining code quality and ensuring that the expected exceptions are raised under certain conditions. Since it serves a clear purpose in testing the robustness of the code, it is likely to be retained."
survived,"    def test_base_url_without_leading_slash(self) -> None:
        # Test without leading slash
        with pytest.raises(click.BadParameter) as excinfo:
            base_url(None, None, ""api"")
        assert ""Must start with /"" in str(excinfo.value)
",tests/_cli/test_cli_validators.py,TestBaseUrl,1,1.725782769012759e-08,"The method `test_base_url_without_leading_slash` is a unit test designed to verify that the `base_url` function raises a `click.BadParameter` exception when the input does not start with a leading slash. This is a valid and necessary test to ensure the robustness of the `base_url` function, especially if the function is part of a larger application where URL validation is critical. Unit tests are generally not deleted unless they are redundant or the functionality they test is removed. Since this test serves a clear purpose in validating input constraints, it is likely to be retained."
survived,"    def test_is_file_path_with_directory(self, tmp_path: Path) -> None:
        # Test with directory instead of file
        with pytest.raises(click.BadParameter) as excinfo:
            is_file_path(None, None, str(tmp_path))
        assert f""Not a file: {tmp_path}"" in str(excinfo.value)",tests/_cli/test_cli_validators.py,TestIsFilePath,1,4.6911638017642294e-08,"The method 'test_is_file_path_with_directory' is a unit test designed to verify that the 'is_file_path' function correctly raises an exception when provided with a directory path instead of a file path. This is a valid and necessary test case to ensure the robustness of the 'is_file_path' function, especially in scenarios where the function is expected to handle file paths only. The test uses 'pytest.raises' to check for the specific exception 'click.BadParameter', which is a common practice in testing to ensure that the function behaves as expected under erroneous input conditions. Therefore, this method is likely to be retained as it serves a critical role in validating the functionality of the code."
survived,"    def test_base_url_with_trailing_slash(self) -> None:
        # Test with trailing slash
        with pytest.raises(click.BadParameter) as excinfo:
            base_url(None, None, ""/api/"")
        assert ""Must not end with /"" in str(excinfo.value)
",tests/_cli/test_cli_validators.py,TestBaseUrl,1,1.522997951276035e-08,"The method 'test_base_url_with_trailing_slash' is a unit test designed to verify that the 'base_url' function raises a 'click.BadParameter' exception when the input URL ends with a trailing slash. This is a valid and useful test case to ensure the robustness of the 'base_url' function by checking its behavior with invalid input. Unit tests are generally retained in codebases to ensure ongoing code quality and to prevent regressions. Therefore, this method is likely to be retained."
survived,"        def accepts_mime_bundle(bundle: MimeBundle) -> MimeBundle:
            return bundle
",tests/_messaging/test_mimetypes.py,TestMimeTypes,0,0.999999694097641,"The method 'accepts_mime_bundle' is a simple pass-through function that returns the input 'bundle' without any modification or processing. This kind of method is often used as a placeholder or for testing purposes. If the method is part of a larger system where it is expected to perform some processing or validation on the 'MimeBundle', it is likely to be deleted or refactored in the future to add meaningful functionality. However, if it serves a specific purpose in the current context, such as maintaining a consistent interface or being overridden in subclasses, it might be retained. Without additional context, the method seems redundant, suggesting it might be deleted."
deleted,"    def test_unknown_error(self) -> None:
        error = UnknownError(msg=""Something went wrong"")

        # Test properties
        assert error.type == ""unknown""
        assert error.describe() == ""Something went wrong""
",tests/_messaging/test_errors.py,TestErrorClasses,1,2.0611536181902033e-09,"The method 'test_unknown_error' is a unit test for the 'UnknownError' class, which is likely part of a larger codebase. Unit tests are crucial for ensuring code reliability and are generally not deleted unless they are redundant or replaced by more comprehensive tests. This test checks the properties and behavior of the 'UnknownError' class, which is a fundamental aspect of maintaining code quality. Therefore, it is likely to survive."
survived,"    def __init__(self) -> None:
        self.messages: list[tuple[str, dict]] = []
",tests/_messaging/test_console_output_worker.py,MockStream,1,9.237449576640118e-09,"The method is a constructor for a class, initializing an instance variable 'messages' as an empty list of tuples. This is a common and necessary practice in object-oriented programming to set up initial state for objects. There is no indication that this method is redundant or unnecessary, as it serves a fundamental purpose in class instantiation. Therefore, it is unlikely to be deleted."
survived,"    def test_stdout_name(self) -> None:
        stdout = self.MockStdout()
        assert stdout.name == ""stdout""
",tests/_messaging/test_types.py,TestStdoutStderr,1,3.850741907939403e-09,"The method `test_stdout_name` is a simple test function that checks if the `name` attribute of a `MockStdout` object is equal to the string ""stdout"". This is a straightforward and valid test case that ensures the `MockStdout` class behaves as expected. Such test methods are crucial for maintaining code quality and ensuring that changes do not break existing functionality. Therefore, it is likely to be retained in the codebase."
survived,"    def test_write_traceback_to_stderr(self) -> None:
        # Test writing traceback to Stderr
        mock_stderr = MagicMock(spec=Stderr)

        with patch(""sys.stderr"", mock_stderr):
            traceback = ""Traceback (most recent call last):\n  File \""<stdin>\"", line 1, in <module>\nValueError: invalid value""
            write_traceback(traceback)

            # Should call _write_with_mimetype with highlighted traceback
            mock_stderr._write_with_mimetype.assert_called_once()

            # First argument should be the highlighted traceback
            args, _ = mock_stderr._write_with_mimetype.call_args
            assert ""<span class=\""codehilite\"">"" in args[0]
            assert ""Traceback"" in args[0]

            # Second argument should be the mimetype
            _, kwargs = mock_stderr._write_with_mimetype.call_args
            assert kwargs[""mimetype""] == ""application/vnd.marimo+traceback""
",tests/_messaging/test_tracebacks.py,TestTracebacks,1,2.1024340680345882e-07,"The method 'test_write_traceback_to_stderr' is a unit test designed to verify the functionality of writing a traceback to stderr with specific formatting. It uses mocking to simulate the stderr and checks if the method '_write_with_mimetype' is called with the correct arguments. This is a typical and necessary test to ensure that the traceback is being handled and displayed correctly, especially in applications where error reporting is crucial. Therefore, it is unlikely to be deleted as it serves an important role in maintaining code quality and reliability."
survived,"    def __init__(self, api_key: str, base_url: str = ""https://api.uniswap.org/v2""):
        self.api_key = api_key
        self.base_url = base_url
",python/src/plugins/uniswap/goat_plugins/uniswap/service.py,UniswapService,1,7.194132978569833e-09,"The method is a constructor for a class, which is a fundamental part of object-oriented programming. Constructors are essential for initializing new objects with specific attributes, such as 'api_key' and 'base_url' in this case. This method is likely to survive because it is necessary for setting up instances of the class with the required configuration for interacting with the Uniswap API."
survived,"def test_error_handling_not_found(custodial_api):
    """"""Test error handling for non-existent wallet.""""""
    with pytest.raises(Exception) as exc:
        custodial_api.get_wallet(""invalid:wallet:id"")
    assert ""Error"" in str(exc.value)
    assert ""404"" in str(exc.value)
",python/src/wallets/crossmint/tests/test_api_client.py,,1,1.1861120010657661e-08,"The method is a test function that checks the error handling of a specific API call. It is important to ensure that the API correctly handles cases where a non-existent wallet is requested, and this test verifies that the appropriate exception is raised and contains the expected error message. Such tests are crucial for maintaining robust error handling in software, especially in APIs. Therefore, this method is likely to be retained as part of the test suite."
survived,"def test_solana_transaction():
    """"""Fixture providing a test Solana transaction.""""""
    return {
        ""instructions"": []  # Empty instructions for basic test
    }
",python/src/wallets/crossmint/tests/conftest.py,,1,7.194132978569833e-09,"The method `test_solana_transaction` is a simple fixture function that returns a basic Solana transaction structure with empty instructions. This function is likely used in a testing context to provide a mock or template transaction for unit tests. Such utility functions are common in test suites to ensure consistent and repeatable test setups. Since it serves a clear purpose in testing, it is unlikely to be deleted unless the testing framework or requirements change significantly."
survived,"def test_response_json_parsing(custodial_api):
    """"""Test JSON response parsing.""""""
    with pytest.raises(Exception) as exc:
        custodial_api.get_wallet(""invalid:wallet:id"")
    error_response = str(exc.value)
    assert ""{"" in error_response  # Should include formatted JSON error
    assert ""}"" in error_response
",python/src/wallets/crossmint/tests/test_api_client.py,,1,9.931195248674785e-08,"The method 'test_response_json_parsing' is a unit test designed to verify the JSON response parsing of an API. It uses pytest to ensure that an exception is raised when an invalid wallet ID is provided, and it checks that the error message contains JSON formatting. This is a standard practice in testing to ensure robustness and error handling in API interactions. Such tests are crucial for maintaining code quality and are unlikely to be deleted unless the functionality they test is removed or significantly altered."
survived,"def test_authentication_headers(custodial_api):
    """"""Test authentication header structure.""""""
    headers = custodial_api._request(""/wallets"", method=""GET"").request.headers
    assert ""x-api-key"" in headers
    assert headers[""x-api-key""] == os.environ[""CROSSMINT_STAGING_API_KEY_CUSTODIAL""]
    assert headers[""Content-Type""] == ""application/json""
",python/src/wallets/crossmint/tests/test_api_client.py,,1,3.653482080241728e-08,"The method `test_authentication_headers` is a unit test function that checks the presence and correctness of authentication headers in an API request. Such test functions are crucial for ensuring that the API requests are properly authenticated and formatted, which is a fundamental aspect of API security and functionality. Therefore, it is unlikely to be deleted as it serves an important role in maintaining the integrity of the API interactions."
survived,"def run():
    source = SourceBoxDataExtract()
    launch(source, sys.argv[1:])",airbyte-integrations/connectors/source-box-data-extract/source_box_data_extract/run.py,,1,5.905303995456778e-10,"The method 'run' is a simple function that initializes an instance of 'SourceBoxDataExtract' and then calls 'launch' with this instance and command line arguments. There is no indication of deprecated functionality, errors, or inefficiencies in the code. It appears to be a straightforward and functional piece of code that serves its purpose. Without any context suggesting that 'SourceBoxDataExtract' or 'launch' are obsolete or that the method is redundant, there is no reason to delete it. Therefore, it is likely to survive."
survived,"def box_folder_text_representation(
    client: BoxClient, folder_id: str, is_recursive: bool = False, by_pass_text_extraction: bool = False
) -> Iterable[BoxFileExtended]:
    # folder items iterator
    for item in client.folders.get_folder_items(folder_id).entries:
        if item.type == ""file"":
            file = box_file_get_by_id(client=client, file_id=item.id)
            if not by_pass_text_extraction:
                text_representation = box_file_text_extract(client=client, file_id=item.id)
            else:
                text_representation = """"
            yield BoxFileExtended(file=file, text_representation=text_representation)
        elif item.type == ""folder"" and is_recursive:
            yield from box_folder_text_representation(
                client=client, folder_id=item.id, is_recursive=is_recursive, by_pass_text_extraction=by_pass_text_extraction
            )
",airbyte-integrations/connectors/source-box-data-extract/source_box_data_extract/box_api.py,,1,2.3355930333443423e-09,"The method 'box_folder_text_representation' is a useful utility for iterating over files in a Box folder and optionally extracting text from them. It supports recursion to handle nested folders and provides flexibility with the 'by_pass_text_extraction' parameter. These features make it a versatile tool for applications that need to process or analyze files stored in Box. Given its functionality and adaptability, it is likely to be retained in the codebase."
survived,"def box_folder_ai_extract_structured(
    client: BoxClient, folder_id: str, fields_json_str: str, is_recursive: bool = False, by_pass_text_extraction: bool = False
) -> Iterable[BoxFileExtended]:
    # folder items iterator
    for item in client.folders.get_folder_items(folder_id).entries:
        if item.type == ""file"":
            file = box_file_get_by_id(client=client, file_id=item.id)
            if not by_pass_text_extraction:
                text_representation = box_file_ai_extract_structured(client=client, file_id=item.id, fields_json_str=fields_json_str)
            else:
                text_representation = """"
            yield BoxFileExtended(file=file, text_representation=text_representation)
        elif item.type == ""folder"" and is_recursive:
            yield from box_folder_ai_extract_structured(
                client=client,
                folder_id=item.id,
                fields_json_str=fields_json_str,
                is_recursive=is_recursive,
                by_pass_text_extraction=by_pass_text_extraction,
            )",airbyte-integrations/connectors/source-box-data-extract/source_box_data_extract/box_api.py,,1,1.8189616842444243e-09,"The method `box_folder_ai_extract_structured` is a utility function that recursively extracts structured data from files within a Box folder. It uses a client to interact with the Box API, processes files to extract text representations, and supports recursive folder traversal. This functionality is useful for applications that need to process and analyze data stored in Box folders, making it a valuable method for data extraction and processing tasks. Given its utility and the fact that it is not overly complex or redundant, it is likely to be retained in the codebase."
survived,"    def check_connection(self, logger, config) -> Tuple[bool, any]:
        """"""
        :param config:  the user-input config object conforming to the connector's spec.yaml
        :param logger:  logger object
        :return Tuple[bool, any]: (True, None) if the input config can be used to connect to the API successfully, (False, error) otherwise.
        """"""
        logger.info(""Checking Box API connection..."")
        try:
            box_client = get_box_ccg_client(config)
            user = box_client.users.get_user_me()
            logger.debug(f""box_subject_type: {config.get('box_subject_type')}, box_subject_id: {config.get('box_subject_id')}"")
            logger.info(f""Logged into Box as: {user.name} ({user.id} - {user.login})"")
        except BoxAPIError as e:
            logger.error(f""Unable to connect to Box API with the provided credentials - {e}"")
            return False, f""Unable to connect to Box API with the provided credentials""
        return True, None
",airbyte-integrations/connectors/source-box-data-extract/source_box_data_extract/source.py,SourceBoxDataExtract,1,1.1861120010657661e-08,"The method 'check_connection' is a crucial part of ensuring that the application can successfully connect to the Box API using the provided configuration. It handles logging, error catching, and returns a clear success or failure status, which is essential for debugging and operational purposes. Such methods are typically retained as they provide necessary functionality for establishing and verifying connections in applications that interact with external services."
survived,"def create_protected_agent() -> Agent:
    """"""
    Create an agent with input guardrails for protection.
    
    Returns:
        An Agent instance with input guardrails.
    """"""
    instructions = """"""
    You are a helpful assistant that provides information and assistance on various topics.
    You prioritize user safety and ethical responses.
    Provide accurate, helpful information while avoiding potentially harmful content.
    Be concise but thorough in your responses.
    """"""
    
    # Create guardrails
    content_guardrail = ContentModerationGuardrail()
    format_guardrail = FormatValidationGuardrail(min_length=5, max_length=500)
    
    # Create the agent with guardrails
    return Agent(
        name=""ProtectedAssistant"",
        instructions=instructions,
        model=""gpt-4o-mini"",
        input_guardrails=[content_guardrail, format_guardrail]
    )
",openai-agents-examples/10_agent_with_guardrails.py,,1,3.581747929000289e-10,"The method 'create_protected_agent' is likely to survive because it encapsulates a clear and useful functionality: creating an agent with specific guardrails for content moderation and format validation. This is a common requirement in applications that need to ensure safe and appropriate interactions, especially when using AI models. The method is well-documented, follows a clear structure, and uses meaningful components, which suggests it is a well-considered part of the codebase."
survived,"def main():
    """"""Fix imports in all Python files in the directory.""""""
    # Try to create a symlink for agents
    create_agents_symlink()
    
    # Get all Python files
    py_files = glob.glob('*.py')
    
    for file_path in py_files:
        if file_path != 'fix_imports.py':  # Skip this script
            fix_imports_in_file(file_path)
    
    print(""Import fixing complete!"")
",openai-agents-examples/fix_imports.py,,1,6.348800075736417e-09,The method is a main function that orchestrates the process of fixing imports in Python files within a directory. It includes a check to avoid modifying itself and provides a clear output message upon completion. This functionality is useful for maintaining code quality and is likely to be retained unless the project requirements change significantly.
survived,"def get_current_time(location: str) -> str:
    """"""
    Get the current time in a given location.
    
    Args:
        location: The location to get the time for. Currently only supports ""UTC"".
        
    Returns:
        A string containing the current time information.
    """"""
    # In a real implementation, you would use a timezone library
    current_time = datetime.utcnow()
    formatted_time = current_time.strftime(""%Y-%m-%d %H:%M:%S"")
    
    return f""The current time in {location} is {formatted_time}.""
",openai-agents-examples/05_agent_with_function_tools.py,,0,0.9999957771647318,"The method is likely to be deleted because it is not fully implemented. It claims to get the current time for a given location but only supports 'UTC'. This limitation makes the function less useful, as it doesn't fulfill the general purpose of getting the current time for any location. Additionally, the function does not handle invalid input or provide any error messages for unsupported locations, which further reduces its utility. Without improvements or extensions to support multiple time zones, the method is not very practical."
survived,"def test_create_travel_assistant():
    """"""Test that the travel assistant agent is created with the correct configuration.""""""
    agent = create_travel_assistant()
    assert agent.name == ""TravelAssistant""
    assert ""travel assistant"" in agent.instructions.lower()
    assert len(agent.tools) == 3
",openai-agents-examples/05_agent_with_function_tools.py,,1,2.3355930333443423e-09,"The method `test_create_travel_assistant` is a unit test designed to verify the correct creation of a travel assistant agent. Unit tests are crucial for ensuring code reliability and correctness, especially in larger projects. This test checks specific attributes of the agent, such as its name, instructions, and the number of tools, which are important for validating the agent's configuration. Given the importance of testing in software development, this method is likely to be retained to ensure the functionality of the `create_travel_assistant` function."
survived,"def test_orchestrate_content_creation():
    """"""Test that the content creation system can run and produce content.""""""
    import pytest
    
    # Skip this test if no API key is available
    if not os.environ.get(""OPENAI_API_KEY""):
        pytest.skip(""OPENAI_API_KEY not set"")
    
    # Run a test with a simple content request
    # Use a shorter timeout for testing
    content = asyncio.run(orchestrate_content_creation(""Write a short paragraph about renewable energy""))
    
    # Verify we got non-empty content
    assert content
    assert len(content) > 0
    # The content should contain relevant terms
    assert any(term in content.lower() for term in [""renewable"", ""energy"", ""sustainable""])
",openai-agents-examples/11_agent_orchestration.py,,1,1.725782769012759e-08,"The method 'test_orchestrate_content_creation' is a test function designed to verify the functionality of a content creation system. It includes a check for an API key, runs a content creation function, and asserts the output. These are standard practices in testing to ensure code reliability and functionality. The method is likely to be maintained as it serves a critical role in validating the system's capabilities and ensuring that the content produced meets certain criteria. Additionally, the use of pytest for skipping tests when conditions aren't met is a common and useful practice in test automation."
survived,"def create_triage_agent(specialists: List[Agent]) -> Agent:
    """"""
    Create a triage agent that can delegate to specialist agents.
    
    Args:
        specialists: List of specialist agents to which tasks can be delegated
        
    Returns:
        An Agent instance that triages customer inquiries
    """"""
    instructions = """"""
    You are a customer support triage agent. Your job is to:
    1. Understand the customer's issue
    2. Determine which specialist would be best suited to help
    3. Hand off the conversation to that specialist
    
    Be polite and professional. If you're unsure which specialist to choose, ask clarifying questions.
    """"""
    
    # Create handoffs to specialist agents
    handoffs = [handoff(agent) for agent in specialists]
    
    return Agent(
        name=""TriageAgent"",
        instructions=instructions,
        model=""gpt-4o-mini"",
        handoffs=handoffs
    )
",openai-agents-examples/07_agent_with_handoffs.py,,1,4.363462233903899e-09,"The method 'create_triage_agent' is likely to survive because it encapsulates a clear and useful functionality: creating a triage agent that delegates tasks to specialist agents. This is a common pattern in customer support systems where initial inquiries need to be routed to the appropriate specialist. The method is well-documented, specifying its purpose, arguments, and return value, which makes it maintainable and understandable. Additionally, it uses a modern AI model ('gpt-4o-mini'), indicating that it is designed to work with current technology trends. Unless there is a significant change in the underlying architecture or a shift away from using AI models for triage, this method will likely remain relevant and useful."
survived,"    def reset_debug_session(self, session_type: str):
        """"""ÈáçÁΩÆË∞ÉËØï‰ºöËØù""""""
        session_key = f'webchat{session_type}'
        self.debug_messages[session_key] = []",pkg/platform/sources/webchat.py,WebChatAdapter,1,5.60279640614594e-09,"The method `reset_debug_session` is a utility function that clears the debug messages for a specific session type. It is a simple and useful method for managing debug sessions, especially in applications that require frequent resetting of session data. The method is straightforward, has a clear purpose, and is likely to be used in debugging or development environments. Therefore, it is likely to be retained in the codebase."
survived,"    def extract_headings(self, content: str) -> List[str]:
        """"""Extract headings from markdown content.""""""
        headings = []
        lines = content.split('\n')
        
        for line in lines:
            line = line.strip()
            if line.startswith('#'):
                heading_text = re.sub(r'^#+\s*', '', line)
                heading_text = re.sub(r'\{[^}]*\}', '', heading_text)  # Remove {#id} syntax
                if heading_text:
                    headings.append(heading_text.strip())
        
        return headings
",scripts/typesense_indexer.py,MarkdownProcessor,1,3.581747929000289e-10,"The method 'extract_headings' is a utility function that extracts headings from markdown content. This is a common requirement in text processing, especially for applications dealing with markdown files, such as static site generators, documentation tools, or content management systems. The method is well-defined, using regular expressions to clean up the heading text and handle specific markdown syntax. It is likely to be useful in various contexts where markdown processing is needed, and there are no apparent issues with its implementation. Therefore, it is likely to be retained in the codebase."
survived,"def test_create_directory_false():
    """"""Test that directories are not created when create_directory=False.""""""
    from pathlib import Path
    
    output_path = ""nonexistent_test_dir/output.txt""
    
    task = Task(
        description=""Test task"",
        expected_output=""Test output"",
        output_file=output_path,
        create_directory=False,
    )
    
    resolved_path = Path(output_path).expanduser().resolve()
    resolved_dir = resolved_path.parent
    
    if resolved_dir.exists():
        import shutil
        shutil.rmtree(resolved_dir)
    
    assert not resolved_dir.exists()
    
    with pytest.raises(RuntimeError, match=""Directory .* does not exist and create_directory is False""):
        task._save_file(""test content"")
",tests/task_test.py,,1,4.944450477491054e-09,"The method is a test function that verifies the behavior of a task when the 'create_directory' flag is set to False. It ensures that the directory is not created automatically, which is a valid and necessary test case for ensuring the robustness of the Task class. Test functions are generally retained as they are crucial for maintaining code quality and preventing regressions."
survived,"    def tearDown(self):
        """"""Clean up Milvus Lite resources.""""""
        import shutil
        
        try:
            # Clean up any existing test collections
            if hasattr(self, 'config') and utility.has_collection(self.config[""indexing""][""collection""], using=""default""):
                utility.drop_collection(self.config[""indexing""][""collection""], using=""default"")
                
            # Disconnect from Milvus Lite
            if connections.has_connection(""default""):
                connections.disconnect(""default"")
            
            # Remove temporary directory
            if hasattr(self, 'temp_dir'):
                shutil.rmtree(self.temp_dir, ignore_errors=True)
        except Exception as e:
            logger.warning(f""Error during teardown: {str(e)}"")
",airbyte-integrations/connectors/destination-milvus/integration_tests/milvus_integration_test.py,MilvusIntegrationTest,1,6.825604231969389e-08,"The method `tearDown` is a standard part of the testing lifecycle in many testing frameworks, such as unittest in Python. It is used to clean up resources after a test has been executed, ensuring that each test runs in a clean environment. This method is crucial for maintaining test isolation and preventing side effects between tests. The code provided is a typical implementation of a `tearDown` method, handling resource cleanup and error logging. Therefore, it is unlikely to be deleted as it serves an essential purpose in the testing process."
survived,"def test_solana_smart_wallet_creation(smart_api):
    """"""Test Solana smart wallet creation and retrieval.""""""
    wallet = smart_api.create_wallet(
        wallet_type=WalletType.SOLANA_SMART_WALLET,
        linked_user=""email:test@example.com""
    )
    assert wallet[""type""] == ""solana-smart-wallet""
    
    # Get wallet and verify only the address matches since other fields might differ
    retrieved = smart_api.get_wallet(wallet[""address""])
    assert retrieved[""address""] == wallet[""address""]
",python/src/wallets/crossmint/tests/test_solana_smart_wallet.py,,1,7.194132978569833e-09,"The method is a test function that verifies the creation and retrieval of a Solana smart wallet using a given API. It is likely part of a test suite for ensuring the functionality of the smart wallet feature. Test functions are generally essential for maintaining code quality and ensuring that features work as expected. Therefore, it is unlikely to be deleted unless the feature itself is deprecated or the testing framework is changed."
survived,"    def my_tool_with_result_as_answer(question: str) -> str:
        """"""This tool will return its result as the final answer.""""""
        return question
",tests/tools/test_base_tool.py,,1,4.1399375473943306e-08,"The method 'my_tool_with_result_as_answer' is a simple function that takes a string input and returns it as the output. It is a straightforward utility function that could be useful in scenarios where the input needs to be echoed back or logged. Since it is a basic and potentially useful function, it is likely to be retained in the codebase unless there are specific reasons for its removal, such as redundancy or a change in requirements."
survived,"def print_item(item):
    """"""Print an item.""""""
    if isinstance(item, dict):
        for key, value in item.items():
            if key not in [""created_at"", ""updated_at""]:
                print(f""  {key}: {value}"")
        print()
",codebase-architectures/layered-architecture/main.py,,1,4.1399375473943306e-08,"The method 'print_item' is a utility function that prints the contents of a dictionary, excluding specific keys ('created_at' and 'updated_at'). This type of function is generally useful for debugging or displaying data in a readable format. Since it serves a clear purpose and is not overly complex, it is likely to be retained in the codebase unless there is a significant change in requirements or a better utility function is introduced."
survived,"def logout_user(token: str) -> bool:
    """"""
    Logout a user by revoking their token.
    
    Args:
        token: The token to revoke
        
    Returns:
        True if the token was revoked, False otherwise
    """"""
    return revoke_token(token)
",codebase-architectures/atomic-composable-architecture/capabilities/user_management.py,,1,1.955568070542584e-08,"The method 'logout_user' is a straightforward utility function that serves a common purpose in applications that manage user sessions. It encapsulates the logic for revoking a user's token, which is a necessary operation for logging out users securely. The method is well-documented, with clear arguments and return types, making it easy to understand and maintain. Additionally, the function is likely to be part of a larger authentication or session management system, which is a critical component of many applications. Therefore, it is unlikely to be deleted as it provides essential functionality."
survived,"    def create_product(name, price, category_id=None, description=None, sku=None):
        """"""Create a new product.""""""
        try:
            # Validate product data
            if not name or not isinstance(name, str):
                raise ValueError(""Product name is required and must be a string"")
            
            try:
                price = float(price)
                if price < 0:
                    raise ValueError()
            except (ValueError, TypeError):
                raise ValueError(""Price must be a positive number"")
            
            # Validate category if provided
            if category_id:
                category = db.get(""categories"", category_id)
                if not category:
                    raise ValueError(f""Category with ID {category_id} not found"")
            
            # Validate SKU if provided
            if sku:
                existing_products = db.query(""products"", lambda p: p[""sku""] == sku)
                if existing_products:
                    raise ValueError(f""Product with SKU '{sku}' already exists"")
            
            # Create and save product
            product = Product(
                name=name,
                price=price,
                category_id=category_id,
                description=description,
                sku=sku
            )
            saved_product = db.insert(""products"", product.to_dict())
            Logger.info(app_logger, f""Created product: {name}"")
            return saved_product
        except Exception as e:
            Logger.error(app_logger, f""Error creating product: {str(e)}"", exc_info=True)
            raise
",codebase-architectures/layered-architecture/services/product_service.py,ProductService,1,1.4166087846364157e-09,"The method 'create_product' is a well-structured function that handles the creation of a product with proper validation and error handling. It checks for valid input types, ensures the price is a positive number, verifies the existence of a category if provided, and checks for SKU uniqueness. Additionally, it logs both successful creation and errors, which is crucial for debugging and auditing. These features make it a robust and useful function in a product management system, suggesting it is likely to be retained."
survived,"    def get_profile(token: str) -> Dict:
        """"""
        Get a user's profile.
        
        Args:
            token: Authentication token
            
        Returns:
            Response with success status and user data or error message
        """"""
        success, user_data = validate_user_token(token)
        
        if success:
            return {
                ""status"": ""success"",
                ""message"": ""Profile retrieved successfully"",
                ""data"": {""user"": user_data}
            }
        else:
            return {
                ""status"": ""error"",
                ""message"": ""Invalid or expired token"",
                ""data"": None
            }
",codebase-architectures/atomic-composable-architecture/endpoints/user_api.py,UserAPI,1,3.160881453314576e-10,"The method 'get_profile' is likely to survive because it performs a common and necessary function of retrieving a user's profile based on an authentication token. It includes proper error handling for invalid or expired tokens, which is essential for maintaining security and user experience. Additionally, the method is well-documented, making it easy to understand and maintain."
survived,"    def get_task(task_id):
        """"""Get a task by ID.""""""
        task_data = db.get(""tasks"", task_id)
        if not task_data:
            return None
        return task_data
",codebase-architectures/vertical-slice-architecture/features/tasks/service.py,TaskService,1,5.211412485172657e-10,"The method `get_task` is a straightforward utility function that retrieves a task by its ID from a database. It is a common pattern in software development to have such functions for data retrieval, especially in applications that interact with databases. The method is simple, clear, and serves a specific purpose, which is likely to be useful in various parts of an application that deals with task management. Unless there is a significant change in the application's architecture or database interaction strategy, this method is likely to remain useful and relevant."
survived,"    def transform_data(self, transform_func):
        """"""
        Apply a transformation function to the data.
        
        Args:
            transform_func: Function to transform the data
        
        Returns:
            dict: Stage result with data and metadata
        """"""
        if self.data is None:
            self.metadata[""status""] = ""error""
            self.metadata[""errors""].append(""No data loaded to transform"")
            return self._create_result()
        
        try:
            self.data = transform_func(self.data)
            self.metadata[""status""] = ""transformed""
            return self._create_result()
        except Exception as e:
            self.metadata[""status""] = ""error""
            self.metadata[""errors""].append(f""Transformation error: {str(e)}"")
            return self._create_result()
",codebase-architectures/pipeline-architecture/pipeline/input_stage.py,InputStage,1,3.160881453314576e-10,The method 'transform_data' is well-structured and serves a clear purpose of applying a transformation function to data. It includes error handling for cases where no data is loaded or if the transformation function raises an exception. This makes it robust and useful in a data processing pipeline. The method is likely to be retained as it provides essential functionality for data transformation with proper error management.
survived,"    def get_task(task_id):
        """"""Get a task by ID.""""""
        task = TaskService.get_task(task_id)
        if not task:
            return {""error"": f""Task with ID {task_id} not found""}
        return task
",codebase-architectures/vertical-slice-architecture/features/tasks/api.py,TaskAPI,1,1.2501528648238603e-09,"The method 'get_task' is a straightforward utility function that retrieves a task by its ID using a service class 'TaskService'. It includes error handling for cases where the task is not found, which is a common and necessary feature in such methods. This method is likely to be useful in various parts of an application where task retrieval is needed, and it follows a clear and concise pattern. Therefore, it is unlikely to be deleted."
survived,"    def create_collection(self, collection_name):
        """"""Create a new collection if it doesn't exist.""""""
        if collection_name not in self.data:
            self.data[collection_name] = {}
",codebase-architectures/vertical-slice-architecture/shared/db.py,InMemoryDB,1,1.2501528648238603e-09,"The method 'create_collection' is a basic utility function that checks if a collection exists in a data structure and creates it if it doesn't. This is a common and useful operation in many applications that manage collections or databases. The method is simple, efficient, and serves a clear purpose, making it likely to be retained in the codebase."
survived,"    def get_by_sku(sku):
        """"""Get a product by SKU.""""""
        try:
            products = db.query(""products"", lambda p: p[""sku""] == sku)
            if not products:
                Logger.warning(app_logger, f""Product with SKU '{sku}' not found"")
                return None
            return products[0]
        except Exception as e:
            Logger.error(app_logger, f""Error getting product by SKU: {str(e)}"", exc_info=True)
            raise
",codebase-architectures/layered-architecture/services/product_service.py,ProductService,1,1.4166087846364157e-09,"The method 'get_by_sku' is a utility function that retrieves a product from a database using its SKU. It includes error handling and logging, which are good practices for maintaining robust code. The method is likely to be useful in various parts of an application where product information needs to be fetched by SKU. Therefore, it is likely to be retained in the codebase."
survived,"    def create_product(name, price, category_id=None, description=None, sku=None):
        """"""Create a new product.""""""
        try:
            product = ProductService.create_product(name, price, category_id, description, sku)
            return {
                ""success"": True,
                ""message"": ""Product created successfully"",
                ""data"": product
            }
        except ValueError as e:
            Logger.warning(app_logger, f""Validation error in create_product: {str(e)}"")
            return {
                ""success"": False,
                ""message"": str(e)
            }
        except Exception as e:
            Logger.error(app_logger, f""Error in create_product: {str(e)}"", exc_info=True)
            return {
                ""success"": False,
                ""message"": ""An error occurred while creating the product""
            }
",codebase-architectures/layered-architecture/api/product_api.py,ProductAPI,1,1.493094675974231e-10,"The method 'create_product' is likely to survive because it is a well-structured function that handles product creation with error handling. It uses a service to create the product and logs warnings and errors appropriately, which is a good practice in software development. Additionally, it provides clear feedback to the caller about the success or failure of the operation, making it a useful and robust part of the codebase."
survived,"    def from_dict(cls, data):
        """"""Create a category from dictionary.""""""
        category = cls(
            name=data[""name""],
            description=data.get(""description""),
            id=data.get(""id"")
        )
        category.created_at = data.get(""created_at"", category.created_at)
        category.updated_at = data.get(""updated_at"", category.updated_at)
        return category",codebase-architectures/layered-architecture/models/category.py,Category,1,2.646573631904765e-09,"The method 'from_dict' is a common utility function used to create an instance of a class from a dictionary. This pattern is widely used in Python to facilitate the conversion of data structures, especially when dealing with JSON or other serialized data formats. The method is straightforward, leveraging class methods to instantiate objects, and it provides flexibility by allowing optional fields with default values. Given its utility and the fact that it adheres to common practices, it is likely to be retained in the codebase."
survived,"    def print_results(self, output_type=""summary""):
        """"""
        Print the results to the console.
        
        Args:
            output_type: Type of output to print (summary, detailed)
        
        Returns:
            dict: Stage result with data and metadata
        """"""
        try:
            if output_type == ""summary"" and hasattr(self, ""summary""):
                print(""\n===== SUMMARY REPORT ====="")
                print(f""Generated at: {self.summary['generated_at']}"")
                print(f""Data source: {self.summary['data_source']}"")
                print(f""Record count: {self.summary['record_count']}"")
                
                if ""statistics"" in self.summary:
                    print(""\n----- Statistics -----"")
                    for field, stats in self.summary[""statistics""].items():
                        print(f""\n{field}:"")
                        for stat_name, stat_value in stats.items():
                            print(f""  {stat_name}: {stat_value}"")
                
                if ""processing_steps"" in self.summary:
                    print(""\n----- Processing Steps -----"")
                    for step in self.summary[""processing_steps""]:
                        print(f""- {step}"")
                
            elif output_type == ""detailed"" and hasattr(self, ""detailed_report""):
                print(""\n===== DETAILED REPORT ====="")
                print(f""Generated at: {self.detailed_report['generated_at']}"")
                print(f""Data source: {self.detailed_report['data_source']}"")
                print(f""Record count: {self.detailed_report['record_count']}"")
                
                if ""analysis"" in self.detailed_report:
                    print(""\n----- Analysis -----"")
                    for analysis_type, analysis_data in self.detailed_report[""analysis""].items():
                        print(f""\n{analysis_type}:"")
                        print(json.dumps(analysis_data, indent=2))
                
                print(""\n----- Data Sample -----"")
                if isinstance(self.data, list):
                    sample_size = min(3, len(self.data))
                    for i in range(sample_size):
                        print(f""\nRecord {i+1}:"")
                        print(json.dumps(self.data[i], indent=2))
                else:
                    print(json.dumps(self.data, indent=2))
            
            else:
                print(""\n===== DATA OUTPUT ====="")
                if isinstance(self.data, list):
                    print(f""Record count: {len(self.data)}"")
                    sample_size = min(3, len(self.data))
                    print(f""\nShowing {sample_size} sample records:"")
                    for i in range(sample_size):
                        print(f""\nRecord {i+1}:"")
                        print(json.dumps(self.data[i], indent=2))
                else:
                    print(json.dumps(self.data, indent=2))
            
            # Update metadata
            self.metadata[""output_formats""].append(""console"")
            
            return self._create_result()
        except Exception as e:
            self.metadata[""status""] = ""error""
            self.metadata[""errors""].append(f""Print error: {str(e)}"")
            return self._create_result()
",codebase-architectures/pipeline-architecture/pipeline/output_stage.py,OutputStage,1,4.363462233903899e-09,"The method 'print_results' is a comprehensive utility function that provides a structured way to print different types of reports (summary and detailed) based on the 'output_type' parameter. It handles exceptions gracefully, updates metadata, and returns a result dictionary. Such functionality is often essential in data processing or reporting applications, making it a valuable method to retain. Additionally, the method is well-documented and follows good coding practices, which further supports its survival."
survived,"    def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """"""
        Process the input data by parsing and validating the tool use request.
        
        Args:
            data: The input data containing the tool use request
            
        Returns:
            Dictionary with the parsed request or error
        """"""
        try:
            console.log(f""[input_stage] Processing tool use request"")
            
            # Convert the tool use dictionary to a ToolUseRequest object
            request = ToolUseRequest.from_dict(data)
            
            console.log(f""[input_stage] Received command: {request.command}, path: {request.path}"")

            # Validate the request
            validation_result = self._validate_request(request)
            if not validation_result.success:
                console.log(f""[input_stage] Validation error: {validation_result.message}"")
                return {""error"": validation_result.message, ""stage"": ""input""}
            
            # Pass the validated request to the next stage
            return {
                ""request"": request,
                ""stage"": ""input"",
                ""status"": ""success""
            }
                
        except Exception as e:
            error_msg = f""Error in input stage: {str(e)}""
            console.print(f""[red]{error_msg}[/red]"")
            console.log(f""[input_stage] Error: {str(e)}"")
            console.log(traceback.format_exc())
            return {""error"": error_msg, ""stage"": ""input""}
",example-agent-codebase-arch/pipeline-architecture/steps/input_stage.py,InputStage,1,9.237449576640118e-09,"The method 'process' is a core part of handling and validating tool use requests, which is likely a critical functionality in the system. It includes error handling, logging, and validation, which are essential for robust software. Unless there is a significant change in the system's requirements or architecture, such methods are typically retained and maintained."
survived,"    def handle_tool_use(tool_use: Dict[str, Any]) -> Dict[str, Any]:
        """"""
        Handle text editor tool use from Claude.

        Args:
            tool_use: The tool use request from Claude

        Returns:
            Dictionary with result or error to send back to Claude
        """"""
        try:
            # Convert the tool use dictionary to a ToolUseRequest object
            request = ToolUseRequest.from_dict(tool_use)
            
            console.log(f""[handle_tool_use] Received command: {request.command}, path: {request.path}"")

            if not request.command:
                error_msg = ""No command specified in tool use request""
                console.log(f""[handle_tool_use] Error: {error_msg}"")
                return {""error"": error_msg}

            if not request.path and request.command != ""undo_edit"":  # undo_edit might not need a path
                error_msg = ""No path specified in tool use request""
                console.log(f""[handle_tool_use] Error: {error_msg}"")
                return {""error"": error_msg}

            # The path normalization is now handled in each file operation function
            console.print(f""[blue]Executing {request.command} command on {request.path}[/blue]"")

            result = None
            
            if request.command == ""view"":
                view_range = request.kwargs.get(""view_range"")
                console.log(
                    f""[handle_tool_use] Calling view_file with view_range: {view_range}""
                )
                result = FileOperationService.view_file(request.path, view_range)

            elif request.command == ""str_replace"":
                old_str = request.kwargs.get(""old_str"")
                new_str = request.kwargs.get(""new_str"")
                console.log(f""[handle_tool_use] Calling str_replace"")
                result = FileOperationService.str_replace(request.path, old_str, new_str)

            elif request.command == ""create"":
                file_text = request.kwargs.get(""file_text"")
                console.log(f""[handle_tool_use] Calling create_file"")
                result = FileOperationService.create_file(request.path, file_text)

            elif request.command == ""insert"":
                insert_line = request.kwargs.get(""insert_line"")
                new_str = request.kwargs.get(""new_str"")
                console.log(f""[handle_tool_use] Calling insert_text at line: {insert_line}"")
                result = FileOperationService.insert_text(request.path, insert_line, new_str)

            elif request.command == ""undo_edit"":
                console.log(f""[handle_tool_use] Calling undo_edit"")
                result = FileOperationService.undo_edit(request.path)

            else:
                error_msg = f""Unknown command: {request.command}""
                console.print(f""[red]{error_msg}[/red]"")
                console.log(f""[handle_tool_use] Error: {error_msg}"")
                return {""error"": error_msg}
            
            # Convert the result to a dictionary
            if result.success:
                return {""result"": result.data if result.data is not None else result.message}
            else:
                return {""error"": result.message}
                
        except Exception as e:
            error_msg = f""Error handling tool use: {str(e)}""
            console.print(f""[red]{error_msg}[/red]"")
            console.log(f""[handle_tool_use] Error: {str(e)}"")
            console.log(traceback.format_exc())
            return {""error"": error_msg}",example-agent-codebase-arch/vertical-slice-architecture/features/file_operations/api.py,FileOperationsAPI,1,9.736200303530205e-10,"The method 'handle_tool_use' is well-structured and serves a clear purpose of handling different text editor tool commands. It includes error handling, logging, and supports multiple operations like view, str_replace, create, insert, and undo_edit. The method is likely part of a larger system that interacts with a text editor, and its functionality is essential for processing tool use requests. Given its comprehensive implementation and utility, it is likely to be retained in the codebase."
survived,"    def __init__(self, success: bool, message: str, data: Any = None):
        """"""
        Initialize a file operation result.
        
        Args:
            success: Whether the operation was successful
            message: A message describing the result
            data: Optional data returned by the operation
        """"""
        self.success = success
        self.message = message
        self.data = data
",example-agent-codebase-arch/layered-architecture/models/tool_models.py,FileOperationResult,1,1.3440409770490404e-08,"The method is a constructor for a class, likely used to initialize instances with specific attributes. It is a common pattern in object-oriented programming to define an __init__ method to set up initial state for objects. This method is well-documented, follows standard practices, and provides flexibility with an optional parameter. There is no indication that it is redundant or poorly designed, so it is likely to be retained."
survived,"    def insert_text(path: str, insert_line: int, new_str: str) -> FileOperationResult:
        """"""
        Insert text at a specific location in a file.

        Args:
            path: The path to the file to modify
            insert_line: The line number after which to insert the text
            new_str: The text to insert

        Returns:
            FileOperationResult with result or error message
        """"""
        try:
            if not path or not path.strip():
                error_msg = ""Invalid file path provided: path is empty.""
                console.log(f""[insert_text] Error: {error_msg}"")
                return FileOperationResult(False, error_msg)

            # Normalize the path
            path = normalize_path(path)

            if not os.path.exists(path):
                error_msg = f""File {path} does not exist""
                console.log(f""[insert_text] Error: {error_msg}"")
                return FileOperationResult(False, error_msg)

            if insert_line is None:
                error_msg = ""No line number specified: insert_line is missing.""
                console.log(f""[insert_text] Error: {error_msg}"")
                return FileOperationResult(False, error_msg)

            with open(path, ""r"") as f:
                lines = f.readlines()

            # Line is 0-indexed for this function, but Claude provides 1-indexed
            insert_line = min(max(0, insert_line - 1), len(lines))

            # Check that the index is within acceptable bounds
            if insert_line < 0 or insert_line > len(lines):
                error_msg = (
                    f""Insert line number {insert_line} out of range (0-{len(lines)}).""
                )
                console.log(f""[insert_text] Error: {error_msg}"")
                return FileOperationResult(False, error_msg)

            # Ensure new_str ends with newline
            if new_str and not new_str.endswith(""\n""):
                new_str += ""\n""

            lines.insert(insert_line, new_str)

            with open(path, ""w"") as f:
                f.writelines(lines)

            console.print(
                f""[green]Successfully inserted text at line {insert_line + 1} in {path}[/green]""
            )
            console.log(
                f""[insert_text] Successfully inserted text at line {insert_line + 1} in {path}""
            )
            return FileOperationResult(
                True, f""Successfully inserted text at line {insert_line + 1} in {path}""
            )
        except Exception as e:
            error_msg = f""Error inserting text: {str(e)}""
            console.print(f""[red]{error_msg}[/red]"")
            console.log(f""[insert_text] Error: {str(e)}"")
            console.log(traceback.format_exc())
            return FileOperationResult(False, error_msg)
",example-agent-codebase-arch/vertical-slice-architecture/features/file_operations/service.py,FileOperationService,1,1.8189616842444243e-09,"The method 'insert_text' is a utility function that provides a useful feature for inserting text into a file at a specified line. It includes error handling, path normalization, and logging, making it robust and informative. Such utility functions are often retained in codebases because they encapsulate common file manipulation tasks that can be reused across different parts of an application. Additionally, the method returns a structured result, which is a good practice for error handling and reporting. Therefore, it is likely to be retained."
survived,"def display_file_content(path: str, content: str) -> None:
    """"""
    Display file content with syntax highlighting

    Args:
        path: Path to the file
        content: Content of the file
    """"""
    file_extension = os.path.splitext(path)[1][1:]  # Get extension without the dot
    syntax = Syntax(content, file_extension or ""text"", line_numbers=True)
    console.print(Panel(syntax, title=f""File: {path}""))
",example-agent-codebase-arch/pipeline-architecture/shared/utilities.py,,1,7.582560422162384e-10,"The method 'display_file_content' is a utility function that provides a useful feature of displaying file content with syntax highlighting. This is a common requirement in many applications, especially those dealing with code or configuration files. The method is well-defined, with clear arguments and usage of external libraries like 'Syntax' and 'Panel' for enhanced display. Unless there is a significant change in the application's requirements or a better alternative is introduced, this method is likely to be retained."
survived,"    def create_file(path: str, file_text: str) -> FileOperationResult:
        """"""
        Create a new file with specified content.

        Args:
            path: The path where the new file should be created
            file_text: The content to write to the new file

        Returns:
            FileOperationResult with result or error message
        """"""
        try:
            # Check if the path is empty or invalid
            if not path or not path.strip():
                error_msg = ""Invalid file path provided: path is empty.""
                Logger.error(app_logger, f""[create_file] {error_msg}"")
                return FileOperationResult(False, error_msg)

            # Normalize the path
            path = normalize_path(path)

            # Check if the directory exists
            directory = os.path.dirname(path)
            if directory and not os.path.exists(directory):
                Logger.info(app_logger, f""[create_file] Creating directory: {directory}"")
                os.makedirs(directory)

            with open(path, ""w"") as f:
                f.write(file_text or """")

            Logger.info(app_logger, f""[create_file] Successfully created file {path}"")
            return FileOperationResult(True, f""Successfully created file {path}"")
        except Exception as e:
            error_msg = f""Error creating file: {str(e)}""
            Logger.error(app_logger, f""[create_file] {error_msg}"", exc_info=True)
            return FileOperationResult(False, error_msg)
",example-agent-codebase-arch/layered-architecture/services/file_service.py,FileService,1,1.8189616842444243e-09,"The method 'create_file' is a utility function that handles file creation, including error handling and logging. It checks for valid paths, creates directories if necessary, and writes content to a file. These are common and necessary operations in many applications, making this method useful and likely to be retained. Additionally, it returns a structured result indicating success or failure, which is a good practice for robust code."
survived,"    def undo_edit(path: str) -> FileOperationResult:
        """"""
        Placeholder for undo_edit functionality.
        In a real implementation, you would need to track edit history.

        Args:
            path: The path to the file whose last edit should be undone

        Returns:
            FileOperationResult with message about undo functionality
        """"""
        try:
            if not path or not path.strip():
                error_msg = ""Invalid file path provided: path is empty.""
                console.log(f""[undo_edit] Error: {error_msg}"")
                return FileOperationResult(False, error_msg)

            # Normalize the path
            path = normalize_path(path)

            message = ""Undo functionality is not implemented in this version.""
            console.print(f""[yellow]{message}[/yellow]"")
            console.log(f""[undo_edit] {message}"")
            return FileOperationResult(True, message)
        except Exception as e:
            error_msg = f""Error in undo_edit: {str(e)}""
            console.print(f""[red]{error_msg}[/red]"")
            console.log(f""[undo_edit] Error: {str(e)}"")
            console.log(traceback.format_exc())
            return FileOperationResult(False, error_msg)",example-agent-codebase-arch/vertical-slice-architecture/features/file_operations/service.py,FileOperationService,0,0.9999970976877992,"The method 'undo_edit' is a placeholder and does not perform any actual undo operation. It simply logs messages and returns a message indicating that the functionality is not implemented. This suggests that the method is not currently useful in its present form and is likely to be deleted unless it is further developed to include actual undo functionality. Additionally, the presence of a placeholder comment indicates that the method is not complete, which further supports the likelihood of deletion if not updated."
survived,"    def __init__(self, db_path: Optional[str] = None):
        """"""Initialize SQLite persistence.
        
        Args:
            db_path: Path to the SQLite database file. If not provided, uses
                    CREWAI_FLOW_DB_PATH environment variable or falls back to
                    a temporary database.
        """"""
        self.db_path = db_path or os.getenv(
            ""CREWAI_FLOW_DB_PATH"",
            os.path.join(tempfile.gettempdir(), ""crewai_flows.db"")
        )
        self.init_db()
",src/crewai/flow/persistence/sqlite.py,SQLiteFlowPersistence,1,2.2159489282323004e-08,"The method is a constructor for initializing a class with a database path, which is a common and necessary functionality in many applications. It provides flexibility by allowing the path to be set via an argument, an environment variable, or a default temporary path. This makes the method robust and adaptable to different deployment environments. Such methods are typically essential for the operation of the class and are unlikely to be removed unless the entire class is deprecated or significantly refactored."
survived,"def test_persistence_error_handling(tmp_path):
    """"""Test error handling in persistence operations.""""""
    db_path = os.path.join(tmp_path, ""test_flows.db"")
    persistence = SQLiteFlowPersistence(db_path)
    
    class InvalidFlow(Flow[TestState]):
        # Missing id field in initial state
        class InvalidState(BaseModel):
            value: str = """"
            
        initial_state = InvalidState
        
        @start()
        @persist(persistence)
        def will_fail(self):
            self.state.value = ""test""
    
    with pytest.raises(ValueError) as exc_info:
        flow = InvalidFlow(persistence=persistence)
        flow.kickoff()
    
    assert ""must have an 'id' field"" in str(exc_info.value)",tests/test_flow_persistence.py,,1,2.5109990926928157e-08,"The method is a test function that checks error handling in persistence operations. It is well-structured, uses a temporary path for testing, and verifies that an exception is raised when expected. This is a common and necessary practice in software development to ensure robustness and reliability of code. Therefore, it is likely to be retained as part of the test suite."
survived,"def test_multiple_method_persistence(tmp_path):
    """"""Test state persistence across multiple method executions.""""""
    db_path = os.path.join(tmp_path, ""test_flows.db"")
    persistence = SQLiteFlowPersistence(db_path)
    
    class MultiStepFlow(Flow[TestState]):
        initial_state = TestState
        
        @start()
        @persist(persistence)
        def step_1(self):
            self.state.counter = 1
            self.state.message = ""Step 1""
        
        @start()
        @persist(persistence)
        def step_2(self):
            self.state.counter = 2
            self.state.message = ""Step 2""
    
    flow = MultiStepFlow(persistence=persistence)
    flow.kickoff()
    
    # Load final state
    final_state = persistence.load_state(flow.state.id)
    assert final_state is not None
    assert final_state[""counter""] == 2
    assert final_state[""message""] == ""Step 2""
",tests/test_flow_persistence.py,,1,1.0467401685178159e-08,"The method 'test_multiple_method_persistence' is a unit test designed to verify the persistence of state across multiple method executions in a flow. It is a crucial part of ensuring that the system behaves as expected when using persistence mechanisms like SQLite. Such tests are essential for maintaining the integrity and reliability of the software, especially in systems where state persistence is critical. Therefore, it is unlikely to be deleted as it serves an important purpose in the testing suite."
survived,"        def init_step(self):
            self.state[""message""] = ""Hello, World!""
            self.state[""id""] = ""test-uuid""  # Ensure we have an ID for persistence
",tests/test_flow_persistence.py,TestFlow,1,2.8453347280241004e-08,"The method 'init_step' is initializing a state with a message and an ID, which seems to be a fundamental part of setting up the object's state. This kind of method is typically essential for the correct functioning of the object, especially if the state is used in other parts of the code. Therefore, it is likely to be retained."
survived,"def jsonrpc(options: JSONRpcPluginOptions) -> JSONRpcPlugin:
    return JSONRpcPlugin(options)",python/src/plugins/jsonrpc/goat_plugins/jsonrpc/__init__.py,,1,3.3982678079468468e-09,"The method 'jsonrpc' is a simple factory function that takes an instance of 'JSONRpcPluginOptions' and returns a new 'JSONRpcPlugin' object initialized with those options. This is a common pattern in programming, especially in plugin or configuration-based systems, where you want to encapsulate the creation logic of an object. The method is straightforward, serves a clear purpose, and is likely to be useful in contexts where JSON-RPC plugins are needed. Therefore, it is unlikely to be deleted unless the entire plugin system is refactored or removed."
survived,"def test_xai_raw_response_sync(model, mode):
    """"""Test that _raw_response is attached to sync XAI responses""""""
    client = instructor.from_provider(f""xai/{model}"", mode=mode)
    
    user = client.chat.completions.create(
        response_model=User,
        messages=[
            {
                ""role"": ""system"",
                ""content"": ""You are a helpful assistant that extracts information."",
            },
            {
                ""role"": ""user"",
                ""content"": ""Extract: Jason is 25 years old."",
            },
        ],
    )
    
    assert isinstance(user, User)
    assert user.name.lower() == ""jason""
    assert user.age == 25
    assert hasattr(user, ""_raw_response""), (
        ""The raw response should be available from XAI""
    )
    assert user._raw_response is not None
",tests/llm/test_xai/test_raw_response.py,,1,9.237449576640118e-09,"The method 'test_xai_raw_response_sync' is a test function that verifies the functionality of a specific feature in a system, specifically checking if the '_raw_response' attribute is correctly attached to the response object. Test functions are generally crucial for ensuring code reliability and are not typically deleted unless they are redundant or replaced by more comprehensive tests. Since this function seems to be directly testing a feature related to XAI (Explainable AI), which is a significant aspect of AI systems, it is likely to be retained to ensure the feature works as expected."
survived,"async def test_xai_create_with_completion_async():
    """"""Test that create_with_completion works with XAI provider in async mode""""""
    client = instructor.from_provider(""xai/grok-3-mini"", mode=instructor.Mode.XAI_JSON, async_client=True)
    
    user, raw_response = await client.chat.completions.create_with_completion(
        response_model=User,
        messages=[
            {
                ""role"": ""system"",
                ""content"": ""You are a helpful assistant that extracts information."",
            },
            {
                ""role"": ""user"",
                ""content"": ""Extract: Jason is 25 years old."",
            },
        ],
    )
    
    assert isinstance(user, User)
    assert user.name.lower() == ""jason""
    assert user.age == 25
    assert hasattr(user, ""_raw_response""), (
        ""The raw response should be available from XAI""
    )
    assert raw_response is not None
    assert user._raw_response == raw_response",tests/llm/test_xai/test_raw_response.py,,1,9.237449576640118e-09,"The method is testing an asynchronous function that interacts with an XAI provider to extract information from a given message. This is a relevant and modern use case, especially with the increasing use of AI and asynchronous programming in software development. The test checks for correct data extraction and response handling, which are crucial for ensuring the reliability of AI-driven applications. Therefore, the method is likely to be maintained and not deleted."
